<div class="ocaml_toplevel_module"><div class="info">String type based on <code class="code">Bigarray</code>, for use in I/O and C-bindings</div>
<div class="ocaml_include ident" path="?package=core_kernel&amp;module=Std.Bigstring" items="[&quot;From_string&quot;,&quot;To_string&quot;]"><pre><span class="keyword">include</span> <code class="type">module type of <code class="code"><a href="?package=core_kernel&amp;module=Std.Bigstring">Core_kernel.Std.Bigstring</a></code> with type t = <a href="?package=core_kernel&amp;module=Std.Bigstring&amp;type=t">Core_kernel.Std.Bigstring.t</a></code></pre></div>
<pre><span class="EXCEPTIONIOError"><span class="keyword">exception</span> IOError</span> <span class="keyword">of</span> <code class="type">int * exn</code></pre><div class="info"><div class="info">Type of I/O errors</div><div class="info">The occurred exception (e.g. Unix_error, End_of_file)</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Input functions</h6></div></div>
<pre><span class="VALread"><span class="keyword">val</span> read</span> : <code class="type">?min_len:int -&gt; <a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; ?pos:int -&gt; ?len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">read ?min_len fd ?pos ?len bstr</code> reads at least <code class="code">min_len</code> (must be
    greater than or equal zero) and at most <code class="code">len</code> (must be greater than
    or equal to <code class="code">min_len</code>) bytes from file descriptor <code class="code">fd</code>, and writes
    them to bigstring <code class="code">bstr</code> starting at position <code class="code">pos</code>.<div class="parameters"><div class="param_info"><code class="code">pos</code> : default = 0</div><div class="param_info"><code class="code">min_len</code> : default = 0</div><div class="param_info"><code class="code">len</code> : default = <code class="code">length bstr - pos</code></div></div> <b>Raises</b> <code>Invalid_argument</code> if the designated ranges are out of bounds.<br/><code>IOError</code> in the case of input errors, or on EOF if the
    minimum length could not be read.<br/> <b>Returns</b> the
    number of bytes actually read.<p>    NOTE: even if <code class="code">len</code> is zero, there may still be errors when reading
    from the descriptor!</p></div></div>
<pre><span class="VALreally_read"><span class="keyword">val</span> really_read</span> : <code class="type"><a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; ?pos:int -&gt; ?len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">really_read fd ?pos ?len bstr</code> reads <code class="code">len</code> bytes from file descriptor
    <code class="code">fd</code>, and writes them to bigstring <code class="code">bstr</code> starting at position <code class="code">pos</code>.<div class="parameters"><div class="param_info"><code class="code">pos</code> : default = 0</div><div class="param_info"><code class="code">len</code> : default = <code class="code">length bstr - pos</code></div></div> <b>Raises</b> <code>Invalid_argument</code> if the designated range is out of bounds.<br/><code>IOError</code> in the case of input errors, or on EOF.<br/></div></div>
<pre><span class="VALreally_recv"><span class="keyword">val</span> really_recv</span> : <code class="type"><a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; ?pos:int -&gt; ?len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">really_recv sock ?pos ?len bstr</code> receives <code class="code">len</code> bytes from socket
    <code class="code">sock</code>, and writes them to bigstring <code class="code">bstr</code> starting at position
    <code class="code">pos</code>.  If <code class="code">len</code> is zero, the function returns immediately without
    performing the underlying system call.<div class="parameters"><div class="param_info"><code class="code">pos</code> : default = 0</div><div class="param_info"><code class="code">len</code> : default = <code class="code">length bstr - pos</code></div></div> <b>Raises</b> <code>Invalid_argument</code> if the designated range is out of bounds.<br/><code>IOError</code> in the case of input errors, or on EOF.<br/></div></div>
<pre><span class="VALrecvfrom_assume_fd_is_nonblocking"><span class="keyword">val</span> recvfrom_assume_fd_is_nonblocking</span> : <code class="type"><a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; ?pos:int -&gt; ?len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; int * <a href="?package=ocaml&amp;module=Unix&amp;type=sockaddr">Unix.sockaddr</a></code></pre><div class="info"><div class="info"><code class="code">recvfrom_assume_fd_is_nonblocking sock ?pos ?len bstr</code> reads up to
    <code class="code">len</code> bytes into bigstring <code class="code">bstr</code> starting at position <code class="code">pos</code> from
    socket <code class="code">sock</code> without yielding to other OCaml-threads.<div class="parameters"><div class="param_info"><code class="code">pos</code> : default = 0</div><div class="param_info"><code class="code">len</code> : default = <code class="code">length bstr - pos</code></div></div> <b>Raises</b> <code>Unix_error</code> in the case of input errors.<br/><code>Invalid_argument</code> if the designated range is out of bounds.<br/> <b>Returns</b> the number of bytes actually read and the socket address of
    the client.</div></div>
<pre><span class="VALread_assume_fd_is_nonblocking"><span class="keyword">val</span> read_assume_fd_is_nonblocking</span> : <code class="type"><a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; ?pos:int -&gt; ?len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">read_assume_fd_is_nonblocking fd ?pos ?len bstr</code> reads up to
    <code class="code">len</code> bytes into bigstring <code class="code">bstr</code> starting at position <code class="code">pos</code> from
    file descriptor <code class="code">fd</code> without yielding to other OCaml-threads.<div class="parameters"><div class="param_info"><code class="code">pos</code> : default = 0</div><div class="param_info"><code class="code">len</code> : default = <code class="code">length bstr - pos</code></div></div> <b>Raises</b> <code>Unix_error</code> in the case of input errors.<br/><code>Invalid_argument</code> if the designated range is out of bounds.<br/> <b>Returns</b> the number of bytes actually read.</div></div>
<pre><span class="VALpread_assume_fd_is_nonblocking"><span class="keyword">val</span> pread_assume_fd_is_nonblocking</span> : <code class="type"><a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; offset:int -&gt; ?pos:int -&gt; ?len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">pread_assume_fd_is_nonblocking fd ~offset ?pos ?len bstr</code> reads up to <code class="code">len</code> bytes
    from file descriptor <code class="code">fd</code> at offset <code class="code">offset</code>, and writes them to bigstring <code class="code">bstr</code>
    starting at position <code class="code">pos</code>.  The fd must be capable of seeking, and the current file
    offset used for a regular <code class="code">read()</code> is unchanged. Please see 'man pread' for more
    information.<div class="parameters"><div class="param_info"><code class="code">pos</code> : default = 0</div><div class="param_info"><code class="code">len</code> : default = <code class="code">length bstr - pos</code></div></div> <b>Raises</b> <code>Invalid_argument</code> if the designated range is out of bounds.<br/><code>IOError</code> in the case of input errors, or on EOF.<br/> <b>Returns</b> the number of bytes actually read.</div></div>
<pre><span class="VALinput"><span class="keyword">val</span> input</span> : <code class="type">?min_len:int -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=in_channel">Pervasives.in_channel</a> -&gt; ?pos:int -&gt; ?len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">input ?min_len ic ?pos ?len bstr</code> tries to read <code class="code">len</code> bytes
    (guarantees to read at least <code class="code">min_len</code> bytes (must be greater than
    or equal to zero and smaller or equal to <code class="code">len</code>), if possible, before
    returning) from input channel <code class="code">ic</code>, and writes them to bigstring
    <code class="code">bstr</code> starting at position <code class="code">pos</code>.<div class="parameters"><div class="param_info"><code class="code">pos</code> : default = 0</div><div class="param_info"><code class="code">min_len</code> : default = 0</div><div class="param_info"><code class="code">len</code> : default = <code class="code">length bstr - pos</code></div></div> <b>Raises</b> <code>Invalid_argument</code> if the designated range is out of bounds.<br/><code>IOError</code> in the case of input errors, or on premature EOF.<br/> <b>Returns</b> the number of bytes
    actually read.<p>    NOTE: even if <code class="code">len</code> is zero, there may still be errors when reading
    from the descriptor, which will be done if the internal buffer
    is empty!</p><p>    NOTE: if at least <code class="code">len</code> characters are available in the input channel
    buffer and if <code class="code">len</code> is not zero, data will only be fetched from the
    channel buffer.  Otherwise data will be read until at least <code class="code">min_len</code>
    characters are available.</p></div></div>
<pre><span class="VALreally_input"><span class="keyword">val</span> really_input</span> : <code class="type"><a href="?package=ocaml&amp;module=Pervasives&amp;type=in_channel">Pervasives.in_channel</a> -&gt; ?pos:int -&gt; ?len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">really_input ic ?pos ?len bstr</code> reads exactly <code class="code">len</code> bytes from
    input channel <code class="code">ic</code>, and writes them to bigstring <code class="code">bstr</code> starting at
    position <code class="code">pos</code>.<div class="parameters"><div class="param_info"><code class="code">pos</code> : default = 0</div><div class="param_info"><code class="code">len</code> : default = <code class="code">length bstr - pos</code></div></div> <b>Raises</b> <code>Invalid_argument</code> if the designated range is out of bounds.<br/><code>IOError</code> in the case of input errors, or on premature EOF.<br/></div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Output functions</h6></div></div>
<pre><span class="VALreally_write"><span class="keyword">val</span> really_write</span> : <code class="type"><a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; ?pos:int -&gt; ?len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">really_write fd ?pos ?len bstr</code> writes <code class="code">len</code> bytes in bigstring
    <code class="code">bstr</code> starting at position <code class="code">pos</code> to file descriptor <code class="code">fd</code>.<div class="parameters"><div class="param_info"><code class="code">pos</code> : default = 0</div><div class="param_info"><code class="code">len</code> : default = <code class="code">length bstr - pos</code></div></div> <b>Raises</b> <code>Invalid_argument</code> if the designated range is out of bounds.<br/><code>IOError</code> in the case of output errors.<br/></div></div>
<pre><span class="VALreally_send_no_sigpipe"><span class="keyword">val</span> really_send_no_sigpipe</span> : <code class="type">(<a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; ?pos:int -&gt; ?len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; unit)
<a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">really_send_no_sigpipe sock ?pos ?len bstr</code> sends <code class="code">len</code> bytes in
    bigstring <code class="code">bstr</code> starting at position <code class="code">pos</code> to socket <code class="code">sock</code> without
    blocking and ignoring <code class="code">SIGPIPE</code>.<div class="parameters"><div class="param_info"><code class="code">pos</code> : default = 0</div><div class="param_info"><code class="code">len</code> : default = <code class="code">length bstr - pos</code><p>    <code class="code">really_send_no_sigpipe</code> is not implemented on some platforms, in which
    case it is an <code class="code">Error</code> value that indicates that it is unimplemented.</p></div></div> <b>Raises</b> <code>Invalid_argument</code> if the designated range is out of bounds.<br/><code>IOError</code> in the case of output errors.<br/></div></div>
<pre><span class="VALsend_nonblocking_no_sigpipe"><span class="keyword">val</span> send_nonblocking_no_sigpipe</span> : <code class="type">(<a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; ?pos:int -&gt; ?len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; int option)
<a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">send_nonblocking_no_sigpipe sock ?pos ?len bstr</code> tries to send
    <code class="code">len</code> bytes in bigstring <code class="code">bstr</code> starting at position <code class="code">pos</code> to socket
    <code class="code">sock</code>.<div class="parameters"><div class="param_info"><code class="code">pos</code> : default = 0</div><div class="param_info"><code class="code">len</code> : default = <code class="code">length bstr - pos</code></div></div> <b>Raises</b> <code>Invalid_argument</code> if the designated range is out of bounds.<br/><code>Unix_error</code> in the case of output errors.<br/> <b>Returns</b> <code class="code">Some bytes_written</code>, or <code class="code">None</code> if the operation
    would have blocked.</div></div>
<pre><span class="VALsendto_nonblocking_no_sigpipe"><span class="keyword">val</span> sendto_nonblocking_no_sigpipe</span> : <code class="type">(<a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; ?pos:int -&gt; ?len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; <a href="?package=ocaml&amp;module=Unix&amp;type=sockaddr">Unix.sockaddr</a> -&gt; int option)
<a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">sendto_nonblocking_no_sigpipe sock ?pos ?len bstr sockaddr</code> tries
    to send <code class="code">len</code> bytes in bigstring <code class="code">bstr</code> starting at position <code class="code">pos</code>
    to socket <code class="code">sock</code> using address <code class="code">addr</code>.<div class="parameters"><div class="param_info"><code class="code">pos</code> : default = 0</div><div class="param_info"><code class="code">len</code> : default = <code class="code">length bstr - pos</code></div></div> <b>Raises</b> <code>Invalid_argument</code> if the designated range is out of bounds.<br/><code>Unix_error</code> in the case of output errors.<br/> <b>Returns</b> <code class="code">Some bytes_written</code>,
    or <code class="code">None</code> if the operation would have blocked.</div></div>
<pre><span class="VALwrite"><span class="keyword">val</span> write</span> : <code class="type"><a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; ?pos:int -&gt; ?len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">write fd ?pos ?len bstr</code> writes <code class="code">len</code>
    bytes in bigstring <code class="code">bstr</code> starting at position <code class="code">pos</code> to file
    descriptor <code class="code">fd</code>.<div class="parameters"><div class="param_info"><code class="code">pos</code> : default = 0</div><div class="param_info"><code class="code">len</code> : default = <code class="code">length bstr - pos</code></div></div> <b>Raises</b> <code>Unix_error</code> in the case of output errors.<br/><code>Invalid_argument</code> if the designated range is out of bounds.<br/> <b>Returns</b> the number of bytes actually written.</div></div>
<pre><span class="VALpwrite_assume_fd_is_nonblocking"><span class="keyword">val</span> pwrite_assume_fd_is_nonblocking</span> : <code class="type"><a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; offset:int -&gt; ?pos:int -&gt; ?len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">pwrite_assume_fd_is_nonblocking fd ~offset ?pos ?len bstr</code> writes up to <code class="code">len</code> bytes
    of bigstring <code class="code">bstr</code> starting at position <code class="code">pos</code> to file descriptor <code class="code">fd</code> at position
    <code class="code">offset</code>.  The fd must be capable of seeking, and the current file offset used for
    non-positional <code class="code">read()</code>/<code class="code">write()</code> calls is unchanged.<div class="parameters"><div class="param_info"><code class="code">pos</code> : default = 0</div><div class="param_info"><code class="code">len</code> : default = <code class="code">length bstr - pos</code></div></div> <b>Raises</b> <code>Invalid_argument</code> if the designated range is out of bounds.<br/><code>IOError</code> in the case of input errors, or on EOF.<br/> <b>Returns</b> the number of bytes
    written.</div></div>
<pre><span class="VALwrite_assume_fd_is_nonblocking"><span class="keyword">val</span> write_assume_fd_is_nonblocking</span> : <code class="type"><a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; ?pos:int -&gt; ?len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">write_assume_fd_is_nonblocking fd ?pos ?len bstr</code> writes <code class="code">len</code>
    bytes in bigstring <code class="code">bstr</code> starting at position <code class="code">pos</code> to file
    descriptor <code class="code">fd</code> without yielding to other OCaml-threads.<div class="parameters"><div class="param_info"><code class="code">pos</code> : default = 0</div><div class="param_info"><code class="code">len</code> : default = <code class="code">length bstr - pos</code></div></div> <b>Raises</b> <code>Unix_error</code> in the case of output errors.<br/><code>Invalid_argument</code> if the designated range is out of bounds.<br/> <b>Returns</b> the
    number of bytes actually written.</div></div>
<pre><span class="VALwritev"><span class="keyword">val</span> writev</span> : <code class="type"><a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; ?count:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> <a href="?package=core&amp;module=Core_unix.IOVec&amp;type=t">Core_unix.IOVec.t</a> array -&gt; int</code></pre><div class="info"><div class="info"><code class="code">writev fd ?count iovecs</code> writes <code class="code">count</code> <code class="code">iovecs</code> of
    bigstrings to file descriptor <code class="code">fd</code>.<div class="parameters"><div class="param_info"><code class="code">count</code> : default = <code class="code">Array.length iovecs</code></div></div> <b>Raises</b> <code>Unix_error</code> in the case of output errors.<br/><code>Invalid_argument</code> if count is out of range.<br/> <b>Returns</b> the number of bytes
    written.</div></div>
<pre><span class="VALwritev_assume_fd_is_nonblocking"><span class="keyword">val</span> writev_assume_fd_is_nonblocking</span> : <code class="type"><a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; ?count:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> <a href="?package=core&amp;module=Core_unix.IOVec&amp;type=t">Core_unix.IOVec.t</a> array -&gt; int</code></pre><div class="info"><div class="info"><code class="code">writev_assume_fd_is_nonblocking fd ?count iovecs</code> writes <code class="code">count</code>
    <code class="code">iovecs</code> of bigstrings to file descriptor <code class="code">fd</code> without yielding to
    other OCaml-threads.<div class="parameters"><div class="param_info"><code class="code">count</code> : default = <code class="code">Array.length iovecs</code></div></div> <b>Raises</b> <code>Unix_error</code> in the case of output errors.<br/><code>Invalid_argument</code> if the designated range is out of bounds.<br/> <b>Returns</b> the number of bytes actually written.</div></div>
<pre><span class="VALrecvmmsg_assume_fd_is_nonblocking"><span class="keyword">val</span> recvmmsg_assume_fd_is_nonblocking</span> : <code class="type">(<a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt;
 ?count:int -&gt;
 ?srcs:<a href="?package=ocaml&amp;module=Unix&amp;type=sockaddr">Unix.sockaddr</a> array -&gt;
 <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> <a href="?package=core&amp;module=Core_unix.IOVec&amp;type=t">Core_unix.IOVec.t</a> array -&gt; lens:int array -&gt; int)
<a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">recvmmsg_assume_fd_is_nonblocking fd iovecs ~count ~lens</code> receives up to <code class="code">count</code>
    messages into <code class="code">iovecs</code> from file descriptor <code class="code">fd</code> without yielding to other OCaml
    threads.  If <code class="code">~count</code> is supplied, it must be that <code class="code">0 &lt;= count &lt;= Array.length
    iovecs</code>.  If <code class="code">~srcs</code> is supplied, save the source addresses for corresponding recieved
    messages there.  If supplied, <code class="code">Array.length srcs</code> must be <code class="code">&gt;= count</code>.  Save the
    lengths of the received messages in <code class="code">lens</code>.  It is required that <code class="code">Array.length lens &gt;=
    count</code>.<p>    If an IOVec isn't long enough for its corresponding message, excess bytes may be
    discarded, depending on the type of socket the message is received from.  While the
    <code class="code">recvmmsg</code> system call itself does return details of such truncation, etc., those
    details are not (yet) passed through this interface.</p><div class="see"><b>See also</b> <ul>  <li><i class="doc">recvmmsg(2) </i>re. the underlying system call.</li></ul></div><div class="parameters"><div class="param_info"><code class="code">count</code> : default = <code class="code">Array.length iovecs</code></div></div> <b>Raises</b> <code>Unix_error</code> in the case of output errors.<br/><code>Invalid_argument</code> if the designated range is out of bounds.<br/> <b>Returns</b> the number of messages actually read.</div></div>
<pre><span class="VALsendmsg_nonblocking_no_sigpipe"><span class="keyword">val</span> sendmsg_nonblocking_no_sigpipe</span> : <code class="type">(<a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; ?count:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> <a href="?package=core&amp;module=Core_unix.IOVec&amp;type=t">Core_unix.IOVec.t</a> array -&gt; int option)
<a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">sendmsg_nonblocking_no_sigpipe sock ?count iovecs</code> sends
    <code class="code">count</code> <code class="code">iovecs</code> of bigstrings to socket <code class="code">sock</code>.<div class="parameters"><div class="param_info"><code class="code">count</code> : default = <code class="code">Array.length iovecs</code></div></div> <b>Raises</b> <code>Unix_error</code> in the case of output errors.<br/><code>Invalid_argument</code> if <code class="code">count</code> is out of range.<br/> <b>Returns</b> <code class="code">Some
    bytes_written</code>, or <code class="code">None</code> if the operation would have blocked.
    This system call will not cause signal <code class="code">SIGPIPE</code> if an attempt is
    made to write to a socket that was closed by the other side.</div></div>
<pre><span class="VALoutput"><span class="keyword">val</span> output</span> : <code class="type">?min_len:int -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=out_channel">Pervasives.out_channel</a> -&gt; ?pos:int -&gt; ?len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">output ?min_len oc ?pos ?len bstr</code> tries to output
    <code class="code">len</code> bytes (guarantees to write at least <code class="code">min_len</code> bytes (must be
    equal to or greater than zero), if possible, before returning) from
    bigstring <code class="code">bstr</code> starting at position <code class="code">pos</code> to output channel <code class="code">oc</code>.<div class="parameters"><div class="param_info"><code class="code">pos</code> : default = 0</div><div class="param_info"><code class="code">min_len</code> : default = 0</div><div class="param_info"><code class="code">len</code> : default = <code class="code">length bstr - pos</code></div></div> <b>Raises</b> <code>Invalid_argument</code> if the designated range is out of bounds.<br/><code>IOError</code> in the case of output errors.  The <code class="code">IOError</code>-argument
    counting the number of successful bytes includes those that have
    been transferred to the channel buffer before the error.<br/> <b>Returns</b> the number of bytes actually written.<p>    NOTE: you may need to flush <code class="code">oc</code> to make sure that the data is
    actually sent.</p><p>    NOTE: if <code class="code">len</code> characters fit into the channel buffer completely,
    they will be buffered.  Otherwise writes will be attempted until at
    least <code class="code">min_len</code> characters have been sent.</p></div></div>
<pre><span class="VALreally_output"><span class="keyword">val</span> really_output</span> : <code class="type"><a href="?package=ocaml&amp;module=Pervasives&amp;type=out_channel">Pervasives.out_channel</a> -&gt; ?pos:int -&gt; ?len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">really_output oc ?pos ?len bstr</code> outputs exactly <code class="code">len</code>
    bytes from bigstring <code class="code">bstr</code> starting at position <code class="code">pos</code> to output
    channel <code class="code">oc</code>.<div class="parameters"><div class="param_info"><code class="code">pos</code> : default = 0</div><div class="param_info"><code class="code">len</code> : default = <code class="code">length bstr - pos</code></div></div> <b>Raises</b> <code>Invalid_argument</code> if the designated range is out of bounds.<br/><code>IOError</code> in the case of output errors.  The <code class="code">IOError</code>-argument
    counting the number of successful bytes includes those that have
    been transferred to the channel buffer before the error.<br/></div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Unsafe functions</h6></div></div>
<pre><span class="VALunsafe_read_assume_fd_is_nonblocking"><span class="keyword">val</span> unsafe_read_assume_fd_is_nonblocking</span> : <code class="type"><a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; pos:int -&gt; len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">unsafe_read_assume_fd_is_nonblocking fd ~pos ~len bstr</code>
    similar to  <a href="#Bigstring.read_assume_fd_is_nonblocking">Bigstring.read_assume_fd_is_nonblocking</a>, but does
    not perform any bounds checks.  Will crash on bounds errors!</div></div>
<pre><span class="VALunsafe_write"><span class="keyword">val</span> unsafe_write</span> : <code class="type"><a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; pos:int -&gt; len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">unsafe_write fd ~pos ~len bstr</code> similar to
     <a href="#Bigstring.write">Bigstring.write</a>, but does not perform any bounds checks.
    Will crash on bounds errors!</div></div>
<pre><span class="VALunsafe_write_assume_fd_is_nonblocking"><span class="keyword">val</span> unsafe_write_assume_fd_is_nonblocking</span> : <code class="type"><a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; pos:int -&gt; len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">unsafe_write_assume_fd_is_nonblocking fd ~pos ~len bstr</code>
    similar to  <a href="#Bigstring.write_assume_fd_is_nonblocking">Bigstring.write_assume_fd_is_nonblocking</a>, but does
    not perform any bounds checks.  Will crash on bounds errors!</div></div>
<pre><span class="VALunsafe_read"><span class="keyword">val</span> unsafe_read</span> : <code class="type">min_len:int -&gt; <a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; pos:int -&gt; len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">unsafe_read ~min_len fd ~pos ~len bstr</code> similar to
     <a href="#Bigstring.read">Bigstring.read</a>, but does not perform any bounds checks.
    Will crash on bounds errors!</div></div>
<pre><span class="VALunsafe_really_recv"><span class="keyword">val</span> unsafe_really_recv</span> : <code class="type"><a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; pos:int -&gt; len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">unsafe_really_recv sock ~pos ~len bstr</code> similar to
     <a href="#Bigstring.really_recv">Bigstring.really_recv</a>, but does not perform any
    bounds checks.  Will crash on bounds errors!</div></div>
<pre><span class="VALunsafe_really_write"><span class="keyword">val</span> unsafe_really_write</span> : <code class="type"><a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; pos:int -&gt; len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">unsafe_really_write fd ~pos ~len bstr</code> similar to
     <a href="#Bigstring.write">Bigstring.write</a>, but does not perform any bounds checks.
    Will crash on bounds errors!</div></div>
<pre><span class="VALunsafe_really_send_no_sigpipe"><span class="keyword">val</span> unsafe_really_send_no_sigpipe</span> : <code class="type">(<a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; pos:int -&gt; len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; unit)
<a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">unsafe_really_send_no_sigpipe sock ~pos ~len bstr</code>
    similar to  <a href="#Bigstring.send">Bigstring.send</a>, but does not perform any
    bounds checks.  Will crash on bounds errors!</div></div>
<pre><span class="VALunsafe_send_nonblocking_no_sigpipe"><span class="keyword">val</span> unsafe_send_nonblocking_no_sigpipe</span> : <code class="type">(<a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; pos:int -&gt; len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; int option)
<a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">unsafe_send_nonblocking_no_sigpipe sock ~pos ~len bstr</code> similar to
     <a href="#Bigstring.send_nonblocking_no_sigpipe">Bigstring.send_nonblocking_no_sigpipe</a>, but does not perform any
    bounds checks.  Will crash on bounds errors!</div></div>
<pre><span class="VALunsafe_writev"><span class="keyword">val</span> unsafe_writev</span> : <code class="type"><a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> <a href="?package=core&amp;module=Core_unix.IOVec&amp;type=t">Core_unix.IOVec.t</a> array -&gt; int -&gt; int</code></pre><div class="info"><div class="info"><code class="code">unsafe_writev fd iovecs count</code> similar to
     <a href="#Bigstring.writev">Bigstring.writev</a>, but does not perform any bounds checks.
    Will crash on bounds errors!</div></div>
<pre><span class="VALunsafe_sendmsg_nonblocking_no_sigpipe"><span class="keyword">val</span> unsafe_sendmsg_nonblocking_no_sigpipe</span> : <code class="type">(<a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> <a href="?package=core&amp;module=Core_unix.IOVec&amp;type=t">Core_unix.IOVec.t</a> array -&gt; int -&gt; int option)
<a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">unsafe_sendmsg_nonblocking_no_sigpipe fd iovecs count</code>
    similar to  <a href="#Bigstring.sendmsg_nonblocking_no_sigpipe">Bigstring.sendmsg_nonblocking_no_sigpipe</a>, but
    does not perform any bounds checks.  Will crash on bounds errors!</div></div>
<pre><span class="VALunsafe_input"><span class="keyword">val</span> unsafe_input</span> : <code class="type">min_len:int -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=in_channel">Pervasives.in_channel</a> -&gt; pos:int -&gt; len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">unsafe_input ~min_len ic ~pos ~len bstr</code> similar to
     <a href="#Bigstring.input">Bigstring.input</a>, but does not perform any bounds checks.
    Will crash on bounds errors!</div></div>
<pre><span class="VALunsafe_output"><span class="keyword">val</span> unsafe_output</span> : <code class="type">min_len:int -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=out_channel">Pervasives.out_channel</a> -&gt; pos:int -&gt; len:int -&gt; <a href="?package=core&amp;module=Bigstring&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">unsafe_output ~min_len oc ~pos ~len bstr</code> similar to
     <a href="#Bigstring.output">Bigstring.output</a>, but does not perform any bounds checks.
    Will crash on bounds errors!</div></div>
</div>