<div class="ocaml_toplevel_module">
<div class="info"><div class="info">A specialized priority queue for a set of time-based alarms.<br/>    A timing wheel is a data structure that maintains a clock with the current time and a
    set of alarms scheduled to fire in the future.  One can add and remove alarms, and
    advance the clock to cause alarms to fire.  There is nothing asynchronous about a
    timing wheel.  Alarms only fire in response to an <code class="code">advance_clock</code> call.<br/>    When one <code class="code">create</code>s a timing wheel, one supplies an initial time, <code class="code">start</code>, and an
    <code class="code">alarm_precision</code>.  The timing wheel breaks all time from <code class="code">start</code> onwards into
    half-open intervals of size <code class="code">alarm_precision</code>, with the bottom half of each interval
    closed, and the top half open.  Alarms in the same interval fire in the same call to
    <code class="code">advance_clock</code>, as soon as <code class="code">now t</code> is greater than all the times in the interval.
    When an alarm <code class="code">a</code> fires on a timing wheel <code class="code">t</code>, the implementation guarantees that:<br/>    <pre class="codepre"><code class="code">
      Alarm.at a &lt; now t
    </code></pre><br/>    That is, alarms never fire early.  Furthermore, the implementation guarantees that
    alarms don't go off too late.  More precisely, for all alarms <code class="code">a</code> in <code class="code">t</code>:<br/>    <pre class="codepre"><code class="code">
      interval_start t (Alarm.at a) &gt;= interval_start t (now t)
    </code></pre><br/>    This implies that for all alarms <code class="code">a</code> in <code class="code">t</code>:<br/>    <pre class="codepre"><code class="code">
      Alarm.at a &gt;= now t - alarm_precision t
    </code></pre><br/>    One would like to have the strict inequality, <code class="code">Alarm.at a &gt; now t - alarm_precision
    t</code>, but that does not hold due to floating-point imprecision.<br/>    Of course, an <code class="code">advance_clock</code> call can advance the clock to an arbitrary time in the
    future, and thus alarms may fire at a clock time arbitrarily far beyond the time for
    which they were set.  But the implementation has no control over the times supplied to
    <code class="code">advance_clock</code>; it can only guarantee that alarms will fire when <code class="code">advance_clock</code> is
    called with a time at least <code class="code">alarm_precision</code> greater than their scheduled time.<br/>    <h1 id="1_TITLE">Implementation</h1>
    ==================
    A timing wheel is implemented using a specialized priority queue in which the
    half-open intervals from <code class="code">start</code> onwards are numbered 0, 1, 2, etc.  Each time is
    stored in the priority queue with the key of its interval number.  Thus all alarms
    with a time in the same interval get the same key, and hence fire at the same time.
    More specifically, an alarm is fired when the clock reaches or passes the time at the
    start of the next interval.<br/>    The priority queue is implemented with an array of levels of decreasing precision,
    with the lowest level having the most precision and storing the closest upcoming
    alarms, while the highest level has the least precision and stores the alarms farthest
    in the future.  As time increases, the timing wheel does a lazy radix sort of the
    alarm keys.<br/>    This implementation makes <code class="code">add_alarm</code> and <code class="code">remove_alarm</code> constant time, while
    <code class="code">advance_clock</code> takes time proportional to the amount of time the clock is advanced.
    With a sufficient number of alarms, this is more efficient than a log(N) heap
    implementation of a priority queue.<br/>    <h1 id="1_TITLE">Representable times</h1>
    =======================
    A timing wheel <code class="code">t</code> can only handle a (typically large) bounded range of times as
    determined by the current time, <code class="code">now t</code>, and the <code class="code">level_bits</code> and <code class="code">alarm_precision</code>
    arguments supplied to <code class="code">create</code>.  Various functions raise if they are supplied a time
    smaller than <code class="code">now t</code> or <code class="code">&gt;= alarm_upper_bound t</code>.  This situation likely indicates a
    misconfiguration of the <code class="code">level_bits</code> and/or <code class="code">alarm_precision</code>.  Here are some examples
    of the duration <code class="code">alarm_upper_bound t - now t</code> for 32-bit and 64-bit machines using the
    default <code class="code">level_bits</code>.<br/>    <span class="verbatim">      | word size | # intervals | alarm_precision | duration |
      |-----------+-------------+-----------------+----------|
      |        32 |        2^29 | millisecond     | 7 days   |
      |        64 |        2^61 | nanosecond      | 73 years |
    </span></div></div>
<div class="ocaml_module sig" name="Time"><pre><span class="keyword">module</span> <a href="?package=core&amp;module=Timing_wheel_intf.Time">Time</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<div class="ocaml_include ident" path="?package=core&amp;module=Time" items="[&quot;Stable&quot;,&quot;Set&quot;,&quot;Map&quot;,&quot;Replace_polymorphic_compare&quot;,&quot;Hash_queue&quot;,&quot;Hash_set&quot;,&quot;Pooled_hashtbl&quot;,&quot;Table&quot;,&quot;Hashable&quot;]"><pre><span class="keyword">include</span> <code class="type"><code class="code"><a href="?package=core&amp;module=Time">Time</a></code></code></pre></div>
<div class="ocaml_module ident" name="Ofday" path="?package=core&amp;module=Ofday"><pre><span class="keyword">module</span> <a href="?package=core&amp;module=Timing_wheel_intf.Time.Ofday">Ofday</a> : <code class="type"><code class="code"><a href="?package=core&amp;module=Ofday">Ofday</a></code></code></pre></div>
<div class="ocaml_module ident" name="Span" path="?package=core&amp;module=Span"><pre><span class="keyword">module</span> <a href="?package=core&amp;module=Timing_wheel_intf.Time.Span">Span</a> : <code class="type"><code class="code"><a href="?package=core&amp;module=Span">Span</a></code></code></pre></div>
<div class="ocaml_module ident" name="Zone" path="?package=core&amp;module=Zone"><pre><span class="keyword">module</span> <a href="?package=core&amp;module=Timing_wheel_intf.Time.Zone">Zone</a> : <code class="type"><code class="code"><a href="?package=core&amp;module=Zone">Zone</a></code></code></pre></div></div></div>
<div class="ocaml_module sig" name="S"><pre><span class="keyword">module type</span> <a href="?package=core&amp;module=Timing_wheel_intf.S">S</a> = <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEt"><span class="keyword">type</span> <code class="type">'a </code>t</span> </pre>
<pre><span class="TYPEtiming_wheel"><span class="keyword">type</span> <code class="type">'a </code>timing_wheel</span> = <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S&amp;type=t">t</a></code></pre>
<div class="ocaml_module sig" name="Alarm"><pre><span class="keyword">module</span> <a href="?package=core&amp;module=Timing_wheel_intf.S.Alarm">Alarm</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEt"><span class="keyword">type</span> <code class="type">'a </code>t</span> </pre>
<pre><span class="VALat"><span class="keyword">val</span> at</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S&amp;type=timing_wheel">timing_wheel</a> -&gt; 'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Alarm&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Timing_wheel_intf.Time&amp;type=t">Time.t</a></code></pre><div class="info"><div class="info">In all <code class="code">Alarm</code> functions, one must supply the timing wheel that the alarm was
        <code class="code">add</code>ed to.  It is an error to supply a different timing wheel.</div></div>
<pre><span class="VALkey"><span class="keyword">val</span> key</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S&amp;type=timing_wheel">timing_wheel</a> -&gt; 'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Alarm&amp;type=t">t</a> -&gt; int</code></pre>
<pre><span class="VALvalue"><span class="keyword">val</span> value</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S&amp;type=timing_wheel">timing_wheel</a> -&gt; 'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Alarm&amp;type=t">t</a> -&gt; 'a</code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type">('a -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a>) -&gt; 'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Alarm&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre>
<div class="info"><div class="info">In all <code class="code">Alarm</code> functions, one must supply the timing wheel that the alarm was
        <code class="code">add</code>ed to.  It is an error to supply a different timing wheel.</div></div></div></div>
<div class="ocaml_include ident" path="?package=core&amp;module=Invariant.S1" items="[]"><pre><span class="keyword">include</span> <code class="type"><code class="code"><a href="?package=core&amp;module=Invariant.S1">Invariant.S1</a></code> with type t := 'a <a href="?package=core&amp;module=Timing_wheel_intf.S&amp;type=t">t</a></code></pre></div>
<div class="ocaml_module sig" name="Level_bits"><pre><span class="keyword">module</span> <a href="?package=core&amp;module=Timing_wheel_intf.S.Level_bits">Level_bits</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEt"><span class="keyword">type</span> t</span> </pre><div class="info"><div class="info">The timing-wheel implementation uses an array of &quot;levels&quot;, where level <code class="code">i</code> is an
        array of length <code class="code">2^b_i</code>, where the <code class="code">b_i</code> are the &quot;level bits&quot; specified via
        <code class="code">Level_bits.create_exn [b_0, b_1; ...]</code>.<br/>        A timing wheel can handle approximately <code class="code">2 ** num_bits t</code> intervals/keys beyond
        the current minimum time/key, where <code class="code">num_bits t = b_0 + b_1 + ...</code>.<br/>        One can use a <code class="code">Level_bits.t</code> to trade off run time and space usage of a timing
        wheel.  For a fixed <code class="code">num_bits</code>, as the number of levels increases, the length of
        the levels decreases and the timing wheel uses less space, but the constant factor
        for the running time of <code class="code">add</code> and <code class="code">increase_min_allowed_key</code> increases.</div></div>
<div class="ocaml_include ident" path="?package=core&amp;module=Invariant.S" items="[]"><pre><span class="keyword">include</span> <code class="type"><code class="code"><a href="?package=core&amp;module=Invariant.S">Invariant.S</a></code> with type t := <a href="?package=core&amp;module=Timing_wheel_intf.S.Level_bits&amp;type=t">t</a></code></pre></div>
<pre><span class="VALmax_num_bits"><span class="keyword">val</span> max_num_bits</span> : <code class="type">int</code></pre>
<pre><span class="VALcreate_exn"><span class="keyword">val</span> create_exn</span> : <code class="type">int list -&gt; <a href="?package=core&amp;module=Timing_wheel_intf.S.Level_bits&amp;type=t">t</a></code></pre><div class="info"><div class="info">In <code class="code">create_exn bits</code>, it is an error if any of the <code class="code">b_i</code> in <code class="code">bits</code> has <code class="code">b_i &lt;= 0</code>,
        or if the sum of the <code class="code">b_i</code> in <code class="code">bits</code> is greater than <code class="code">max_num_bits</code>.</div></div>
<pre><span class="VALdefault"><span class="keyword">val</span> default</span> : <code class="type"><a href="?package=core&amp;module=Word_size&amp;type=t">Word_size.t</a> -&gt; <a href="?package=core&amp;module=Timing_wheel_intf.S.Level_bits&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">default</code> returns the default value of <code class="code">level_bits</code> used by <code class="code">Timing_wheel.create</code>
        and <code class="code">Timing_wheel.Priority_queue.create</code>.  It varies based on the machine's word
        size.  Here are the the values and the amount of space used for the level arrays.<br/>        | word | bits used | level_bits               | space used  |
        |------+-----------+--------------------------+-------------|
        |   32 |        29 | <code class="code">10; 10; 9</code>              | &lt; 4k words  |
        |   64 |        61 | <code class="code">11; 10; 10; 10; 10; 10</code> | &lt; 10k words |</div></div>
<pre><span class="VALnum_bits"><span class="keyword">val</span> num_bits</span> : <code class="type"><a href="?package=core&amp;module=Timing_wheel_intf.S.Level_bits&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">num_bits t</code> is the sum of the <code class="code">b_i</code> in <code class="code">t</code>.</div></div>
<pre><span class="VALdurations"><span class="keyword">val</span> durations</span> : <code class="type"><a href="?package=core&amp;module=Timing_wheel_intf.S.Level_bits&amp;type=t">t</a> -&gt; alarm_precision:<a href="?package=core&amp;module=Timing_wheel_intf.Time.Span&amp;type=t">Time.Span.t</a> -&gt; <a href="?package=core&amp;module=Timing_wheel_intf.Time.Span&amp;type=t">Time.Span.t</a> list</code></pre><div class="info"><div class="info"><code class="code">durations t ~alarm_precision</code> returns the durations of the levels in <code class="code">t</code>,
        assuming that each interval has duration <code class="code">alarm_precision</code>.</div></div>
<pre><span class="VALt_of_sexp"><span class="keyword">val</span> t_of_sexp</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a> -&gt; <a href="?package=core&amp;module=Timing_wheel_intf.S.Level_bits&amp;type=t">t</a></code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type"><a href="?package=core&amp;module=Timing_wheel_intf.S.Level_bits&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre>
<div class="info"><div class="info">In <code class="code">create_exn bits</code>, it is an error if any of the <code class="code">b_i</code> in <code class="code">bits</code> has <code class="code">b_i &lt;= 0</code>,
        or if the sum of the <code class="code">b_i</code> in <code class="code">bits</code> is greater than <code class="code">max_num_bits</code>.</div></div>
<div class="info"><div class="info"><code class="code">default</code> returns the default value of <code class="code">level_bits</code> used by <code class="code">Timing_wheel.create</code>
        and <code class="code">Timing_wheel.Priority_queue.create</code>.  It varies based on the machine's word
        size.  Here are the the values and the amount of space used for the level arrays.<br/>        | word | bits used | level_bits               | space used  |
        |------+-----------+--------------------------+-------------|
        |   32 |        29 | <code class="code">10; 10; 9</code>              | &lt; 4k words  |
        |   64 |        61 | <code class="code">11; 10; 10; 10; 10; 10</code> | &lt; 10k words |</div></div>
<div class="info"><div class="info"><code class="code">num_bits t</code> is the sum of the <code class="code">b_i</code> in <code class="code">t</code>.</div></div>
<div class="info"><div class="info"><code class="code">durations t ~alarm_precision</code> returns the durations of the levels in <code class="code">t</code>,
        assuming that each interval has duration <code class="code">alarm_precision</code>.</div></div></div></div>
<pre><span class="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">?level_bits:<a href="?package=core&amp;module=Timing_wheel_intf.S.Level_bits&amp;type=t">Level_bits.t</a> -&gt;
start:<a href="?package=core&amp;module=Timing_wheel_intf.Time&amp;type=t">Time.t</a> -&gt; alarm_precision:<a href="?package=core&amp;module=Timing_wheel_intf.Time.Span&amp;type=t">Time.Span.t</a> -&gt; dummy:'a -&gt; unit -&gt; 'a <a href="?package=core&amp;module=Timing_wheel_intf.S&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">create ~start ~alarm_precision ~dummy ()</code> creates a new timing wheel with current
      time <code class="code">start</code>.  The <code class="code">dummy</code> value is a performance optimization; it would be a bug if
      the timing wheel ever returned the <code class="code">dummy</code> value to client code.<br/>      For a fixed <code class="code">level_bits</code>, a smaller (i.e. more precise) <code class="code">alarm_precision</code> decreases
      the representable range of times/keys and increases the constant factor for
      <code class="code">advance_clock</code>.<br/>      <code class="code">create</code> raises if <code class="code">alarm_precision &lt;= 0</code>.</div></div>
<pre><span class="VALalarm_precision"><span class="keyword">val</span> alarm_precision</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Timing_wheel_intf.Time.Span&amp;type=t">Time.Span.t</a></code></pre><div class="info"><div class="info">Accessors</div></div>
<pre><span class="VALnow"><span class="keyword">val</span> now</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Timing_wheel_intf.Time&amp;type=t">Time.t</a></code></pre>
<pre><span class="VALstart"><span class="keyword">val</span> start</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Timing_wheel_intf.Time&amp;type=t">Time.t</a></code></pre>
<pre><span class="VALis_empty"><span class="keyword">val</span> is_empty</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S&amp;type=t">t</a> -&gt; bool</code></pre><div class="info"><div class="info">One can think of a timing wheel as a set of alarms.  Here are various container
      functions along those lines.</div></div>
<pre><span class="VALlength"><span class="keyword">val</span> length</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S&amp;type=t">t</a> -&gt; int</code></pre>
<pre><span class="VALiter"><span class="keyword">val</span> iter</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S&amp;type=t">t</a> -&gt; f:('a <a href="?package=core&amp;module=Timing_wheel_intf.S.Alarm&amp;type=t">Alarm.t</a> -&gt; unit) -&gt; unit</code></pre>
<pre><span class="VALinterval_start"><span class="keyword">val</span> interval_start</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Timing_wheel_intf.Time&amp;type=t">Time.t</a> -&gt; <a href="?package=core&amp;module=Timing_wheel_intf.Time&amp;type=t">Time.t</a></code></pre><div class="info"><div class="info"><code class="code">interval_start t time</code> returns the time at the start of the half-open interval
      containing <code class="code">time</code>, i.e. the largest time less than or equal to <code class="code">time</code> that is of the
      form <code class="code">start t + k * alarm_precision t</code>.  <code class="code">interval_start</code> raises if <code class="code">time &lt; start t</code>
      or <code class="code">time</code> is too far in the future to represent.</div></div>
<pre><span class="VALadvance_clock"><span class="keyword">val</span> advance_clock</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S&amp;type=t">t</a> -&gt; to_:<a href="?package=core&amp;module=Timing_wheel_intf.Time&amp;type=t">Time.t</a> -&gt; handle_fired:('a <a href="?package=core&amp;module=Timing_wheel_intf.S.Alarm&amp;type=t">Alarm.t</a> -&gt; unit) -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">advance_clock t ~to_ ~handle_fired</code> advances <code class="code">t</code>'s clock to <code class="code">to_</code>.  It fires and
      removes all alarms <code class="code">a</code> in <code class="code">t</code> with <code class="code">Time.(&lt;) (Alarm.at a) (interval_start t to_)</code>
      applying <code class="code">handle_fired</code> to each such <code class="code">a</code>.<br/>      If <code class="code">to_ &lt;= now t</code>, then <code class="code">advance_clock</code> does nothing.<br/>      <code class="code">advance_clock</code> fails if <code class="code">to_</code> is too far in the future to represent.<br/>      Behavior is unspecified if <code class="code">handle_fired</code> accesses <code class="code">t</code> in any way other than
      <code class="code">Alarm</code> functions.</div></div>
<pre><span class="VALalarm_upper_bound"><span class="keyword">val</span> alarm_upper_bound</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Timing_wheel_intf.Time&amp;type=t">Time.t</a></code></pre><div class="info"><div class="info"><code class="code">alarm_upper_bound t</code> returns the upper bound on an <code class="code">at</code> that can be supplied to
      <code class="code">add</code>.  <code class="code">alarm_upper_bound t</code> is not constant; its value increases as <code class="code">now t</code>
      increases.</div></div>
<pre><span class="VALadd"><span class="keyword">val</span> add</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S&amp;type=t">t</a> -&gt; at:<a href="?package=core&amp;module=Timing_wheel_intf.Time&amp;type=t">Time.t</a> -&gt; 'a -&gt; 'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Alarm&amp;type=t">Alarm.t</a></code></pre><div class="info"><div class="info"><code class="code">add t ~at a</code> adds a new value <code class="code">a</code> to <code class="code">t</code> and returns an alarm that can later be
      supplied to <code class="code">remove</code> the alarm from <code class="code">t</code>.  <code class="code">add</code> raises if <code class="code">at &lt; now t || at &gt;=
      alarm_upper_bound t</code>.</div></div>
<pre><span class="VALremove"><span class="keyword">val</span> remove</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S&amp;type=t">t</a> -&gt; 'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Alarm&amp;type=t">Alarm.t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">remove t alarm</code> removes <code class="code">alarm</code> from <code class="code">t</code>.  It is an error to <code class="code">remove</code> an alarm
      that is not in <code class="code">t</code>.</div></div>
<pre><span class="VALnext_alarm_fires_at"><span class="keyword">val</span> next_alarm_fires_at</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Timing_wheel_intf.Time&amp;type=t">Time.t</a> option</code></pre><div class="info"><div class="info"><code class="code">next_alarm_fires_at t</code> returns the minimum time to which the clock can be advanced
      such that an alarm will fire, or <code class="code">None</code> if <code class="code">t</code> has no alarms.  If
      <code class="code">next_alarm_fires_at t = Some next</code>, then for the minimum alarm time <code class="code">min</code> that
      occurs in <code class="code">t</code>, it is guaranteed that: <code class="code">next - alarm_precision t &lt;= min &lt; next</code>.</div></div>
<div class="ocaml_module sig" name="Priority_queue"><pre><span class="keyword">module</span> <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue">Priority_queue</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="info"><div class="info">Timing wheel is implemented as a priority queue in which the keys are
      non-negative integers corresponding to the intervals of time.  The priority queue is
      unlike a typical priority queue in that rather than having a &quot;delete min&quot; operation,
      it has a nondecreasing minimum allowed key, which corresponds to the current time,
      and an <code class="code">increase_min_allowed_key</code> operation, which implements <code class="code">advance_clock</code>.
      <code class="code">increase_min_allowed_key</code> as a side effect removes all elements from the timing
      wheel whose key is smaller than the new minimum, which implements firing the alarms
      whose time has expired.<br/>      Adding elements to and removing elements from a timing wheel takes constant time,
      unlike a heap-based priority queue which takes log(N), where N is the number of
      elements in the heap.  <code class="code">increase_min_allowed_key</code> takes time proportional to the
      amount of increase in the min-allowed key, as compared to log(N) for a heap.  It is
      these performance differences that motivate the existence of timing wheels and make
      them a good choice for maintaing a set of alarms.  With a timing wheel, one can
      support any number of alarms paying constant overhead per alarm, while paying a
      small constant overhead per unit of time passed.<br/>      As the minimum allowed key increases, the timing wheel does a lazy radix sort of the
      element keys, with level 0 handling the least significant <code class="code">b_0</code> bits in a key, and
      each subsequent level <code class="code">i</code> handling the next most significant <code class="code">b_i</code> bits.  The levels
      hold increasingly larger ranges of keys, where the union of all the levels can hold
      any key from <code class="code">min_allowed_key t</code> to <code class="code">max_allowed_key t</code>.  When a key is added to the
      timing wheel, it is added at the lowest possible level that can store the key.  As
      the minimum allowed key increases, timing-wheel elements move down levels until they
      reach level 0, and then are eventually removed.</div></div><div class="ocaml_module_content">
<pre><span class="TYPEt"><span class="keyword">type</span> <code class="type">'a </code>t</span> </pre>
<pre><span class="TYPEpriority_queue"><span class="keyword">type</span> <code class="type">'a </code>priority_queue</span> = <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue&amp;type=t">t</a></code></pre>
<div class="ocaml_module sig" name="Elt"><pre><span class="keyword">module</span> <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue.Elt">Elt</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEt"><span class="keyword">type</span> <code class="type">'a </code>t</span> </pre><div class="info"><div class="info">An <code class="code">Elt.t</code> represents an element that was added to a timing wheel.</div></div>
<pre><span class="VALinvariant"><span class="keyword">val</span> invariant</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue&amp;type=priority_queue">priority_queue</a> -&gt; 'a <a href="?package=core&amp;module=Invariant&amp;type=t">Invariant.t</a> -&gt; 'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue.Elt&amp;type=t">t</a> <a href="?package=core&amp;module=Invariant&amp;type=t">Invariant.t</a></code></pre>
<pre><span class="VALkey"><span class="keyword">val</span> key</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue&amp;type=priority_queue">priority_queue</a> -&gt; 'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue.Elt&amp;type=t">t</a> -&gt; int</code></pre>
<pre><span class="VALvalue"><span class="keyword">val</span> value</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue&amp;type=priority_queue">priority_queue</a> -&gt; 'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue.Elt&amp;type=t">t</a> -&gt; 'a</code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type">('a -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a>) -&gt; 'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue.Elt&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre></div></div>
<div class="ocaml_include ident" path="?package=core&amp;module=Invariant.S1" items="[]"><pre><span class="keyword">include</span> <code class="type"><code class="code"><a href="?package=core&amp;module=Invariant.S1">Invariant.S1</a></code> with type t := 'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue&amp;type=t">t</a></code></pre></div>
<pre><span class="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">?level_bits:<a href="?package=core&amp;module=Timing_wheel_intf.S.Level_bits&amp;type=t">Level_bits.t</a> -&gt; dummy:'a -&gt; unit -&gt; 'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">create ?level_bits ~dummy ()</code> creates a new empty timing wheel, <code class="code">t</code>, with <code class="code">length
        t = 0</code> and <code class="code">min_allowed_key t = 0</code>.<br/>        <code class="code">dummy</code> is a dummy value that will never be returned by any operation, but that
        allows the implementation to be more efficient.</div></div>
<pre><span class="VALlength"><span class="keyword">val</span> length</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">length t</code> returns the number of elements in the timing wheel.</div></div>
<pre><span class="VALis_empty"><span class="keyword">val</span> is_empty</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue&amp;type=t">t</a> -&gt; bool</code></pre><div class="info"><div class="info"><code class="code">is_empty t</code> is <code class="code">length t = 0</code></div></div>
<pre><span class="VALmax_representable_key"><span class="keyword">val</span> max_representable_key</span> : <code class="type">int</code></pre><div class="info"><div class="info">To avoid issues with arithmetic overflow, the implementation restricts keys to
        being between <code class="code">0</code> and <code class="code">max_representable_key</code>, where:<br/>        <pre class="codepre"><code class="code">
          max_representable_key = 1 lsl Level_bits.max_num_bits - 1
        </code></pre><br/>        This is different from <code class="code">max_allowed_key t</code>, which gives the maximum key that can
        currently be stored in <code class="code">t</code>.  The maximum allowed key is never larger than the
        maximum representable key, but may be smaller.</div></div>
<pre><span class="VALmin_allowed_key"><span class="keyword">val</span> min_allowed_key</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">min_allowed_key t</code> is the minimum key that can be stored in <code class="code">t</code>.  This only
        indicates the possibility; there need not be an element <code class="code">elt</code> in <code class="code">t</code> with <code class="code">Elt.key
        elt = min_allowed_key t</code>.  This is not the same as the &quot;min_key&quot; operation in a
        typical priority queue.<br/>        <code class="code">min_allowed_key t</code> can increase over time, via calls to
        <code class="code">increase_min_allowed_key</code>.  It is guaranteed that <code class="code">min_allowed_key t &lt;=
        max_representable_key</code>.</div></div>
<pre><span class="VALmax_allowed_key"><span class="keyword">val</span> max_allowed_key</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">max_allowed_key t</code> is the maximum allowed key that can be stored in <code class="code">t</code>.  As
        <code class="code">min_allowed_key</code> increases, so does <code class="code">max_allowed_key</code>; however it is not the case
        that <code class="code">max_allowed_key t - min_allowed_key t</code> is a constant.  It is guaranteed that
        <code class="code">max_allowed_key t &gt;= min (max_representable_key, min_allowed_key t + 2^B - 1</code>,
        where <code class="code">B</code> is the sum of the b_i in <code class="code">level_bits</code>.  It is also guaranteed that
        <code class="code">max_allowed_key t &lt;= max_representable_key</code>.</div></div>
<pre><span class="VALmin_elt"><span class="keyword">val</span> min_elt</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue&amp;type=t">t</a> -&gt; 'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue.Elt&amp;type=t">Elt.t</a> option</code></pre><div class="info"><div class="info"><code class="code">min_elt t</code> returns an element in <code class="code">t</code> that has the minimum key, if <code class="code">t</code> is
        nonempty.  <code class="code">min_elt</code> takes time proportional to the size of the timing-wheel data
        structure in the worst case.  It is implemented via a linear search.<br/>        <code class="code">min_key t</code> returns the key of <code class="code">min_elt t</code>, if any.</div></div>
<pre><span class="VALmin_key"><span class="keyword">val</span> min_key</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue&amp;type=t">t</a> -&gt; int option</code></pre>
<pre><span class="VALadd"><span class="keyword">val</span> add</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue&amp;type=t">t</a> -&gt; key:int -&gt; 'a -&gt; 'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue.Elt&amp;type=t">Elt.t</a></code></pre><div class="info"><div class="info"><code class="code">add t ~key value</code> adds a new value to <code class="code">t</code> and returns an element that can later
        be supplied to <code class="code">remove</code> the element from <code class="code">t</code>.  <code class="code">add</code> raises if <code class="code">key &lt;
        min_allowed_key t || key &gt; max_allowed_key t</code>.</div></div>
<pre><span class="VALremove"><span class="keyword">val</span> remove</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue&amp;type=t">t</a> -&gt; 'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue.Elt&amp;type=t">Elt.t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">remove t elt</code> removes <code class="code">elt</code> from <code class="code">t</code>.  It is an error if <code class="code">elt</code> is not currently
        in <code class="code">t</code>, and this error may or may not be detected.</div></div>
<pre><span class="VALincrease_min_allowed_key"><span class="keyword">val</span> increase_min_allowed_key</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue&amp;type=t">t</a> -&gt; key:int -&gt; handle_removed:('a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue.Elt&amp;type=t">Elt.t</a> -&gt; unit) -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">increase_min_allowed_key t ~key ~handle_removed</code> increases the minimum allowed
        key in <code class="code">t</code> to <code class="code">key</code>, and removes all elements with keys less than <code class="code">key</code>, applying
        <code class="code">handle_removed</code> to each element that is removed.  If <code class="code">key &lt;= min_allowed_key t</code>,
        then <code class="code">increase_min_allowed_key</code> does nothing.  Otherwise, if
        <code class="code">increase_min_allowed_key</code> returns successfully, <code class="code">min_allowed_key t = key</code>.<br/>        <code class="code">increase_min_allowed_key</code> raises if <code class="code">key &gt; max_representable_key</code>.<br/>        <code class="code">increase_min_allowed_key</code> takes time proportional to <code class="code">key - min_allowed_key t</code>,
        although possibly less time.<br/>        Behavior is unspecified if <code class="code">handle_removed</code> accesses <code class="code">t</code> in any way other than
        <code class="code">Elt</code> functions.</div></div>
<pre><span class="VALiter"><span class="keyword">val</span> iter</span> : <code class="type">'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue&amp;type=t">t</a> -&gt; f:('a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue.Elt&amp;type=t">Elt.t</a> -&gt; unit) -&gt; unit</code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type">('a -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a>) -&gt; 'a <a href="?package=core&amp;module=Timing_wheel_intf.S.Priority_queue&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre>
<div class="info"><div class="info">An <code class="code">Elt.t</code> represents an element that was added to a timing wheel.</div></div>
<div class="info"><div class="info"><code class="code">create ?level_bits ~dummy ()</code> creates a new empty timing wheel, <code class="code">t</code>, with <code class="code">length
        t = 0</code> and <code class="code">min_allowed_key t = 0</code>.<br/>        <code class="code">dummy</code> is a dummy value that will never be returned by any operation, but that
        allows the implementation to be more efficient.</div></div>
<div class="info"><div class="info"><code class="code">length t</code> returns the number of elements in the timing wheel.</div></div>
<div class="info"><div class="info"><code class="code">is_empty t</code> is <code class="code">length t = 0</code></div></div>
<div class="info"><div class="info">To avoid issues with arithmetic overflow, the implementation restricts keys to
        being between <code class="code">0</code> and <code class="code">max_representable_key</code>, where:<br/>        <pre class="codepre"><code class="code">
          max_representable_key = 1 lsl Level_bits.max_num_bits - 1
        </code></pre><br/>        This is different from <code class="code">max_allowed_key t</code>, which gives the maximum key that can
        currently be stored in <code class="code">t</code>.  The maximum allowed key is never larger than the
        maximum representable key, but may be smaller.</div></div>
<div class="info"><div class="info"><code class="code">min_allowed_key t</code> is the minimum key that can be stored in <code class="code">t</code>.  This only
        indicates the possibility; there need not be an element <code class="code">elt</code> in <code class="code">t</code> with <code class="code">Elt.key
        elt = min_allowed_key t</code>.  This is not the same as the &quot;min_key&quot; operation in a
        typical priority queue.<br/>        <code class="code">min_allowed_key t</code> can increase over time, via calls to
        <code class="code">increase_min_allowed_key</code>.  It is guaranteed that <code class="code">min_allowed_key t &lt;=
        max_representable_key</code>.</div></div>
<div class="info"><div class="info"><code class="code">max_allowed_key t</code> is the maximum allowed key that can be stored in <code class="code">t</code>.  As
        <code class="code">min_allowed_key</code> increases, so does <code class="code">max_allowed_key</code>; however it is not the case
        that <code class="code">max_allowed_key t - min_allowed_key t</code> is a constant.  It is guaranteed that
        <code class="code">max_allowed_key t &gt;= min (max_representable_key, min_allowed_key t + 2^B - 1</code>,
        where <code class="code">B</code> is the sum of the b_i in <code class="code">level_bits</code>.  It is also guaranteed that
        <code class="code">max_allowed_key t &lt;= max_representable_key</code>.</div></div>
<div class="info"><div class="info"><code class="code">min_elt t</code> returns an element in <code class="code">t</code> that has the minimum key, if <code class="code">t</code> is
        nonempty.  <code class="code">min_elt</code> takes time proportional to the size of the timing-wheel data
        structure in the worst case.  It is implemented via a linear search.<br/>        <code class="code">min_key t</code> returns the key of <code class="code">min_elt t</code>, if any.</div></div>
<div class="info"><div class="info"><code class="code">add t ~key value</code> adds a new value to <code class="code">t</code> and returns an element that can later
        be supplied to <code class="code">remove</code> the element from <code class="code">t</code>.  <code class="code">add</code> raises if <code class="code">key &lt;
        min_allowed_key t || key &gt; max_allowed_key t</code>.</div></div>
<div class="info"><div class="info"><code class="code">remove t elt</code> removes <code class="code">elt</code> from <code class="code">t</code>.  It is an error if <code class="code">elt</code> is not currently
        in <code class="code">t</code>, and this error may or may not be detected.</div></div>
<div class="info"><div class="info"><code class="code">increase_min_allowed_key t ~key ~handle_removed</code> increases the minimum allowed
        key in <code class="code">t</code> to <code class="code">key</code>, and removes all elements with keys less than <code class="code">key</code>, applying
        <code class="code">handle_removed</code> to each element that is removed.  If <code class="code">key &lt;= min_allowed_key t</code>,
        then <code class="code">increase_min_allowed_key</code> does nothing.  Otherwise, if
        <code class="code">increase_min_allowed_key</code> returns successfully, <code class="code">min_allowed_key t = key</code>.<br/>        <code class="code">increase_min_allowed_key</code> raises if <code class="code">key &gt; max_representable_key</code>.<br/>        <code class="code">increase_min_allowed_key</code> takes time proportional to <code class="code">key - min_allowed_key t</code>,
        although possibly less time.<br/>        Behavior is unspecified if <code class="code">handle_removed</code> accesses <code class="code">t</code> in any way other than
        <code class="code">Elt</code> functions.</div></div></div></div>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type">('a -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a>) -&gt; 'a <a href="?package=core&amp;module=Timing_wheel_intf.S&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre>
<div class="info"><div class="info">In all <code class="code">Alarm</code> functions, one must supply the timing wheel that the alarm was
        <code class="code">add</code>ed to.  It is an error to supply a different timing wheel.</div></div>
<div class="info"><div class="info">The timing-wheel implementation uses an array of &quot;levels&quot;, where level <code class="code">i</code> is an
        array of length <code class="code">2^b_i</code>, where the <code class="code">b_i</code> are the &quot;level bits&quot; specified via
        <code class="code">Level_bits.create_exn [b_0, b_1; ...]</code>.<br/>        A timing wheel can handle approximately <code class="code">2 ** num_bits t</code> intervals/keys beyond
        the current minimum time/key, where <code class="code">num_bits t = b_0 + b_1 + ...</code>.<br/>        One can use a <code class="code">Level_bits.t</code> to trade off run time and space usage of a timing
        wheel.  For a fixed <code class="code">num_bits</code>, as the number of levels increases, the length of
        the levels decreases and the timing wheel uses less space, but the constant factor
        for the running time of <code class="code">add</code> and <code class="code">increase_min_allowed_key</code> increases.</div></div>
<div class="info"><div class="info">In <code class="code">create_exn bits</code>, it is an error if any of the <code class="code">b_i</code> in <code class="code">bits</code> has <code class="code">b_i &lt;= 0</code>,
        or if the sum of the <code class="code">b_i</code> in <code class="code">bits</code> is greater than <code class="code">max_num_bits</code>.</div></div>
<div class="info"><div class="info"><code class="code">default</code> returns the default value of <code class="code">level_bits</code> used by <code class="code">Timing_wheel.create</code>
        and <code class="code">Timing_wheel.Priority_queue.create</code>.  It varies based on the machine's word
        size.  Here are the the values and the amount of space used for the level arrays.<br/>        | word | bits used | level_bits               | space used  |
        |------+-----------+--------------------------+-------------|
        |   32 |        29 | <code class="code">10; 10; 9</code>              | &lt; 4k words  |
        |   64 |        61 | <code class="code">11; 10; 10; 10; 10; 10</code> | &lt; 10k words |</div></div>
<div class="info"><div class="info"><code class="code">num_bits t</code> is the sum of the <code class="code">b_i</code> in <code class="code">t</code>.</div></div>
<div class="info"><div class="info"><code class="code">durations t ~alarm_precision</code> returns the durations of the levels in <code class="code">t</code>,
        assuming that each interval has duration <code class="code">alarm_precision</code>.</div></div>
<div class="info"><div class="info"><code class="code">create ~start ~alarm_precision ~dummy ()</code> creates a new timing wheel with current
      time <code class="code">start</code>.  The <code class="code">dummy</code> value is a performance optimization; it would be a bug if
      the timing wheel ever returned the <code class="code">dummy</code> value to client code.<br/>      For a fixed <code class="code">level_bits</code>, a smaller (i.e. more precise) <code class="code">alarm_precision</code> decreases
      the representable range of times/keys and increases the constant factor for
      <code class="code">advance_clock</code>.<br/>      <code class="code">create</code> raises if <code class="code">alarm_precision &lt;= 0</code>.</div></div>
<div class="info"><div class="info">Accessors</div></div>
<div class="info"><div class="info">One can think of a timing wheel as a set of alarms.  Here are various container
      functions along those lines.</div></div>
<div class="info"><div class="info"><code class="code">interval_start t time</code> returns the time at the start of the half-open interval
      containing <code class="code">time</code>, i.e. the largest time less than or equal to <code class="code">time</code> that is of the
      form <code class="code">start t + k * alarm_precision t</code>.  <code class="code">interval_start</code> raises if <code class="code">time &lt; start t</code>
      or <code class="code">time</code> is too far in the future to represent.</div></div>
<div class="info"><div class="info"><code class="code">advance_clock t ~to_ ~handle_fired</code> advances <code class="code">t</code>'s clock to <code class="code">to_</code>.  It fires and
      removes all alarms <code class="code">a</code> in <code class="code">t</code> with <code class="code">Time.(&lt;) (Alarm.at a) (interval_start t to_)</code>
      applying <code class="code">handle_fired</code> to each such <code class="code">a</code>.<br/>      If <code class="code">to_ &lt;= now t</code>, then <code class="code">advance_clock</code> does nothing.<br/>      <code class="code">advance_clock</code> fails if <code class="code">to_</code> is too far in the future to represent.<br/>      Behavior is unspecified if <code class="code">handle_fired</code> accesses <code class="code">t</code> in any way other than
      <code class="code">Alarm</code> functions.</div></div>
<div class="info"><div class="info"><code class="code">alarm_upper_bound t</code> returns the upper bound on an <code class="code">at</code> that can be supplied to
      <code class="code">add</code>.  <code class="code">alarm_upper_bound t</code> is not constant; its value increases as <code class="code">now t</code>
      increases.</div></div>
<div class="info"><div class="info"><code class="code">add t ~at a</code> adds a new value <code class="code">a</code> to <code class="code">t</code> and returns an alarm that can later be
      supplied to <code class="code">remove</code> the alarm from <code class="code">t</code>.  <code class="code">add</code> raises if <code class="code">at &lt; now t || at &gt;=
      alarm_upper_bound t</code>.</div></div>
<div class="info"><div class="info"><code class="code">remove t alarm</code> removes <code class="code">alarm</code> from <code class="code">t</code>.  It is an error to <code class="code">remove</code> an alarm
      that is not in <code class="code">t</code>.</div></div>
<div class="info"><div class="info"><code class="code">next_alarm_fires_at t</code> returns the minimum time to which the clock can be advanced
      such that an alarm will fire, or <code class="code">None</code> if <code class="code">t</code> has no alarms.  If
      <code class="code">next_alarm_fires_at t = Some next</code>, then for the minimum alarm time <code class="code">min</code> that
      occurs in <code class="code">t</code>, it is guaranteed that: <code class="code">next - alarm_precision t &lt;= min &lt; next</code>.</div></div>
<div class="info"><div class="info">Timing wheel is implemented as a priority queue in which the keys are
      non-negative integers corresponding to the intervals of time.  The priority queue is
      unlike a typical priority queue in that rather than having a &quot;delete min&quot; operation,
      it has a nondecreasing minimum allowed key, which corresponds to the current time,
      and an <code class="code">increase_min_allowed_key</code> operation, which implements <code class="code">advance_clock</code>.
      <code class="code">increase_min_allowed_key</code> as a side effect removes all elements from the timing
      wheel whose key is smaller than the new minimum, which implements firing the alarms
      whose time has expired.<br/>      Adding elements to and removing elements from a timing wheel takes constant time,
      unlike a heap-based priority queue which takes log(N), where N is the number of
      elements in the heap.  <code class="code">increase_min_allowed_key</code> takes time proportional to the
      amount of increase in the min-allowed key, as compared to log(N) for a heap.  It is
      these performance differences that motivate the existence of timing wheels and make
      them a good choice for maintaing a set of alarms.  With a timing wheel, one can
      support any number of alarms paying constant overhead per alarm, while paying a
      small constant overhead per unit of time passed.<br/>      As the minimum allowed key increases, the timing wheel does a lazy radix sort of the
      element keys, with level 0 handling the least significant <code class="code">b_0</code> bits in a key, and
      each subsequent level <code class="code">i</code> handling the next most significant <code class="code">b_i</code> bits.  The levels
      hold increasingly larger ranges of keys, where the union of all the levels can hold
      any key from <code class="code">min_allowed_key t</code> to <code class="code">max_allowed_key t</code>.  When a key is added to the
      timing wheel, it is added at the lowest possible level that can store the key.  As
      the minimum allowed key increases, timing-wheel elements move down levels until they
      reach level 0, and then are eventually removed.</div></div>
<div class="info"><div class="info">An <code class="code">Elt.t</code> represents an element that was added to a timing wheel.</div></div>
<div class="info"><div class="info"><code class="code">create ?level_bits ~dummy ()</code> creates a new empty timing wheel, <code class="code">t</code>, with <code class="code">length
        t = 0</code> and <code class="code">min_allowed_key t = 0</code>.<br/>        <code class="code">dummy</code> is a dummy value that will never be returned by any operation, but that
        allows the implementation to be more efficient.</div></div>
<div class="info"><div class="info"><code class="code">length t</code> returns the number of elements in the timing wheel.</div></div>
<div class="info"><div class="info"><code class="code">is_empty t</code> is <code class="code">length t = 0</code></div></div>
<div class="info"><div class="info">To avoid issues with arithmetic overflow, the implementation restricts keys to
        being between <code class="code">0</code> and <code class="code">max_representable_key</code>, where:<br/>        <pre class="codepre"><code class="code">
          max_representable_key = 1 lsl Level_bits.max_num_bits - 1
        </code></pre><br/>        This is different from <code class="code">max_allowed_key t</code>, which gives the maximum key that can
        currently be stored in <code class="code">t</code>.  The maximum allowed key is never larger than the
        maximum representable key, but may be smaller.</div></div>
<div class="info"><div class="info"><code class="code">min_allowed_key t</code> is the minimum key that can be stored in <code class="code">t</code>.  This only
        indicates the possibility; there need not be an element <code class="code">elt</code> in <code class="code">t</code> with <code class="code">Elt.key
        elt = min_allowed_key t</code>.  This is not the same as the &quot;min_key&quot; operation in a
        typical priority queue.<br/>        <code class="code">min_allowed_key t</code> can increase over time, via calls to
        <code class="code">increase_min_allowed_key</code>.  It is guaranteed that <code class="code">min_allowed_key t &lt;=
        max_representable_key</code>.</div></div>
<div class="info"><div class="info"><code class="code">max_allowed_key t</code> is the maximum allowed key that can be stored in <code class="code">t</code>.  As
        <code class="code">min_allowed_key</code> increases, so does <code class="code">max_allowed_key</code>; however it is not the case
        that <code class="code">max_allowed_key t - min_allowed_key t</code> is a constant.  It is guaranteed that
        <code class="code">max_allowed_key t &gt;= min (max_representable_key, min_allowed_key t + 2^B - 1</code>,
        where <code class="code">B</code> is the sum of the b_i in <code class="code">level_bits</code>.  It is also guaranteed that
        <code class="code">max_allowed_key t &lt;= max_representable_key</code>.</div></div>
<div class="info"><div class="info"><code class="code">min_elt t</code> returns an element in <code class="code">t</code> that has the minimum key, if <code class="code">t</code> is
        nonempty.  <code class="code">min_elt</code> takes time proportional to the size of the timing-wheel data
        structure in the worst case.  It is implemented via a linear search.<br/>        <code class="code">min_key t</code> returns the key of <code class="code">min_elt t</code>, if any.</div></div>
<div class="info"><div class="info"><code class="code">add t ~key value</code> adds a new value to <code class="code">t</code> and returns an element that can later
        be supplied to <code class="code">remove</code> the element from <code class="code">t</code>.  <code class="code">add</code> raises if <code class="code">key &lt;
        min_allowed_key t || key &gt; max_allowed_key t</code>.</div></div>
<div class="info"><div class="info"><code class="code">remove t elt</code> removes <code class="code">elt</code> from <code class="code">t</code>.  It is an error if <code class="code">elt</code> is not currently
        in <code class="code">t</code>, and this error may or may not be detected.</div></div>
<div class="info"><div class="info"><code class="code">increase_min_allowed_key t ~key ~handle_removed</code> increases the minimum allowed
        key in <code class="code">t</code> to <code class="code">key</code>, and removes all elements with keys less than <code class="code">key</code>, applying
        <code class="code">handle_removed</code> to each element that is removed.  If <code class="code">key &lt;= min_allowed_key t</code>,
        then <code class="code">increase_min_allowed_key</code> does nothing.  Otherwise, if
        <code class="code">increase_min_allowed_key</code> returns successfully, <code class="code">min_allowed_key t = key</code>.<br/>        <code class="code">increase_min_allowed_key</code> raises if <code class="code">key &gt; max_representable_key</code>.<br/>        <code class="code">increase_min_allowed_key</code> takes time proportional to <code class="code">key - min_allowed_key t</code>,
        although possibly less time.<br/>        Behavior is unspecified if <code class="code">handle_removed</code> accesses <code class="code">t</code> in any way other than
        <code class="code">Elt</code> functions.</div></div></div></div>

<div class="ocaml_module sig" name="Timing_wheel"><pre><span class="keyword">module type</span> <a href="?package=core&amp;module=Timing_wheel_intf.Timing_wheel">Timing_wheel</a> = <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<div class="ocaml_module ident" name="S" path="?package=core&amp;module=Timing_wheel_intf.S"><pre><span class="keyword">module type</span> <a href="?package=core&amp;module=Timing_wheel_intf.Timing_wheel.S">S</a> = <code class="type"><code class="code"><a href="?package=core&amp;module=Timing_wheel_intf.S">S</a></code></code></pre></div>
<div class="ocaml_include ident" path="?package=core&amp;module=Timing_wheel_intf.Timing_wheel.S" items="[]"><pre><span class="keyword">include</span> <code class="type"><code class="code"><a href="?package=core&amp;module=Timing_wheel_intf.Timing_wheel.S">S</a></code></code></pre></div>
<div class="ocaml_module sig" name="Debug"><pre><span class="keyword">module</span> <a href="?package=core&amp;module=Timing_wheel_intf.Timing_wheel.Debug">Debug</a> : <code class="type"><div class="sig_block"><code class="code">functor (</code><code class="code">M</code><code class="code"> : </code><code class="code"><a href="?package=core&amp;module=Timing_wheel_intf.Timing_wheel.S">S</a></code><code class="code">) -&gt; </code><code class="code">sig</code> .. <code class="code">end</code></div></code></pre><div class="ocaml_module_content">
<div class="ocaml_include ident" path="?package=core&amp;module=Timing_wheel_intf.Timing_wheel.S" items="[]"><pre><span class="keyword">include</span> <code class="type"><code class="code"><a href="?package=core&amp;module=Timing_wheel_intf.Timing_wheel.S">S</a></code></code></pre></div>
<pre><span class="VALcheck_invariant"><span class="keyword">val</span> check_invariant</span> : <code class="type">bool <a href="?package=ocaml&amp;module=Pervasives&amp;type=ref">Pervasives.ref</a></code></pre>
<pre><span class="VALshow_messages"><span class="keyword">val</span> show_messages</span> : <code class="type">bool <a href="?package=ocaml&amp;module=Pervasives&amp;type=ref">Pervasives.ref</a></code></pre></div></div></div></div>

<div class="info"><div class="info">A specialized priority queue for a set of time-based alarms.<br/>    A timing wheel is a data structure that maintains a clock with the current time and a
    set of alarms scheduled to fire in the future.  One can add and remove alarms, and
    advance the clock to cause alarms to fire.  There is nothing asynchronous about a
    timing wheel.  Alarms only fire in response to an <code class="code">advance_clock</code> call.<br/>    When one <code class="code">create</code>s a timing wheel, one supplies an initial time, <code class="code">start</code>, and an
    <code class="code">alarm_precision</code>.  The timing wheel breaks all time from <code class="code">start</code> onwards into
    half-open intervals of size <code class="code">alarm_precision</code>, with the bottom half of each interval
    closed, and the top half open.  Alarms in the same interval fire in the same call to
    <code class="code">advance_clock</code>, as soon as <code class="code">now t</code> is greater than all the times in the interval.
    When an alarm <code class="code">a</code> fires on a timing wheel <code class="code">t</code>, the implementation guarantees that:<br/>    <pre class="codepre"><code class="code">
      Alarm.at a &lt; now t
    </code></pre><br/>    That is, alarms never fire early.  Furthermore, the implementation guarantees that
    alarms don't go off too late.  More precisely, for all alarms <code class="code">a</code> in <code class="code">t</code>:<br/>    <pre class="codepre"><code class="code">
      interval_start t (Alarm.at a) &gt;= interval_start t (now t)
    </code></pre><br/>    This implies that for all alarms <code class="code">a</code> in <code class="code">t</code>:<br/>    <pre class="codepre"><code class="code">
      Alarm.at a &gt;= now t - alarm_precision t
    </code></pre><br/>    One would like to have the strict inequality, <code class="code">Alarm.at a &gt; now t - alarm_precision
    t</code>, but that does not hold due to floating-point imprecision.<br/>    Of course, an <code class="code">advance_clock</code> call can advance the clock to an arbitrary time in the
    future, and thus alarms may fire at a clock time arbitrarily far beyond the time for
    which they were set.  But the implementation has no control over the times supplied to
    <code class="code">advance_clock</code>; it can only guarantee that alarms will fire when <code class="code">advance_clock</code> is
    called with a time at least <code class="code">alarm_precision</code> greater than their scheduled time.<br/>    <h1 id="1_TITLE">Implementation</h1>
    ==================
    A timing wheel is implemented using a specialized priority queue in which the
    half-open intervals from <code class="code">start</code> onwards are numbered 0, 1, 2, etc.  Each time is
    stored in the priority queue with the key of its interval number.  Thus all alarms
    with a time in the same interval get the same key, and hence fire at the same time.
    More specifically, an alarm is fired when the clock reaches or passes the time at the
    start of the next interval.<br/>    The priority queue is implemented with an array of levels of decreasing precision,
    with the lowest level having the most precision and storing the closest upcoming
    alarms, while the highest level has the least precision and stores the alarms farthest
    in the future.  As time increases, the timing wheel does a lazy radix sort of the
    alarm keys.<br/>    This implementation makes <code class="code">add_alarm</code> and <code class="code">remove_alarm</code> constant time, while
    <code class="code">advance_clock</code> takes time proportional to the amount of time the clock is advanced.
    With a sufficient number of alarms, this is more efficient than a log(N) heap
    implementation of a priority queue.<br/>    <h1 id="1_TITLE">Representable times</h1>
    =======================
    A timing wheel <code class="code">t</code> can only handle a (typically large) bounded range of times as
    determined by the current time, <code class="code">now t</code>, and the <code class="code">level_bits</code> and <code class="code">alarm_precision</code>
    arguments supplied to <code class="code">create</code>.  Various functions raise if they are supplied a time
    smaller than <code class="code">now t</code> or <code class="code">&gt;= alarm_upper_bound t</code>.  This situation likely indicates a
    misconfiguration of the <code class="code">level_bits</code> and/or <code class="code">alarm_precision</code>.  Here are some examples
    of the duration <code class="code">alarm_upper_bound t - now t</code> for 32-bit and 64-bit machines using the
    default <code class="code">level_bits</code>.<br/>    <span class="verbatim">      | word size | # intervals | alarm_precision | duration |
      |-----------+-------------+-----------------+----------|
      |        32 |        2^29 | millisecond     | 7 days   |
      |        64 |        2^61 | nanosecond      | 73 years |
    </span></div></div>
<div class="info"><div class="info">In all <code class="code">Alarm</code> functions, one must supply the timing wheel that the alarm was
        <code class="code">add</code>ed to.  It is an error to supply a different timing wheel.</div></div>
<div class="info"><div class="info">The timing-wheel implementation uses an array of &quot;levels&quot;, where level <code class="code">i</code> is an
        array of length <code class="code">2^b_i</code>, where the <code class="code">b_i</code> are the &quot;level bits&quot; specified via
        <code class="code">Level_bits.create_exn [b_0, b_1; ...]</code>.<br/>        A timing wheel can handle approximately <code class="code">2 ** num_bits t</code> intervals/keys beyond
        the current minimum time/key, where <code class="code">num_bits t = b_0 + b_1 + ...</code>.<br/>        One can use a <code class="code">Level_bits.t</code> to trade off run time and space usage of a timing
        wheel.  For a fixed <code class="code">num_bits</code>, as the number of levels increases, the length of
        the levels decreases and the timing wheel uses less space, but the constant factor
        for the running time of <code class="code">add</code> and <code class="code">increase_min_allowed_key</code> increases.</div></div>
<div class="info"><div class="info">In <code class="code">create_exn bits</code>, it is an error if any of the <code class="code">b_i</code> in <code class="code">bits</code> has <code class="code">b_i &lt;= 0</code>,
        or if the sum of the <code class="code">b_i</code> in <code class="code">bits</code> is greater than <code class="code">max_num_bits</code>.</div></div>
<div class="info"><div class="info"><code class="code">default</code> returns the default value of <code class="code">level_bits</code> used by <code class="code">Timing_wheel.create</code>
        and <code class="code">Timing_wheel.Priority_queue.create</code>.  It varies based on the machine's word
        size.  Here are the the values and the amount of space used for the level arrays.<br/>        | word | bits used | level_bits               | space used  |
        |------+-----------+--------------------------+-------------|
        |   32 |        29 | <code class="code">10; 10; 9</code>              | &lt; 4k words  |
        |   64 |        61 | <code class="code">11; 10; 10; 10; 10; 10</code> | &lt; 10k words |</div></div>
<div class="info"><div class="info"><code class="code">num_bits t</code> is the sum of the <code class="code">b_i</code> in <code class="code">t</code>.</div></div>
<div class="info"><div class="info"><code class="code">durations t ~alarm_precision</code> returns the durations of the levels in <code class="code">t</code>,
        assuming that each interval has duration <code class="code">alarm_precision</code>.</div></div>
<div class="info"><div class="info"><code class="code">create ~start ~alarm_precision ~dummy ()</code> creates a new timing wheel with current
      time <code class="code">start</code>.  The <code class="code">dummy</code> value is a performance optimization; it would be a bug if
      the timing wheel ever returned the <code class="code">dummy</code> value to client code.<br/>      For a fixed <code class="code">level_bits</code>, a smaller (i.e. more precise) <code class="code">alarm_precision</code> decreases
      the representable range of times/keys and increases the constant factor for
      <code class="code">advance_clock</code>.<br/>      <code class="code">create</code> raises if <code class="code">alarm_precision &lt;= 0</code>.</div></div>
<div class="info"><div class="info">Accessors</div></div>
<div class="info"><div class="info">One can think of a timing wheel as a set of alarms.  Here are various container
      functions along those lines.</div></div>
<div class="info"><div class="info"><code class="code">interval_start t time</code> returns the time at the start of the half-open interval
      containing <code class="code">time</code>, i.e. the largest time less than or equal to <code class="code">time</code> that is of the
      form <code class="code">start t + k * alarm_precision t</code>.  <code class="code">interval_start</code> raises if <code class="code">time &lt; start t</code>
      or <code class="code">time</code> is too far in the future to represent.</div></div>
<div class="info"><div class="info"><code class="code">advance_clock t ~to_ ~handle_fired</code> advances <code class="code">t</code>'s clock to <code class="code">to_</code>.  It fires and
      removes all alarms <code class="code">a</code> in <code class="code">t</code> with <code class="code">Time.(&lt;) (Alarm.at a) (interval_start t to_)</code>
      applying <code class="code">handle_fired</code> to each such <code class="code">a</code>.<br/>      If <code class="code">to_ &lt;= now t</code>, then <code class="code">advance_clock</code> does nothing.<br/>      <code class="code">advance_clock</code> fails if <code class="code">to_</code> is too far in the future to represent.<br/>      Behavior is unspecified if <code class="code">handle_fired</code> accesses <code class="code">t</code> in any way other than
      <code class="code">Alarm</code> functions.</div></div>
<div class="info"><div class="info"><code class="code">alarm_upper_bound t</code> returns the upper bound on an <code class="code">at</code> that can be supplied to
      <code class="code">add</code>.  <code class="code">alarm_upper_bound t</code> is not constant; its value increases as <code class="code">now t</code>
      increases.</div></div>
<div class="info"><div class="info"><code class="code">add t ~at a</code> adds a new value <code class="code">a</code> to <code class="code">t</code> and returns an alarm that can later be
      supplied to <code class="code">remove</code> the alarm from <code class="code">t</code>.  <code class="code">add</code> raises if <code class="code">at &lt; now t || at &gt;=
      alarm_upper_bound t</code>.</div></div>
<div class="info"><div class="info"><code class="code">remove t alarm</code> removes <code class="code">alarm</code> from <code class="code">t</code>.  It is an error to <code class="code">remove</code> an alarm
      that is not in <code class="code">t</code>.</div></div>
<div class="info"><div class="info"><code class="code">next_alarm_fires_at t</code> returns the minimum time to which the clock can be advanced
      such that an alarm will fire, or <code class="code">None</code> if <code class="code">t</code> has no alarms.  If
      <code class="code">next_alarm_fires_at t = Some next</code>, then for the minimum alarm time <code class="code">min</code> that
      occurs in <code class="code">t</code>, it is guaranteed that: <code class="code">next - alarm_precision t &lt;= min &lt; next</code>.</div></div>
<div class="info"><div class="info">Timing wheel is implemented as a priority queue in which the keys are
      non-negative integers corresponding to the intervals of time.  The priority queue is
      unlike a typical priority queue in that rather than having a &quot;delete min&quot; operation,
      it has a nondecreasing minimum allowed key, which corresponds to the current time,
      and an <code class="code">increase_min_allowed_key</code> operation, which implements <code class="code">advance_clock</code>.
      <code class="code">increase_min_allowed_key</code> as a side effect removes all elements from the timing
      wheel whose key is smaller than the new minimum, which implements firing the alarms
      whose time has expired.<br/>      Adding elements to and removing elements from a timing wheel takes constant time,
      unlike a heap-based priority queue which takes log(N), where N is the number of
      elements in the heap.  <code class="code">increase_min_allowed_key</code> takes time proportional to the
      amount of increase in the min-allowed key, as compared to log(N) for a heap.  It is
      these performance differences that motivate the existence of timing wheels and make
      them a good choice for maintaing a set of alarms.  With a timing wheel, one can
      support any number of alarms paying constant overhead per alarm, while paying a
      small constant overhead per unit of time passed.<br/>      As the minimum allowed key increases, the timing wheel does a lazy radix sort of the
      element keys, with level 0 handling the least significant <code class="code">b_0</code> bits in a key, and
      each subsequent level <code class="code">i</code> handling the next most significant <code class="code">b_i</code> bits.  The levels
      hold increasingly larger ranges of keys, where the union of all the levels can hold
      any key from <code class="code">min_allowed_key t</code> to <code class="code">max_allowed_key t</code>.  When a key is added to the
      timing wheel, it is added at the lowest possible level that can store the key.  As
      the minimum allowed key increases, timing-wheel elements move down levels until they
      reach level 0, and then are eventually removed.</div></div>
<div class="info"><div class="info">An <code class="code">Elt.t</code> represents an element that was added to a timing wheel.</div></div>
<div class="info"><div class="info"><code class="code">create ?level_bits ~dummy ()</code> creates a new empty timing wheel, <code class="code">t</code>, with <code class="code">length
        t = 0</code> and <code class="code">min_allowed_key t = 0</code>.<br/>        <code class="code">dummy</code> is a dummy value that will never be returned by any operation, but that
        allows the implementation to be more efficient.</div></div>
<div class="info"><div class="info"><code class="code">length t</code> returns the number of elements in the timing wheel.</div></div>
<div class="info"><div class="info"><code class="code">is_empty t</code> is <code class="code">length t = 0</code></div></div>
<div class="info"><div class="info">To avoid issues with arithmetic overflow, the implementation restricts keys to
        being between <code class="code">0</code> and <code class="code">max_representable_key</code>, where:<br/>        <pre class="codepre"><code class="code">
          max_representable_key = 1 lsl Level_bits.max_num_bits - 1
        </code></pre><br/>        This is different from <code class="code">max_allowed_key t</code>, which gives the maximum key that can
        currently be stored in <code class="code">t</code>.  The maximum allowed key is never larger than the
        maximum representable key, but may be smaller.</div></div>
<div class="info"><div class="info"><code class="code">min_allowed_key t</code> is the minimum key that can be stored in <code class="code">t</code>.  This only
        indicates the possibility; there need not be an element <code class="code">elt</code> in <code class="code">t</code> with <code class="code">Elt.key
        elt = min_allowed_key t</code>.  This is not the same as the &quot;min_key&quot; operation in a
        typical priority queue.<br/>        <code class="code">min_allowed_key t</code> can increase over time, via calls to
        <code class="code">increase_min_allowed_key</code>.  It is guaranteed that <code class="code">min_allowed_key t &lt;=
        max_representable_key</code>.</div></div>
<div class="info"><div class="info"><code class="code">max_allowed_key t</code> is the maximum allowed key that can be stored in <code class="code">t</code>.  As
        <code class="code">min_allowed_key</code> increases, so does <code class="code">max_allowed_key</code>; however it is not the case
        that <code class="code">max_allowed_key t - min_allowed_key t</code> is a constant.  It is guaranteed that
        <code class="code">max_allowed_key t &gt;= min (max_representable_key, min_allowed_key t + 2^B - 1</code>,
        where <code class="code">B</code> is the sum of the b_i in <code class="code">level_bits</code>.  It is also guaranteed that
        <code class="code">max_allowed_key t &lt;= max_representable_key</code>.</div></div>
<div class="info"><div class="info"><code class="code">min_elt t</code> returns an element in <code class="code">t</code> that has the minimum key, if <code class="code">t</code> is
        nonempty.  <code class="code">min_elt</code> takes time proportional to the size of the timing-wheel data
        structure in the worst case.  It is implemented via a linear search.<br/>        <code class="code">min_key t</code> returns the key of <code class="code">min_elt t</code>, if any.</div></div>
<div class="info"><div class="info"><code class="code">add t ~key value</code> adds a new value to <code class="code">t</code> and returns an element that can later
        be supplied to <code class="code">remove</code> the element from <code class="code">t</code>.  <code class="code">add</code> raises if <code class="code">key &lt;
        min_allowed_key t || key &gt; max_allowed_key t</code>.</div></div>
<div class="info"><div class="info"><code class="code">remove t elt</code> removes <code class="code">elt</code> from <code class="code">t</code>.  It is an error if <code class="code">elt</code> is not currently
        in <code class="code">t</code>, and this error may or may not be detected.</div></div>
<div class="info"><div class="info"><code class="code">increase_min_allowed_key t ~key ~handle_removed</code> increases the minimum allowed
        key in <code class="code">t</code> to <code class="code">key</code>, and removes all elements with keys less than <code class="code">key</code>, applying
        <code class="code">handle_removed</code> to each element that is removed.  If <code class="code">key &lt;= min_allowed_key t</code>,
        then <code class="code">increase_min_allowed_key</code> does nothing.  Otherwise, if
        <code class="code">increase_min_allowed_key</code> returns successfully, <code class="code">min_allowed_key t = key</code>.<br/>        <code class="code">increase_min_allowed_key</code> raises if <code class="code">key &gt; max_representable_key</code>.<br/>        <code class="code">increase_min_allowed_key</code> takes time proportional to <code class="code">key - min_allowed_key t</code>,
        although possibly less time.<br/>        Behavior is unspecified if <code class="code">handle_removed</code> accesses <code class="code">t</code> in any way other than
        <code class="code">Elt</code> functions.</div></div>
</div>