<div class="ocaml_toplevel_module"><div class="info"><div class="info">Interface to Linux-specific system calls</div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">sysinfo</h2></div></div>
<div class="ocaml_module sig" name="Sysinfo"><pre><span class="keyword">module</span> <a href="?package=core&amp;module=Linux_ext.Sysinfo">Sysinfo</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><code><span class="TYPEt"><span class="keyword">type</span> t</span> = {</code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTt.uptime">uptime</span> : <code class="type"><a href="?package=core&amp;module=Span&amp;type=t">Span.t</a></code>;</code></td><td class="typefieldcomment" align="left"><div class="info">time since boot</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTt.load1">load1</span> : <code class="type">int</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">load average over the last minute</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTt.load5">load5</span> : <code class="type">int</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">load average over the last 5 minutes</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTt.load15">load15</span> : <code class="type">int</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">load average over the last 15 minutes</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTt.total_ram">total_ram</span> : <code class="type">int</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">total usable main memory</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTt.free_ram">free_ram</span> : <code class="type">int</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">available memory size</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTt.shared_ram">shared_ram</span> : <code class="type">int</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">amount of shared memory</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTt.buffer_ram">buffer_ram</span> : <code class="type">int</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">memory used by buffers</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTt.total_swap">total_swap</span> : <code class="type">int</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">total swap page size</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTt.free_swap">free_swap</span> : <code class="type">int</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">available swap space</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTt.procs">procs</span> : <code class="type">int</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">number of current processes</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTt.totalhigh">totalhigh</span> : <code class="type">int</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">Total high memory size</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTt.freehigh">freehigh</span> : <code class="type">int</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">Available high memory size</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTt.mem_unit">mem_unit</span> : <code class="type">int</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">Memory unit size in bytes</div></td></tr><tr><td>}</td></tr></table><div class="info"><div class="info">Result of sysinfo syscall (man 2 sysinfo)</div></div>
<pre><span class="VALsysinfo"><span class="keyword">val</span> sysinfo</span> : <code class="type">(unit -&gt; <a href="?package=core&amp;module=Linux_ext.Sysinfo&amp;type=t">t</a>) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre>
<pre><span class="VALbin_t"><span class="keyword">val</span> bin_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Sysinfo&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Type_class&amp;type=t">Core_kernel.Std.Bin_prot.Type_class.t</a></code></pre>
<pre><span class="VALbin_read_t"><span class="keyword">val</span> bin_read_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Sysinfo&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Read_ml&amp;type=reader">Core_kernel.Std.Bin_prot.Read_ml.reader</a></code></pre>
<pre><span class="VALbin_read_t_"><span class="keyword">val</span> bin_read_t_</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Sysinfo&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Unsafe_read_c&amp;type=reader">Core_kernel.Std.Bin_prot.Unsafe_read_c.reader</a></code></pre>
<pre><span class="VALbin_read_t__"><span class="keyword">val</span> bin_read_t__</span> : <code class="type">(int -&gt; <a href="?package=core&amp;module=Linux_ext.Sysinfo&amp;type=t">t</a>) <a href="?package=core_kernel&amp;module=Std.Bin_prot.Unsafe_read_c&amp;type=reader">Core_kernel.Std.Bin_prot.Unsafe_read_c.reader</a></code></pre>
<pre><span class="VALbin_reader_t"><span class="keyword">val</span> bin_reader_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Sysinfo&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Type_class&amp;type=reader">Core_kernel.Std.Bin_prot.Type_class.reader</a></code></pre>
<pre><span class="VALbin_size_t"><span class="keyword">val</span> bin_size_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Sysinfo&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Size&amp;type=sizer">Core_kernel.Std.Bin_prot.Size.sizer</a></code></pre>
<pre><span class="VALbin_write_t"><span class="keyword">val</span> bin_write_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Sysinfo&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Write_ml&amp;type=writer">Core_kernel.Std.Bin_prot.Write_ml.writer</a></code></pre>
<pre><span class="VALbin_write_t_"><span class="keyword">val</span> bin_write_t_</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Sysinfo&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Unsafe_write_c&amp;type=writer">Core_kernel.Std.Bin_prot.Unsafe_write_c.writer</a></code></pre>
<pre><span class="VALbin_writer_t"><span class="keyword">val</span> bin_writer_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Sysinfo&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Type_class&amp;type=writer">Core_kernel.Std.Bin_prot.Type_class.writer</a></code></pre>
<pre><span class="VALt_of_sexp"><span class="keyword">val</span> t_of_sexp</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a> -&gt; <a href="?package=core&amp;module=Linux_ext.Sysinfo&amp;type=t">t</a></code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Sysinfo&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre></div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">Filesystem functions</h2></div></div>
<pre><span class="VALsendfile"><span class="keyword">val</span> sendfile</span> : <code class="type">(?pos:int -&gt;
 ?len:int -&gt; fd:<a href="?package=core&amp;module=Core_unix.File_descr&amp;type=t">Core_unix.File_descr.t</a> -&gt; <a href="?package=core&amp;module=Core_unix.File_descr&amp;type=t">Core_unix.File_descr.t</a> -&gt; int)
<a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">sendfile ?pos ?len ~fd sock</code> sends mmap-able data from file
    descriptor <code class="code">fd</code> to socket <code class="code">sock</code> using offset <code class="code">pos</code> and length <code class="code">len</code>.<div class="parameters"><div class="param_info"><code class="code">default</code> : pos = 0</div><div class="param_info"><code class="code">default</code> : len = length of data (file) associated with descriptor <code class="code">fd</code></div></div> <b>Raises</b> <code>Unix_error</code> on Unix-errors.<br/> <b>Returns</b> the number of characters actually written.<p>    NOTE: if the returned value is unequal to what was requested (=
    the initial size of the data by default), the system call may have
    been interrupted by a signal, the source file may have been truncated
    during operation, or a timeout occurred on the socket during sending.
    It is currently impossible to find out which of the events above
    happened.  Calling  <a href="#sendfile">sendfile</a> several times on the same descriptor
    that only partially accepted data due to a timeout will eventually
    lead to the unix error <code class="code">EAGAIN</code>.</p></div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">Non-portable TCP-functionality</h2></div></div>
<pre><code><span class="TYPEtcp_bool_option"><span class="keyword">type</span> tcp_bool_option</span> = </code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTtcp_bool_option.TCP_CORK"><span class="constructor">TCP_CORK</span></span></code></td></tr></table><div class="info"><div class="info"><code class="code">gettcpopt_bool sock opt</code> <b>Returns</b> the current value of the boolean
    TCP socket option <code class="code">opt</code> for socket <code class="code">sock</code>.</div></div>
<pre><span class="VALgettcpopt_bool"><span class="keyword">val</span> gettcpopt_bool</span> : <code class="type">(<a href="?package=core&amp;module=Core_unix.File_descr&amp;type=t">Core_unix.File_descr.t</a> -&gt; <a href="?package=core&amp;module=Linux_ext&amp;type=tcp_bool_option">tcp_bool_option</a> -&gt; bool)
<a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre>
<pre><span class="VALsettcpopt_bool"><span class="keyword">val</span> settcpopt_bool</span> : <code class="type">(<a href="?package=core&amp;module=Core_unix.File_descr&amp;type=t">Core_unix.File_descr.t</a> -&gt; <a href="?package=core&amp;module=Linux_ext&amp;type=tcp_bool_option">tcp_bool_option</a> -&gt; bool -&gt; unit)
<a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">settcpopt_bool sock opt v</code> sets the current value of the boolean
    TCP socket option <code class="code">opt</code> for socket <code class="code">sock</code> to value <code class="code">v</code>.</div></div>
<pre><span class="VALsend_nonblocking_no_sigpipe"><span class="keyword">val</span> send_nonblocking_no_sigpipe</span> : <code class="type">(<a href="?package=core&amp;module=Core_unix.File_descr&amp;type=t">Core_unix.File_descr.t</a> -&gt; ?pos:int -&gt; ?len:int -&gt; string -&gt; int option)
<a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">send_nonblocking_no_sigpipe sock ?pos ?len buf</code> tries to do a
    nonblocking send on socket <code class="code">sock</code> given buffer <code class="code">buf</code>, offset <code class="code">pos</code>
    and length <code class="code">len</code>.  Prevents <code class="code">SIGPIPE</code>, i.e. raise a Unix-error
    in that case immediately.<div class="parameters"><div class="param_info"><code class="code">pos</code> : default = 0</div><div class="param_info"><code class="code">len</code> : default = <code class="code">String.length buf - pos</code></div></div> <b>Raises</b> <code>Invalid_argument</code> if the designated buffer range is invalid.<br/><code>Unix_error</code> on Unix-errors.<br/> <b>Returns</b> <code class="code">Some bytes_written</code> or <code class="code">None</code>
    if the operation would have blocked.</div></div>
<pre><span class="VALsend_no_sigpipe"><span class="keyword">val</span> send_no_sigpipe</span> : <code class="type">(<a href="?package=core&amp;module=Core_unix.File_descr&amp;type=t">Core_unix.File_descr.t</a> -&gt; ?pos:int -&gt; ?len:int -&gt; string -&gt; int)
<a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">send_no_sigpipe sock ?pos ?len buf</code> tries to do a
    blocking send on socket <code class="code">sock</code> given buffer <code class="code">buf</code>, offset <code class="code">pos</code>
    and length <code class="code">len</code>.  Prevents <code class="code">SIGPIPE</code>, i.e. raise a Unix-error in
    that case immediately.<div class="parameters"><div class="param_info"><code class="code">pos</code> : default = 0</div><div class="param_info"><code class="code">len</code> : default = <code class="code">String.length buf - pos</code></div></div> <b>Raises</b> <code>Invalid_argument</code> if the designated buffer range is invalid.<br/><code>Unix_error</code> on Unix-errors.<br/> <b>Returns</b> the number of bytes written.</div></div>
<pre><span class="VALsendmsg_nonblocking_no_sigpipe"><span class="keyword">val</span> sendmsg_nonblocking_no_sigpipe</span> : <code class="type">(<a href="?package=core&amp;module=Core_unix.File_descr&amp;type=t">Core_unix.File_descr.t</a> -&gt;
 ?count:int -&gt; string <a href="?package=core&amp;module=Core_unix.IOVec&amp;type=t">Core_unix.IOVec.t</a> array -&gt; int option)
<a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">sendmsg_nonblocking_no_sigpipe sock ?count iovecs</code> tries to do
    a nonblocking send on socket <code class="code">sock</code> using <code class="code">count</code> I/O-vectors
    <code class="code">iovecs</code>.  Prevents <code class="code">SIGPIPE</code>, i.e. raises a Unix-error in that
    case immediately. <b>Raises</b> <code>Invalid_argument</code> if the designated ranges are invalid.<br/><code>Unix_error</code> on Unix-errors.<br/> <b>Returns</b> <code class="code">Some bytes_written</code> or <code class="code">None</code> if the
    operation would have blocked.</div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">Clock functions</h2></div></div>
<div class="ocaml_module sig" name="Clock"><pre><span class="keyword">module</span> <a href="?package=core&amp;module=Linux_ext.Clock">Clock</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEt"><span class="keyword">type</span> t</span> </pre>
<pre><span class="VALget"><span class="keyword">val</span> get</span> : <code class="type">(<a href="?package=ocaml&amp;module=Thread&amp;type=t">Thread.t</a> -&gt; <a href="?package=core&amp;module=Linux_ext.Clock&amp;type=t">t</a>) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre>
<pre><span class="VALget_time"><span class="keyword">val</span> get_time</span> : <code class="type">(<a href="?package=core&amp;module=Linux_ext.Clock&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Span&amp;type=t">Span.t</a>) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre>
<pre><span class="VALset_time"><span class="keyword">val</span> set_time</span> : <code class="type">(<a href="?package=core&amp;module=Linux_ext.Clock&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Span&amp;type=t">Span.t</a> -&gt; unit) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre>
<pre><span class="VALget_resolution"><span class="keyword">val</span> get_resolution</span> : <code class="type">(<a href="?package=core&amp;module=Linux_ext.Clock&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Span&amp;type=t">Span.t</a>) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre>
<pre><span class="VALget_process_clock"><span class="keyword">val</span> get_process_clock</span> : <code class="type">(unit -&gt; <a href="?package=core&amp;module=Linux_ext.Clock&amp;type=t">t</a>) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">get_process_clock</code> the clock measuring the CPU-time of a process.</div></div>
<pre><span class="VALget_thread_clock"><span class="keyword">val</span> get_thread_clock</span> : <code class="type">(unit -&gt; <a href="?package=core&amp;module=Linux_ext.Clock&amp;type=t">t</a>) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">get_thread_clock</code> the clock measuring the CPU-time of the current thread.</div></div></div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">Timerfd functions</h2></div></div>
<div class="ocaml_module sig" name="Timerfd"><pre><span class="keyword">module</span> <a href="?package=core&amp;module=Linux_ext.Timerfd">Timerfd</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<div class="ocaml_module sig" name="Clock"><pre><span class="keyword">module</span> <a href="?package=core&amp;module=Linux_ext.Timerfd.Clock">Clock</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="info"><div class="info">Clock used to mark the progress of a timer.</div></div><div class="ocaml_module_content">
<pre><span class="TYPEt"><span class="keyword">type</span> t</span> </pre>
<pre><span class="VALrealtime"><span class="keyword">val</span> realtime</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd.Clock&amp;type=t">t</a></code></pre><div class="info"><div class="info">Settable system-wide clock.</div></div>
<pre><span class="VALmonotonic"><span class="keyword">val</span> monotonic</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd.Clock&amp;type=t">t</a></code></pre><div class="info"><div class="info">Nonsettable clock.  It is not affected by manual changes to the system time.</div></div>
<pre><span class="VALt_of_sexp"><span class="keyword">val</span> t_of_sexp</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a> -&gt; <a href="?package=core&amp;module=Linux_ext.Timerfd.Clock&amp;type=t">t</a></code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd.Clock&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre>
<pre><span class="VALcompare"><span class="keyword">val</span> compare</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd.Clock&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Linux_ext.Timerfd.Clock&amp;type=t">t</a> -&gt; int</code></pre>
<pre><span class="VALbin_t"><span class="keyword">val</span> bin_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd.Clock&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Type_class&amp;type=t">Core_kernel.Std.Bin_prot.Type_class.t</a></code></pre>
<pre><span class="VALbin_read_t"><span class="keyword">val</span> bin_read_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd.Clock&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Read_ml&amp;type=reader">Core_kernel.Std.Bin_prot.Read_ml.reader</a></code></pre>
<pre><span class="VALbin_read_t_"><span class="keyword">val</span> bin_read_t_</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd.Clock&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Unsafe_read_c&amp;type=reader">Core_kernel.Std.Bin_prot.Unsafe_read_c.reader</a></code></pre>
<pre><span class="VALbin_read_t__"><span class="keyword">val</span> bin_read_t__</span> : <code class="type">(int -&gt; <a href="?package=core&amp;module=Linux_ext.Timerfd.Clock&amp;type=t">t</a>) <a href="?package=core_kernel&amp;module=Std.Bin_prot.Unsafe_read_c&amp;type=reader">Core_kernel.Std.Bin_prot.Unsafe_read_c.reader</a></code></pre>
<pre><span class="VALbin_reader_t"><span class="keyword">val</span> bin_reader_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd.Clock&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Type_class&amp;type=reader">Core_kernel.Std.Bin_prot.Type_class.reader</a></code></pre>
<pre><span class="VALbin_size_t"><span class="keyword">val</span> bin_size_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd.Clock&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Size&amp;type=sizer">Core_kernel.Std.Bin_prot.Size.sizer</a></code></pre>
<pre><span class="VALbin_write_t"><span class="keyword">val</span> bin_write_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd.Clock&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Write_ml&amp;type=writer">Core_kernel.Std.Bin_prot.Write_ml.writer</a></code></pre>
<pre><span class="VALbin_write_t_"><span class="keyword">val</span> bin_write_t_</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd.Clock&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Unsafe_write_c&amp;type=writer">Core_kernel.Std.Bin_prot.Unsafe_write_c.writer</a></code></pre>
<pre><span class="VALbin_writer_t"><span class="keyword">val</span> bin_writer_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd.Clock&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Type_class&amp;type=writer">Core_kernel.Std.Bin_prot.Type_class.writer</a></code></pre>
<div class="info"><div class="info">Settable system-wide clock.</div></div>
<div class="info"><div class="info">Nonsettable clock.  It is not affected by manual changes to the system time.</div></div></div></div>
<div class="ocaml_module sig" name="Flags"><pre><span class="keyword">module</span> <a href="?package=core&amp;module=Linux_ext.Timerfd.Flags">Flags</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEt"><span class="keyword">type</span> t</span> </pre>
<div class="ocaml_include ident" path="?package=core_kernel&amp;module=Std.Flags.S" items="[]"><pre><span class="keyword">include</span> <code class="type"><code class="code"><a href="?package=core_kernel&amp;module=Std.Flags.S">Core_kernel.Std.Flags.S</a></code> with type t := <a href="?package=core&amp;module=Linux_ext.Timerfd.Flags&amp;type=t">t</a></code></pre></div>
<pre><span class="VALnonblock"><span class="keyword">val</span> nonblock</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd.Flags&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">TFD_NONBLOCK</code></div></div>
<pre><span class="VALcloexec"><span class="keyword">val</span> cloexec</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd.Flags&amp;type=t">t</a></code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd.Flags&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre>
<div class="info"><div class="info"><code class="code">TFD_NONBLOCK</code></div></div>
<div class="info"><div class="info"><code class="code">TFD_CLOEXEC</code></div></div></div></div>
<pre><span class="TYPEt"><span class="keyword">type</span> t</span> = <code class="type"><a href="?package=core&amp;module=Core_unix.File_descr&amp;type=t">Core_unix.File_descr.t</a></code><span class="keyword">private</span></pre>
<pre><span class="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">(?flags:<a href="?package=core&amp;module=Linux_ext.Timerfd.Flags&amp;type=t">Flags.t</a> -&gt; <a href="?package=core&amp;module=Linux_ext.Timerfd.Clock&amp;type=t">Clock.t</a> -&gt; <a href="?package=core&amp;module=Linux_ext.Timerfd&amp;type=t">t</a>) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">create ?flags clock</code> creates a new timer file descriptor.  With Linux 2.6.26 or
      earlier <code class="code">flags</code> must be empty.</div></div>
<pre><span class="VALset"><span class="keyword">val</span> set</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd&amp;type=t">t</a> -&gt; [ `After of <a href="?package=core&amp;module=Span&amp;type=t">Span.t</a> | `At of <a href="?package=core&amp;module=Time&amp;type=t">Time.t</a> ] -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">set t when</code> sets <code class="code">t</code> to fire once, at the time specified by <code class="code">when</code>.</div></div>
<pre><span class="VALset_repeating"><span class="keyword">val</span> set_repeating</span> : <code class="type">?initial:[ `After of <a href="?package=core&amp;module=Span&amp;type=t">Span.t</a> | `At of <a href="?package=core&amp;module=Time&amp;type=t">Time.t</a> ] -&gt; <a href="?package=core&amp;module=Linux_ext.Timerfd&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Span&amp;type=t">Span.t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">set_repeating ?initial t interval</code> sets <code class="code">t</code> to fire every <code class="code">interval</code> starting at
      <code class="code">when</code>.</div></div>
<pre><span class="VALclear"><span class="keyword">val</span> clear</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">clear t</code> causes <code class="code">t</code> to not fire any more.</div></div>
<pre><code><span class="TYPErepeat"><span class="keyword">type</span> repeat</span> = {</code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTrepeat.fire_after">fire_after</span> : <code class="type"><a href="?package=core&amp;module=Span&amp;type=t">Span.t</a></code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTrepeat.interval">interval</span> : <code class="type"><a href="?package=core&amp;module=Span&amp;type=t">Span.t</a></code>;</code></td></tr><tr><td>}</td></tr></table>
<pre><span class="VALget"><span class="keyword">val</span> get</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd&amp;type=t">t</a> -&gt; [ `Fire_after of <a href="?package=core&amp;module=Span&amp;type=t">Span.t</a> | `Not_armed | `Repeat of <a href="?package=core&amp;module=Linux_ext.Timerfd&amp;type=repeat">repeat</a> ]</code></pre><div class="info"><div class="info"><code class="code">get t</code> returns the current state of the timer <code class="code">t</code>.</div></div>
<pre><span class="VALt_of_sexp"><span class="keyword">val</span> t_of_sexp</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a> -&gt; <a href="?package=core&amp;module=Linux_ext.Timerfd&amp;type=t">t</a></code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre>
<pre><span class="VALcompare"><span class="keyword">val</span> compare</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Linux_ext.Timerfd&amp;type=t">t</a> -&gt; int</code></pre>
<pre><span class="VALbin_t"><span class="keyword">val</span> bin_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Type_class&amp;type=t">Core_kernel.Std.Bin_prot.Type_class.t</a></code></pre>
<pre><span class="VALbin_read_t"><span class="keyword">val</span> bin_read_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Read_ml&amp;type=reader">Core_kernel.Std.Bin_prot.Read_ml.reader</a></code></pre>
<pre><span class="VALbin_read_t_"><span class="keyword">val</span> bin_read_t_</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Unsafe_read_c&amp;type=reader">Core_kernel.Std.Bin_prot.Unsafe_read_c.reader</a></code></pre>
<pre><span class="VALbin_read_t__"><span class="keyword">val</span> bin_read_t__</span> : <code class="type">(int -&gt; <a href="?package=core&amp;module=Linux_ext.Timerfd&amp;type=t">t</a>) <a href="?package=core_kernel&amp;module=Std.Bin_prot.Unsafe_read_c&amp;type=reader">Core_kernel.Std.Bin_prot.Unsafe_read_c.reader</a></code></pre>
<pre><span class="VALbin_reader_t"><span class="keyword">val</span> bin_reader_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Type_class&amp;type=reader">Core_kernel.Std.Bin_prot.Type_class.reader</a></code></pre>
<pre><span class="VALbin_size_t"><span class="keyword">val</span> bin_size_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Size&amp;type=sizer">Core_kernel.Std.Bin_prot.Size.sizer</a></code></pre>
<pre><span class="VALbin_write_t"><span class="keyword">val</span> bin_write_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Write_ml&amp;type=writer">Core_kernel.Std.Bin_prot.Write_ml.writer</a></code></pre>
<pre><span class="VALbin_write_t_"><span class="keyword">val</span> bin_write_t_</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Unsafe_write_c&amp;type=writer">Core_kernel.Std.Bin_prot.Unsafe_write_c.writer</a></code></pre>
<pre><span class="VALbin_writer_t"><span class="keyword">val</span> bin_writer_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Timerfd&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Type_class&amp;type=writer">Core_kernel.Std.Bin_prot.Type_class.writer</a></code></pre>
<div class="info"><div class="info"><code class="code">create ?flags clock</code> creates a new timer file descriptor.  With Linux 2.6.26 or
      earlier <code class="code">flags</code> must be empty.</div></div>
<div class="info"><div class="info"><code class="code">set t when</code> sets <code class="code">t</code> to fire once, at the time specified by <code class="code">when</code>.</div></div>
<div class="info"><div class="info"><code class="code">set_repeating ?initial t interval</code> sets <code class="code">t</code> to fire every <code class="code">interval</code> starting at
      <code class="code">when</code>.</div></div>
<div class="info"><div class="info">default is <code class="code">`After interval</code></div></div>
<div class="info"><div class="info"><code class="code">clear t</code> causes <code class="code">t</code> to not fire any more.</div></div>
<div class="info"><div class="info"><code class="code">get t</code> returns the current state of the timer <code class="code">t</code>.</div></div></div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">Parent death notifications</h2></div></div>
<pre><span class="VALpr_set_pdeathsig"><span class="keyword">val</span> pr_set_pdeathsig</span> : <code class="type">(<a href="?package=core&amp;module=Signal&amp;type=t">Signal.t</a> -&gt; unit) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">pr_set_pdeathsig s</code> sets the signal <code class="code">s</code> to be sent to the executing
    process when its parent dies.  NOTE: the parent may have died
    before or while executing this system call.  To make sure that you
    do not miss this event, you should call  <a href="#getppid">getppid</a> to get
    the parent process id after this system call.  If the parent has
    died, the returned parent PID will be 1, i.e. the init process will
    have adopted the child.  You should then either send the signal to
    yourself using Unix.kill, or execute an appropriate handler.</div></div>
<pre><span class="VALpr_get_pdeathsig"><span class="keyword">val</span> pr_get_pdeathsig</span> : <code class="type">(unit -&gt; <a href="?package=core&amp;module=Signal&amp;type=t">Signal.t</a>) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">pr_get_pdeathsig ()</code> get the signal that will be sent to the
    currently executing process when its parent dies.</div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">Task name</h2></div></div>
<pre><span class="VALpr_set_name_first16"><span class="keyword">val</span> pr_set_name_first16</span> : <code class="type">(string -&gt; unit) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">pr_set_name_first16 name</code> sets the name of the executing thread to <code class="code">name</code>.  Only
    the first 16 bytes in <code class="code">name</code> will be used, the rest is ignored.</div></div>
<pre><span class="VALpr_get_name"><span class="keyword">val</span> pr_get_name</span> : <code class="type">(unit -&gt; string) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">pr_get_name ()</code> gets the name of the executing thread.  The name is
    at most 16 bytes long.</div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">Pathname resolution</h2></div></div>
<pre><span class="VALfile_descr_realpath"><span class="keyword">val</span> file_descr_realpath</span> : <code class="type">(<a href="?package=core&amp;module=Core_unix.File_descr&amp;type=t">Core_unix.File_descr.t</a> -&gt; string) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">file_descr_realpath fd</code> <b>Raises</b> <code>Unix_error</code> on errors.<br/> <b>Returns</b> the canonicalized absolute
    pathname of the file associated with file descriptor <code class="code">fd</code>.</div></div>
<pre><span class="VALout_channel_realpath"><span class="keyword">val</span> out_channel_realpath</span> : <code class="type">(<a href="?package=ocaml&amp;module=Pervasives&amp;type=out_channel">Pervasives.out_channel</a> -&gt; string) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">out_channel_realpath oc</code> <b>Raises</b> <code>Unix_error</code> on errors.<br/> <b>Returns</b> the canonicalized absolute
    pathname of the file associated with output channel <code class="code">oc</code>.</div></div>
<pre><span class="VALin_channel_realpath"><span class="keyword">val</span> in_channel_realpath</span> : <code class="type">(<a href="?package=ocaml&amp;module=Pervasives&amp;type=in_channel">Pervasives.in_channel</a> -&gt; string) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">in_channel_realpath ic</code> <b>Raises</b> <code>Unix_error</code> on errors.<br/> <b>Returns</b> the canonicalized absolute
    pathname of the file associated with input channel <code class="code">ic</code>.</div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">Affinity</h2></div></div>
<pre><span class="VALsched_setaffinity"><span class="keyword">val</span> sched_setaffinity</span> : <code class="type">(?pid:<a href="?package=core_kernel&amp;module=Std.Pid&amp;type=t">Core_kernel.Std.Pid.t</a> -&gt; cpuset:int list -&gt; unit -&gt; unit)
<a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre>
<pre><span class="VALsched_setaffinity_this_thread"><span class="keyword">val</span> sched_setaffinity_this_thread</span> : <code class="type">(cpuset:int list -&gt; unit) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre>
<pre><span class="VALcores"><span class="keyword">val</span> cores</span> : <code class="type">(unit -&gt; int) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">cores ()</code> <b>Returns</b> the number of cores on the machine</div></div>
<pre><span class="VALget_terminal_size"><span class="keyword">val</span> get_terminal_size</span> : <code class="type">(unit -&gt; int * int) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">get_terminal_size ()</code> <b>Returns</b> <code class="code">(rows, cols)</code>, the number of rows and
    columns of the terminal.</div></div>
<pre><span class="VALgettid"><span class="keyword">val</span> gettid</span> : <code class="type">(unit -&gt; int) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre>
<div class="ocaml_module sig" name="Priority"><pre><span class="keyword">module</span> <a href="?package=core&amp;module=Linux_ext.Priority">Priority</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEt"><span class="keyword">type</span> t</span> </pre>
<pre><span class="VALequal"><span class="keyword">val</span> equal</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Priority&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Linux_ext.Priority&amp;type=t">t</a> -&gt; bool</code></pre>
<pre><span class="VALof_int"><span class="keyword">val</span> of_int</span> : <code class="type">int -&gt; <a href="?package=core&amp;module=Linux_ext.Priority&amp;type=t">t</a></code></pre>
<pre><span class="VALto_int"><span class="keyword">val</span> to_int</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Priority&amp;type=t">t</a> -&gt; int</code></pre>
<pre><span class="VALincr"><span class="keyword">val</span> incr</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Priority&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Linux_ext.Priority&amp;type=t">t</a></code></pre>
<pre><span class="VALdecr"><span class="keyword">val</span> decr</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Priority&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Linux_ext.Priority&amp;type=t">t</a></code></pre>
<pre><span class="VALt_of_sexp"><span class="keyword">val</span> t_of_sexp</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a> -&gt; <a href="?package=core&amp;module=Linux_ext.Priority&amp;type=t">t</a></code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Priority&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre></div></div>
<pre><span class="VALsetpriority"><span class="keyword">val</span> setpriority</span> : <code class="type">(<a href="?package=core&amp;module=Linux_ext.Priority&amp;type=t">Priority.t</a> -&gt; unit) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info">Set the calling thread's priority in the linux scheduler</div></div>
<pre><span class="VALgetpriority"><span class="keyword">val</span> getpriority</span> : <code class="type">(unit -&gt; <a href="?package=core&amp;module=Linux_ext.Priority&amp;type=t">Priority.t</a>) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info">Get the calling thread's priority in the linux scheduler</div></div>
<pre><span class="VALget_ipv4_address_for_interface"><span class="keyword">val</span> get_ipv4_address_for_interface</span> : <code class="type">(string -&gt; string) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre>
<pre><span class="VALbind_to_interface"><span class="keyword">val</span> bind_to_interface</span> : <code class="type">(<a href="?package=core&amp;module=Core_unix.File_descr&amp;type=t">Core_unix.File_descr.t</a> -&gt; [ `Any | `Interface_name of string ] -&gt; unit)
<a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre>
<div class="ocaml_module sig" name="Epoll"><pre><span class="keyword">module</span> <a href="?package=core&amp;module=Linux_ext.Epoll">Epoll</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="info"><div class="info">epoll() - a linux I/O multiplexer of the same family as select() or poll().  Its main
    differences are support for Edge or Level triggered notifications (We're using
    Level-triggered to emulate select) and much better scaling with the number of file
    descriptors.<p>    See the man pages for a full description of the epoll facility.</p></div></div><div class="ocaml_module_content">
<div class="ocaml_module sig" name="Flags"><pre><span class="keyword">module</span> <a href="?package=core&amp;module=Linux_ext.Epoll.Flags">Flags</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEt"><span class="keyword">type</span> t</span> </pre><div class="info"><div class="info">An <code class="code">Epoll.Flags.t</code> is an immutable set of flags for which one can register
        interest for a file descriptor.  It is implemented as a bitmask, and so all
        operations (+, -, etc.) are constant time with no allocation.<p>        <code class="code">sexp_of_t</code> produces a human-readable list of bits, e.g. &quot;(in out)&quot;.</p></div></div>
<div class="ocaml_include ident" path="?package=core_kernel&amp;module=Std.Flags.S" items="[]"><pre><span class="keyword">include</span> <code class="type"><code class="code"><a href="?package=core_kernel&amp;module=Std.Flags.S">Core_kernel.Std.Flags.S</a></code> with type t := <a href="?package=core&amp;module=Linux_ext.Epoll.Flags&amp;type=t">t</a></code></pre></div>
<pre><span class="VALnone"><span class="keyword">val</span> none</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Epoll.Flags&amp;type=t">t</a></code></pre>
<pre><span class="VALin_"><span class="keyword">val</span> in_</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Epoll.Flags&amp;type=t">t</a></code></pre>
<pre><span class="VALout"><span class="keyword">val</span> out</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Epoll.Flags&amp;type=t">t</a></code></pre>
<pre><span class="VALpri"><span class="keyword">val</span> pri</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Epoll.Flags&amp;type=t">t</a></code></pre>
<pre><span class="VALerr"><span class="keyword">val</span> err</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Epoll.Flags&amp;type=t">t</a></code></pre>
<pre><span class="VALhup"><span class="keyword">val</span> hup</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Epoll.Flags&amp;type=t">t</a></code></pre>
<pre><span class="VALet"><span class="keyword">val</span> et</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Epoll.Flags&amp;type=t">t</a></code></pre>
<pre><span class="VALoneshot"><span class="keyword">val</span> oneshot</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Epoll.Flags&amp;type=t">t</a></code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Epoll.Flags&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre></div></div>
<pre><span class="TYPEt"><span class="keyword">type</span> t</span> </pre><div class="info"><div class="info">An <code class="code">Epoll.t</code> maintains a map from <code class="code">File_descr.t</code> to <code class="code">Flags.t</code>, where the domain is
      the set of file descriptors that one is interested in, and the flags associated with
      each file descriptor specify the types of events one is interested in being notified
      about for that file descriptor.  Our implementation maintains a user-level table
      equivalent to the kernel epoll set, so that <code class="code">sexp_of_t</code> produces useful
      human-readable information, and so that we can present our standard table
      interface.<p>      An <code class="code">Epoll.t</code> also has a buffer that is used to store the set of ready fds returned
      by calling <code class="code">wait</code>.</p></div></div>
<pre><span class="VALinvariant"><span class="keyword">val</span> invariant</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Epoll&amp;type=t">t</a> -&gt; unit</code></pre>
<pre><span class="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">(num_file_descrs:int -&gt; max_ready_events:int -&gt; <a href="?package=core&amp;module=Linux_ext.Epoll&amp;type=t">t</a>) <a href="?package=core_kernel&amp;module=Std.Or_error&amp;type=t">Core_kernel.Std.Or_error.t</a></code></pre><div class="info"><div class="info"><code class="code">create ~num_file_descrs</code> creates a new epoll set able to watch file descriptors in
      [0, num_file_descrs).  Additionally, the set allocates space for reading the ready
      events when <code class="code">wait</code> returns, allowing for up to <code class="code">max_ready_events</code> to be returned in
      a single call to <code class="code">wait</code>.</div></div>
<pre><span class="VALfind"><span class="keyword">val</span> find</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Epoll&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Core_unix.File_descr&amp;type=t">Core_unix.File_descr.t</a> -&gt; <a href="?package=core&amp;module=Linux_ext.Epoll.Flags&amp;type=t">Flags.t</a> option</code></pre><div class="info"><div class="info">map operations</div></div>
<pre><span class="VALfind_exn"><span class="keyword">val</span> find_exn</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Epoll&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Core_unix.File_descr&amp;type=t">Core_unix.File_descr.t</a> -&gt; <a href="?package=core&amp;module=Linux_ext.Epoll.Flags&amp;type=t">Flags.t</a></code></pre>
<pre><span class="VALset"><span class="keyword">val</span> set</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Epoll&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Core_unix.File_descr&amp;type=t">Core_unix.File_descr.t</a> -&gt; <a href="?package=core&amp;module=Linux_ext.Epoll.Flags&amp;type=t">Flags.t</a> -&gt; unit</code></pre>
<pre><span class="VALremove"><span class="keyword">val</span> remove</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Epoll&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Core_unix.File_descr&amp;type=t">Core_unix.File_descr.t</a> -&gt; unit</code></pre>
<pre><span class="VALiter"><span class="keyword">val</span> iter</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Epoll&amp;type=t">t</a> -&gt; f:(<a href="?package=core&amp;module=Core_unix.File_descr&amp;type=t">Core_unix.File_descr.t</a> -&gt; <a href="?package=core&amp;module=Linux_ext.Epoll.Flags&amp;type=t">Flags.t</a> -&gt; unit) -&gt; unit</code></pre>
<pre><span class="VALwait"><span class="keyword">val</span> wait</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Epoll&amp;type=t">t</a> -&gt;
timeout:[ `After of <a href="?package=core&amp;module=Span&amp;type=t">Span.t</a> | `Immediately | `Never ] -&gt; [ `Ok | `Timeout ]</code></pre><div class="info"><div class="info"><code class="code">wait t ~timeout</code> blocks until at least one file descriptor in <code class="code">t</code> is ready for one
      of the events it is being watched for, or <code class="code">timeout</code> passes.  <code class="code">wait</code> side effects <code class="code">t</code>
      by storing the ready set in it.  One can subsequently access the ready set by
      calling <code class="code">iter_ready</code> or <code class="code">fold_ready</code>.<p>      The <code class="code">timeout</code> has a granularity of one millisecond.  <code class="code">wait</code> rounds up the <code class="code">timeout</code>
      to the next millisecond.  E.g. a <code class="code">timeout</code> of one microsecond will be rounded up
      to one millisecond.</p><p>      Note that this method should not be considered thread safe.  There is mutable state
      in t that will be changed by invocations to wait that cannot be prevented by mutexes
      around <code class="code">wait</code>.</p></div></div>
<pre><span class="VALiter_ready"><span class="keyword">val</span> iter_ready</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Epoll&amp;type=t">t</a> -&gt; f:(<a href="?package=core&amp;module=Core_unix.File_descr&amp;type=t">Core_unix.File_descr.t</a> -&gt; <a href="?package=core&amp;module=Linux_ext.Epoll.Flags&amp;type=t">Flags.t</a> -&gt; unit) -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">iter_ready</code> and <code class="code">fold_ready</code> iterate over the ready set computed by the last
      call to <code class="code">wait</code>.</div></div>
<pre><span class="VALfold_ready"><span class="keyword">val</span> fold_ready</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Epoll&amp;type=t">t</a> -&gt; init:'a -&gt; f:('a -&gt; <a href="?package=core&amp;module=Core_unix.File_descr&amp;type=t">Core_unix.File_descr.t</a> -&gt; <a href="?package=core&amp;module=Linux_ext.Epoll.Flags&amp;type=t">Flags.t</a> -&gt; 'a) -&gt; 'a</code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext.Epoll&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre>
<div class="info"><div class="info"><code class="code">create ~num_file_descrs</code> creates a new epoll set able to watch file descriptors in
      [0, num_file_descrs).  Additionally, the set allocates space for reading the ready
      events when <code class="code">wait</code> returns, allowing for up to <code class="code">max_ready_events</code> to be returned in
      a single call to <code class="code">wait</code>.</div></div>
<div class="info"><div class="info">map operations</div></div>
<div class="info"><div class="info"><code class="code">wait t ~timeout</code> blocks until at least one file descriptor in <code class="code">t</code> is ready for one
      of the events it is being watched for, or <code class="code">timeout</code> passes.  <code class="code">wait</code> side effects <code class="code">t</code>
      by storing the ready set in it.  One can subsequently access the ready set by
      calling <code class="code">iter_ready</code> or <code class="code">fold_ready</code>.<p>      The <code class="code">timeout</code> has a granularity of one millisecond.  <code class="code">wait</code> rounds up the <code class="code">timeout</code>
      to the next millisecond.  E.g. a <code class="code">timeout</code> of one microsecond will be rounded up
      to one millisecond.</p><p>      Note that this method should not be considered thread safe.  There is mutable state
      in t that will be changed by invocations to wait that cannot be prevented by mutexes
      around <code class="code">wait</code>.</p></div></div>
<div class="info"><div class="info"><code class="code">iter_ready</code> and <code class="code">fold_ready</code> iterate over the ready set computed by the last
      call to <code class="code">wait</code>.</div></div></div></div>
<pre><span class="VALbin_tcp_bool_option"><span class="keyword">val</span> bin_tcp_bool_option</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext&amp;type=tcp_bool_option">tcp_bool_option</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Type_class&amp;type=t">Core_kernel.Std.Bin_prot.Type_class.t</a></code></pre>
<pre><span class="VALbin_read_tcp_bool_option"><span class="keyword">val</span> bin_read_tcp_bool_option</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext&amp;type=tcp_bool_option">tcp_bool_option</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Read_ml&amp;type=reader">Core_kernel.Std.Bin_prot.Read_ml.reader</a></code></pre>
<pre><span class="VALbin_read_tcp_bool_option_"><span class="keyword">val</span> bin_read_tcp_bool_option_</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext&amp;type=tcp_bool_option">tcp_bool_option</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Unsafe_read_c&amp;type=reader">Core_kernel.Std.Bin_prot.Unsafe_read_c.reader</a></code></pre>
<pre><span class="VALbin_read_tcp_bool_option__"><span class="keyword">val</span> bin_read_tcp_bool_option__</span> : <code class="type">(int -&gt; <a href="?package=core&amp;module=Linux_ext&amp;type=tcp_bool_option">tcp_bool_option</a>) <a href="?package=core_kernel&amp;module=Std.Bin_prot.Unsafe_read_c&amp;type=reader">Core_kernel.Std.Bin_prot.Unsafe_read_c.reader</a></code></pre>
<pre><span class="VALbin_reader_tcp_bool_option"><span class="keyword">val</span> bin_reader_tcp_bool_option</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext&amp;type=tcp_bool_option">tcp_bool_option</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Type_class&amp;type=reader">Core_kernel.Std.Bin_prot.Type_class.reader</a></code></pre>
<pre><span class="VALbin_size_tcp_bool_option"><span class="keyword">val</span> bin_size_tcp_bool_option</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext&amp;type=tcp_bool_option">tcp_bool_option</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Size&amp;type=sizer">Core_kernel.Std.Bin_prot.Size.sizer</a></code></pre>
<pre><span class="VALbin_write_tcp_bool_option"><span class="keyword">val</span> bin_write_tcp_bool_option</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext&amp;type=tcp_bool_option">tcp_bool_option</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Write_ml&amp;type=writer">Core_kernel.Std.Bin_prot.Write_ml.writer</a></code></pre>
<pre><span class="VALbin_write_tcp_bool_option_"><span class="keyword">val</span> bin_write_tcp_bool_option_</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext&amp;type=tcp_bool_option">tcp_bool_option</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Unsafe_write_c&amp;type=writer">Core_kernel.Std.Bin_prot.Unsafe_write_c.writer</a></code></pre>
<pre><span class="VALbin_writer_tcp_bool_option"><span class="keyword">val</span> bin_writer_tcp_bool_option</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext&amp;type=tcp_bool_option">tcp_bool_option</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Type_class&amp;type=writer">Core_kernel.Std.Bin_prot.Type_class.writer</a></code></pre>
<pre><span class="VALtcp_bool_option_of_sexp"><span class="keyword">val</span> tcp_bool_option_of_sexp</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a> -&gt; <a href="?package=core&amp;module=Linux_ext&amp;type=tcp_bool_option">tcp_bool_option</a></code></pre>
<pre><span class="VALsexp_of_tcp_bool_option"><span class="keyword">val</span> sexp_of_tcp_bool_option</span> : <code class="type"><a href="?package=core&amp;module=Linux_ext&amp;type=tcp_bool_option">tcp_bool_option</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre>
<div class="info"><div class="info"><code class="code">gettcpopt_bool sock opt</code> <b>Returns</b> the current value of the boolean
    TCP socket option <code class="code">opt</code> for socket <code class="code">sock</code>.</div></div>
<div class="info"><div class="info"><code class="code">settcpopt_bool sock opt v</code> sets the current value of the boolean
    TCP socket option <code class="code">opt</code> for socket <code class="code">sock</code> to value <code class="code">v</code>.</div></div>
<div class="info"><div class="info"><code class="code">send_nonblocking_no_sigpipe sock ?pos ?len buf</code> tries to do a
    nonblocking send on socket <code class="code">sock</code> given buffer <code class="code">buf</code>, offset <code class="code">pos</code>
    and length <code class="code">len</code>.  Prevents <code class="code">SIGPIPE</code>, i.e. raise a Unix-error
    in that case immediately.<div class="parameters"><div class="param_info"><code class="code">pos</code> : default = 0</div><div class="param_info"><code class="code">len</code> : default = <code class="code">String.length buf - pos</code></div></div> <b>Raises</b> <code>Invalid_argument</code> if the designated buffer range is invalid.<br/><code>Unix_error</code> on Unix-errors.<br/> <b>Returns</b> <code class="code">Some bytes_written</code> or <code class="code">None</code>
    if the operation would have blocked.</div></div>
<div class="info"><div class="info"><code class="code">send_no_sigpipe sock ?pos ?len buf</code> tries to do a
    blocking send on socket <code class="code">sock</code> given buffer <code class="code">buf</code>, offset <code class="code">pos</code>
    and length <code class="code">len</code>.  Prevents <code class="code">SIGPIPE</code>, i.e. raise a Unix-error in
    that case immediately.<div class="parameters"><div class="param_info"><code class="code">pos</code> : default = 0</div><div class="param_info"><code class="code">len</code> : default = <code class="code">String.length buf - pos</code></div></div> <b>Raises</b> <code>Invalid_argument</code> if the designated buffer range is invalid.<br/><code>Unix_error</code> on Unix-errors.<br/> <b>Returns</b> the number of bytes written.</div></div>
<div class="info"><div class="info"><code class="code">sendmsg_nonblocking_no_sigpipe sock ?count iovecs</code> tries to do
    a nonblocking send on socket <code class="code">sock</code> using <code class="code">count</code> I/O-vectors
    <code class="code">iovecs</code>.  Prevents <code class="code">SIGPIPE</code>, i.e. raises a Unix-error in that
    case immediately. <b>Raises</b> <code>Invalid_argument</code> if the designated ranges are invalid.<br/><code>Unix_error</code> on Unix-errors.<br/> <b>Returns</b> <code class="code">Some bytes_written</code> or <code class="code">None</code> if the
    operation would have blocked.</div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">Clock functions</h2></div></div>
<div class="info"><div class="info"><code class="code">get_process_clock</code> the clock measuring the CPU-time of a process.</div></div>
<div class="info"><div class="info"><code class="code">get_thread_clock</code> the clock measuring the CPU-time of the current thread.</div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">Timerfd functions</h2></div></div>
<div class="info"><div class="info">Clock used to mark the progress of a timer.</div></div>
<div class="info"><div class="info">Settable system-wide clock.</div></div>
<div class="info"><div class="info">Nonsettable clock.  It is not affected by manual changes to the system time.</div></div>
<div class="info"><div class="info"><code class="code">TFD_NONBLOCK</code></div></div>
<div class="info"><div class="info"><code class="code">TFD_CLOEXEC</code></div></div>
<div class="info"><div class="info"><code class="code">create ?flags clock</code> creates a new timer file descriptor.  With Linux 2.6.26 or
      earlier <code class="code">flags</code> must be empty.</div></div>
<div class="info"><div class="info"><code class="code">set t when</code> sets <code class="code">t</code> to fire once, at the time specified by <code class="code">when</code>.</div></div>
<div class="info"><div class="info"><code class="code">set_repeating ?initial t interval</code> sets <code class="code">t</code> to fire every <code class="code">interval</code> starting at
      <code class="code">when</code>.</div></div>
<div class="info"><div class="info">default is <code class="code">`After interval</code></div></div>
<div class="info"><div class="info"><code class="code">clear t</code> causes <code class="code">t</code> to not fire any more.</div></div>
<div class="info"><div class="info"><code class="code">get t</code> returns the current state of the timer <code class="code">t</code>.</div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">Parent death notifications</h2></div></div>
<div class="info"><div class="info"><code class="code">pr_set_pdeathsig s</code> sets the signal <code class="code">s</code> to be sent to the executing
    process when its parent dies.  NOTE: the parent may have died
    before or while executing this system call.  To make sure that you
    do not miss this event, you should call  <a href="#getppid">getppid</a> to get
    the parent process id after this system call.  If the parent has
    died, the returned parent PID will be 1, i.e. the init process will
    have adopted the child.  You should then either send the signal to
    yourself using Unix.kill, or execute an appropriate handler.</div></div>
<div class="info"><div class="info"><code class="code">pr_get_pdeathsig ()</code> get the signal that will be sent to the
    currently executing process when its parent dies.</div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">Task name</h2></div></div>
<div class="info"><div class="info"><code class="code">pr_set_name_first16 name</code> sets the name of the executing thread to <code class="code">name</code>.  Only
    the first 16 bytes in <code class="code">name</code> will be used, the rest is ignored.</div></div>
<div class="info"><div class="info"><code class="code">pr_get_name ()</code> gets the name of the executing thread.  The name is
    at most 16 bytes long.</div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">Pathname resolution</h2></div></div>
<div class="info"><div class="info"><code class="code">file_descr_realpath fd</code> <b>Raises</b> <code>Unix_error</code> on errors.<br/> <b>Returns</b> the canonicalized absolute
    pathname of the file associated with file descriptor <code class="code">fd</code>.</div></div>
<div class="info"><div class="info"><code class="code">out_channel_realpath oc</code> <b>Raises</b> <code>Unix_error</code> on errors.<br/> <b>Returns</b> the canonicalized absolute
    pathname of the file associated with output channel <code class="code">oc</code>.</div></div>
<div class="info"><div class="info"><code class="code">in_channel_realpath ic</code> <b>Raises</b> <code>Unix_error</code> on errors.<br/> <b>Returns</b> the canonicalized absolute
    pathname of the file associated with input channel <code class="code">ic</code>.</div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">Affinity</h2></div></div>
<div class="info"><div class="info"><code class="code">cores ()</code> <b>Returns</b> the number of cores on the machine</div></div>
<div class="info"><div class="info"><code class="code">get_terminal_size ()</code> <b>Returns</b> <code class="code">(rows, cols)</code>, the number of rows and
    columns of the terminal.</div></div>
<div class="info"><div class="info">Set the calling thread's priority in the linux scheduler</div></div>
<div class="info"><div class="info">Get the calling thread's priority in the linux scheduler</div></div>
<div class="info"><div class="info">epoll() - a linux I/O multiplexer of the same family as select() or poll().  Its main
    differences are support for Edge or Level triggered notifications (We're using
    Level-triggered to emulate select) and much better scaling with the number of file
    descriptors.<p>    See the man pages for a full description of the epoll facility.</p></div></div>
<div class="info"><div class="info">An <code class="code">Epoll.Flags.t</code> is an immutable set of flags for which one can register
        interest for a file descriptor.  It is implemented as a bitmask, and so all
        operations (+, -, etc.) are constant time with no allocation.<p>        <code class="code">sexp_of_t</code> produces a human-readable list of bits, e.g. &quot;(in out)&quot;.</p></div></div>
<div class="info"><div class="info">An <code class="code">Epoll.t</code> maintains a map from <code class="code">File_descr.t</code> to <code class="code">Flags.t</code>, where the domain is
      the set of file descriptors that one is interested in, and the flags associated with
      each file descriptor specify the types of events one is interested in being notified
      about for that file descriptor.  Our implementation maintains a user-level table
      equivalent to the kernel epoll set, so that <code class="code">sexp_of_t</code> produces useful
      human-readable information, and so that we can present our standard table
      interface.<p>      An <code class="code">Epoll.t</code> also has a buffer that is used to store the set of ready fds returned
      by calling <code class="code">wait</code>.</p></div></div>
<div class="info"><div class="info"><code class="code">create ~num_file_descrs</code> creates a new epoll set able to watch file descriptors in
      [0, num_file_descrs).  Additionally, the set allocates space for reading the ready
      events when <code class="code">wait</code> returns, allowing for up to <code class="code">max_ready_events</code> to be returned in
      a single call to <code class="code">wait</code>.</div></div>
<div class="info"><div class="info">map operations</div></div>
<div class="info"><div class="info"><code class="code">wait t ~timeout</code> blocks until at least one file descriptor in <code class="code">t</code> is ready for one
      of the events it is being watched for, or <code class="code">timeout</code> passes.  <code class="code">wait</code> side effects <code class="code">t</code>
      by storing the ready set in it.  One can subsequently access the ready set by
      calling <code class="code">iter_ready</code> or <code class="code">fold_ready</code>.<p>      The <code class="code">timeout</code> has a granularity of one millisecond.  <code class="code">wait</code> rounds up the <code class="code">timeout</code>
      to the next millisecond.  E.g. a <code class="code">timeout</code> of one microsecond will be rounded up
      to one millisecond.</p><p>      Note that this method should not be considered thread safe.  There is mutable state
      in t that will be changed by invocations to wait that cannot be prevented by mutexes
      around <code class="code">wait</code>.</p></div></div>
<div class="info"><div class="info"><code class="code">iter_ready</code> and <code class="code">fold_ready</code> iterate over the ready set computed by the last
      call to <code class="code">wait</code>.</div></div>
</div>