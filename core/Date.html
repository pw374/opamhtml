<div class="ocaml_toplevel_module"><pre><code><span class="TYPEt"><span class="keyword">type</span> t</span> = {<span class="keyword">private</span></code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTt.y">y</span> : <code class="type">int</code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTt.m">m</span> : <code class="type"><a href="?package=core_kernel&amp;module=Std.Month&amp;type=t">Core_kernel.Std.Month.t</a></code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTt.d">d</span> : <code class="type">int</code>;</code></td></tr><tr><td>}</td></tr></table>
<div class="ocaml_include ident" path="?package=core_kernel&amp;module=Std.Hashable_binable" items="[&quot;Hash_queue&quot;,&quot;Hash_set&quot;,&quot;Pooled_hashtbl&quot;,&quot;Table&quot;,&quot;Hashable&quot;]"><pre><span class="keyword">include</span> <code class="type"><code class="code"><a href="?package=core_kernel&amp;module=Std.Hashable_binable">Core_kernel.Std.Hashable_binable</a></code> with type t := <a href="?package=core&amp;module=Date&amp;type=t">t</a></code></pre><div class="info"><div class="info">converts a string to a date, in formats:
 m/d/y
 y-m-d (* valid iso8601_extended *)
 DD MMM YYYY
 DDMMMYYYY
 YYYYMMDD</div></div></div>
<div class="ocaml_include ident" path="?package=core_kernel&amp;module=Std.Stringable" items="[]"><pre><span class="keyword">include</span> <code class="type"><code class="code"><a href="?package=core_kernel&amp;module=Std.Stringable">Core_kernel.Std.Stringable</a></code> with type t := <a href="?package=core&amp;module=Date&amp;type=t">t</a></code></pre></div>
<div class="ocaml_include ident" path="?package=core_kernel&amp;module=Std.Comparable_binable" items="[&quot;Set&quot;,&quot;Map&quot;,&quot;Replace_polymorphic_compare&quot;]"><pre><span class="keyword">include</span> <code class="type"><code class="code"><a href="?package=core_kernel&amp;module=Std.Comparable_binable">Core_kernel.Std.Comparable_binable</a></code> with type t := <a href="?package=core&amp;module=Date&amp;type=t">t</a></code></pre></div>
<div class="ocaml_include ident" path="?package=core_kernel&amp;module=Std.Pretty_printer.S" items="[]"><pre><span class="keyword">include</span> <code class="type"><code class="code"><a href="?package=core_kernel&amp;module=Std.Pretty_printer.S">Core_kernel.Std.Pretty_printer.S</a></code> with type t := <a href="?package=core&amp;module=Date&amp;type=t">t</a></code></pre></div>
<pre><span class="VALcreate_exn"><span class="keyword">val</span> create_exn</span> : <code class="type">y:int -&gt; m:<a href="?package=core_kernel&amp;module=Std.Month&amp;type=t">Core_kernel.Std.Month.t</a> -&gt; d:int -&gt; <a href="?package=core&amp;module=Date&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">create_exn ~y ~m ~d</code> creates the date specified in the arguments.  Arguments are
    validated, and are not normalized in any way.  So, days must be within the limits for
    the month in question, numbers cannot be negative, years must be fully specified, etc.</div></div>
<pre><span class="VALof_tm"><span class="keyword">val</span> of_tm</span> : <code class="type"><a href="?package=core&amp;module=Core_unix&amp;type=tm">Core_unix.tm</a> -&gt; <a href="?package=core&amp;module=Date&amp;type=t">t</a></code></pre>
<pre><span class="VALof_string_iso8601_basic"><span class="keyword">val</span> of_string_iso8601_basic</span> : <code class="type">string -&gt; pos:int -&gt; <a href="?package=core&amp;module=Date&amp;type=t">t</a></code></pre>
<pre><span class="VALto_string_iso8601_basic"><span class="keyword">val</span> to_string_iso8601_basic</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; string</code></pre>
<pre><span class="VALto_string_american"><span class="keyword">val</span> to_string_american</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; string</code></pre>
<pre><span class="VALday"><span class="keyword">val</span> day</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; int</code></pre>
<pre><span class="VALmonth"><span class="keyword">val</span> month</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; <a href="?package=core_kernel&amp;module=Std.Month&amp;type=t">Core_kernel.Std.Month.t</a></code></pre>
<pre><span class="VALyear"><span class="keyword">val</span> year</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; int</code></pre>
<pre><span class="VALday_of_week"><span class="keyword">val</span> day_of_week</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; <a href="?package=core_kernel&amp;module=Std.Day_of_week&amp;type=t">Core_kernel.Std.Day_of_week.t</a></code></pre>
<pre><span class="VALis_weekend"><span class="keyword">val</span> is_weekend</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; bool</code></pre>
<pre><span class="VALis_weekday"><span class="keyword">val</span> is_weekday</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; bool</code></pre>
<pre><span class="VALis_business_day"><span class="keyword">val</span> is_business_day</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; is_holiday:(<a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; bool) -&gt; bool</code></pre>
<pre><span class="VALadd_days"><span class="keyword">val</span> add_days</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; int -&gt; <a href="?package=core&amp;module=Date&amp;type=t">t</a></code></pre>
<pre><span class="VALadd_months"><span class="keyword">val</span> add_months</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; int -&gt; <a href="?package=core&amp;module=Date&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">add_months t n</code> returns date with max days for the month if the date would be
    invalid. e.g. adding 1 month to Jan 30 results in Feb 28 due to Feb 30 being
    an invalid date, Feb 29 is returned in cases of leap year. *</div></div>
<pre><span class="VALdiff"><span class="keyword">val</span> diff</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">diff t1 t2</code> returns date <code class="code">t1</code> minus date <code class="code">t2</code> in days.</div></div>
<pre><span class="VALadd_weekdays"><span class="keyword">val</span> add_weekdays</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; int -&gt; <a href="?package=core&amp;module=Date&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">add_weekdays t 0</code> returns the next weekday if <code class="code">t</code> is a weekend and <code class="code">t</code> otherwise.
    Unlike add_days this is done by looping over the count of days to be added (forward or
    backwards based on the sign), and is O(n) in the number of days to add.
    Beware, <code class="code">add_weekdays sat 1</code> or <code class="code">add_weekdays sun 1</code> both return the next <code class="code">tue</code>,
    not the next <code class="code">mon</code>. You may want to use <code class="code">following_weekday</code> if you want the next
    following weekday, <code class="code">following_weekday (fri|sat|sun)</code> would all return the next <code class="code">mon</code>.</div></div>
<pre><span class="VALadd_business_days"><span class="keyword">val</span> add_business_days</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; is_holiday:(<a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; bool) -&gt; int -&gt; <a href="?package=core&amp;module=Date&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">add_business_days t ~is_holiday n</code> returns a business day even when
    <code class="code">n=0</code>. <code class="code">add_business_days ~is_holiday:(fun _ -&gt; false) ...</code> is the same as
    <code class="code">add_weekdays</code>. Use <code class="code">Pnl_db.Calendar_events.is_holiday</code> as a conveninent holiday
    function.</div></div>
<pre><span class="VALdates_between"><span class="keyword">val</span> dates_between</span> : <code class="type">min:<a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; max:<a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Date&amp;type=t">t</a> list</code></pre>
<pre><span class="VALbusiness_dates_between"><span class="keyword">val</span> business_dates_between</span> : <code class="type">min:<a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; max:<a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; is_holiday:(<a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; bool) -&gt; <a href="?package=core&amp;module=Date&amp;type=t">t</a> list</code></pre>
<pre><span class="VALweekdays_between"><span class="keyword">val</span> weekdays_between</span> : <code class="type">min:<a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; max:<a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Date&amp;type=t">t</a> list</code></pre>
<pre><span class="VALprevious_weekday"><span class="keyword">val</span> previous_weekday</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Date&amp;type=t">t</a></code></pre>
<pre><span class="VALfollowing_weekday"><span class="keyword">val</span> following_weekday</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Date&amp;type=t">t</a></code></pre>
<pre><span class="VALfirst_strictly_after"><span class="keyword">val</span> first_strictly_after</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; on:<a href="?package=core_kernel&amp;module=Std.Day_of_week&amp;type=t">Core_kernel.Std.Day_of_week.t</a> -&gt; <a href="?package=core&amp;module=Date&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">first_strictly_after t ~on:day_of_week</code> returns the first occurrence of <code class="code">day_of_week</code>
    strictly after <code class="code">t</code>.</div></div>
<div class="ocaml_module sig" name="Export"><pre><span class="keyword">module</span> <a href="?package=core&amp;module=Date.Export">Export</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="TYPE_date"><span class="keyword">type</span> _date</span> = {<code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a></code>}<span class="keyword">private</span></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELT_date.y">y</span> : <code class="type">int</code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELT_date.m">m</span> : <code class="type"><a href="?package=core_kernel&amp;module=Std.Month&amp;type=t">Core_kernel.Std.Month.t</a></code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELT_date.d">d</span> : <code class="type">int</code>;</code></td></tr><tr><td>}</td></tr></table></div></div>
<div class="ocaml_module sig" name="Stable"><pre><span class="keyword">module</span> <a href="?package=core&amp;module=Date.Stable">Stable</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<div class="ocaml_module sig" name="V1"><pre><span class="keyword">module</span> <a href="?package=core&amp;module=Date.Stable.V1">V1</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code> with type <a href="?package=core&amp;module=Date.Stable.V1&amp;type=t">t</a> = <a href="?package=core&amp;module=Date&amp;type=t">t</a></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEt"><span class="keyword">type</span> t</span> </pre>
<pre><span class="VALcompare"><span class="keyword">val</span> compare</span> : <code class="type"><a href="?package=core&amp;module=Date.Stable.V1&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Date.Stable.V1&amp;type=t">t</a> -&gt; int</code></pre>
<pre><span class="VALbin_t"><span class="keyword">val</span> bin_t</span> : <code class="type"><a href="?package=core&amp;module=Date.Stable.V1&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Type_class&amp;type=t">Core_kernel.Std.Bin_prot.Type_class.t</a></code></pre>
<pre><span class="VALbin_read_t"><span class="keyword">val</span> bin_read_t</span> : <code class="type"><a href="?package=core&amp;module=Date.Stable.V1&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Read_ml&amp;type=reader">Core_kernel.Std.Bin_prot.Read_ml.reader</a></code></pre>
<pre><span class="VALbin_read_t_"><span class="keyword">val</span> bin_read_t_</span> : <code class="type"><a href="?package=core&amp;module=Date.Stable.V1&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Unsafe_read_c&amp;type=reader">Core_kernel.Std.Bin_prot.Unsafe_read_c.reader</a></code></pre>
<pre><span class="VALbin_read_t__"><span class="keyword">val</span> bin_read_t__</span> : <code class="type">(int -&gt; <a href="?package=core&amp;module=Date.Stable.V1&amp;type=t">t</a>) <a href="?package=core_kernel&amp;module=Std.Bin_prot.Unsafe_read_c&amp;type=reader">Core_kernel.Std.Bin_prot.Unsafe_read_c.reader</a></code></pre>
<pre><span class="VALbin_reader_t"><span class="keyword">val</span> bin_reader_t</span> : <code class="type"><a href="?package=core&amp;module=Date.Stable.V1&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Type_class&amp;type=reader">Core_kernel.Std.Bin_prot.Type_class.reader</a></code></pre>
<pre><span class="VALbin_size_t"><span class="keyword">val</span> bin_size_t</span> : <code class="type"><a href="?package=core&amp;module=Date.Stable.V1&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Size&amp;type=sizer">Core_kernel.Std.Bin_prot.Size.sizer</a></code></pre>
<pre><span class="VALbin_write_t"><span class="keyword">val</span> bin_write_t</span> : <code class="type"><a href="?package=core&amp;module=Date.Stable.V1&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Write_ml&amp;type=writer">Core_kernel.Std.Bin_prot.Write_ml.writer</a></code></pre>
<pre><span class="VALbin_write_t_"><span class="keyword">val</span> bin_write_t_</span> : <code class="type"><a href="?package=core&amp;module=Date.Stable.V1&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Unsafe_write_c&amp;type=writer">Core_kernel.Std.Bin_prot.Unsafe_write_c.writer</a></code></pre>
<pre><span class="VALbin_writer_t"><span class="keyword">val</span> bin_writer_t</span> : <code class="type"><a href="?package=core&amp;module=Date.Stable.V1&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Type_class&amp;type=writer">Core_kernel.Std.Bin_prot.Type_class.writer</a></code></pre>
<pre><span class="VALt_of_sexp"><span class="keyword">val</span> t_of_sexp</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a> -&gt; <a href="?package=core&amp;module=Date.Stable.V1&amp;type=t">t</a></code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type"><a href="?package=core&amp;module=Date.Stable.V1&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre></div></div></div></div>
<pre><span class="VALt_of_sexp"><span class="keyword">val</span> t_of_sexp</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a> -&gt; <a href="?package=core&amp;module=Date&amp;type=t">t</a></code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre>
<pre><span class="VALbin_t"><span class="keyword">val</span> bin_t</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Type_class&amp;type=t">Core_kernel.Std.Bin_prot.Type_class.t</a></code></pre>
<pre><span class="VALbin_read_t"><span class="keyword">val</span> bin_read_t</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Read_ml&amp;type=reader">Core_kernel.Std.Bin_prot.Read_ml.reader</a></code></pre>
<pre><span class="VALbin_read_t_"><span class="keyword">val</span> bin_read_t_</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Unsafe_read_c&amp;type=reader">Core_kernel.Std.Bin_prot.Unsafe_read_c.reader</a></code></pre>
<pre><span class="VALbin_read_t__"><span class="keyword">val</span> bin_read_t__</span> : <code class="type">(int -&gt; <a href="?package=core&amp;module=Date&amp;type=t">t</a>) <a href="?package=core_kernel&amp;module=Std.Bin_prot.Unsafe_read_c&amp;type=reader">Core_kernel.Std.Bin_prot.Unsafe_read_c.reader</a></code></pre>
<pre><span class="VALbin_reader_t"><span class="keyword">val</span> bin_reader_t</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Type_class&amp;type=reader">Core_kernel.Std.Bin_prot.Type_class.reader</a></code></pre>
<pre><span class="VALbin_size_t"><span class="keyword">val</span> bin_size_t</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Size&amp;type=sizer">Core_kernel.Std.Bin_prot.Size.sizer</a></code></pre>
<pre><span class="VALbin_write_t"><span class="keyword">val</span> bin_write_t</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Write_ml&amp;type=writer">Core_kernel.Std.Bin_prot.Write_ml.writer</a></code></pre>
<pre><span class="VALbin_write_t_"><span class="keyword">val</span> bin_write_t_</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Unsafe_write_c&amp;type=writer">Core_kernel.Std.Bin_prot.Unsafe_write_c.writer</a></code></pre>
<pre><span class="VALbin_writer_t"><span class="keyword">val</span> bin_writer_t</span> : <code class="type"><a href="?package=core&amp;module=Date&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Std.Bin_prot.Type_class&amp;type=writer">Core_kernel.Std.Bin_prot.Type_class.writer</a></code></pre>
<div class="info"><div class="info">converts a string to a date, in formats:
 m/d/y
 y-m-d (* valid iso8601_extended *)
 DD MMM YYYY
 DDMMMYYYY
 YYYYMMDD</div></div>
<div class="info"><div class="info"><code class="code">create_exn ~y ~m ~d</code> creates the date specified in the arguments.  Arguments are
    validated, and are not normalized in any way.  So, days must be within the limits for
    the month in question, numbers cannot be negative, years must be fully specified, etc.</div></div>
<div class="info"><div class="info"><code class="code">add_months t n</code> returns date with max days for the month if the date would be
    invalid. e.g. adding 1 month to Jan 30 results in Feb 28 due to Feb 30 being
    an invalid date, Feb 29 is returned in cases of leap year. *</div></div>
<div class="info"><div class="info"><code class="code">diff t1 t2</code> returns date <code class="code">t1</code> minus date <code class="code">t2</code> in days.</div></div>
<div class="info"><div class="info"><code class="code">add_weekdays t 0</code> returns the next weekday if <code class="code">t</code> is a weekend and <code class="code">t</code> otherwise.
    Unlike add_days this is done by looping over the count of days to be added (forward or
    backwards based on the sign), and is O(n) in the number of days to add.
    Beware, <code class="code">add_weekdays sat 1</code> or <code class="code">add_weekdays sun 1</code> both return the next <code class="code">tue</code>,
    not the next <code class="code">mon</code>. You may want to use <code class="code">following_weekday</code> if you want the next
    following weekday, <code class="code">following_weekday (fri|sat|sun)</code> would all return the next <code class="code">mon</code>.</div></div>
<div class="info"><div class="info"><code class="code">add_business_days t ~is_holiday n</code> returns a business day even when
    <code class="code">n=0</code>. <code class="code">add_business_days ~is_holiday:(fun _ -&gt; false) ...</code> is the same as
    <code class="code">add_weekdays</code>. Use <code class="code">Pnl_db.Calendar_events.is_holiday</code> as a conveninent holiday
    function.</div></div>
<div class="info"><div class="info"><code class="code">first_strictly_after t ~on:day_of_week</code> returns the first occurrence of <code class="code">day_of_week</code>
    strictly after <code class="code">t</code>.</div></div>
</div>