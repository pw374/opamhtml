<div class="ocaml_toplevel_module"><div class="info">Pa_type_conv: Preprocessing Module for Registering Type Conversions</div>
<div class="info"><div class="info"><h6 id="6_TITLE">Generator registration</h6></div></div>
<pre><span class="VALset_conv_path_if_not_set"><span class="keyword">val</span> set_conv_path_if_not_set</span> : <code class="type">Camlp4.PreCast.Ast.Loc.t -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">set_conv_path_if_not_set loc</code> sets the path to the file/module being
    converted for improved error messages.</div></div>
<pre><span class="VALget_conv_path"><span class="keyword">val</span> get_conv_path</span> : <code class="type">unit -&gt; string</code></pre><div class="info"><div class="info"><code class="code">get_conv_path ()</code> <b>Returns</b> the name to module containing a type
    as required for error messages.</div></div>
<pre><span class="VALadd_generator"><span class="keyword">val</span> add_generator</span> : <code class="type">?is_exn:bool -&gt;
string -&gt;
(bool -&gt; Camlp4.PreCast.Ast.ctyp -&gt; Camlp4.PreCast.Ast.str_item) -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">add_generator ?is_exn name gen</code> adds the code generator <code class="code">gen</code>,
    which maps type or exception declarations to structure items, where
    <code class="code">is_exn</code> specifies whether the declaration is an exception.  Note that
    the original type/exception declarations get added automatically in
    any case.<div class="parameters"><div class="param_info"><code class="code">is_exn</code> : = <code class="code">false</code></div></div></div></div>
<pre><span class="VALadd_generator_with_arg"><span class="keyword">val</span> add_generator_with_arg</span> : <code class="type">?is_exn:bool -&gt;
string -&gt;
'a Camlp4.PreCast.Gram.Entry.t -&gt;
('a option -&gt; bool -&gt; Camlp4.PreCast.Ast.ctyp -&gt; Camlp4.PreCast.Ast.str_item) -&gt;
unit</code></pre><div class="info"><div class="info"><code class="code">add_generator_with_arg ?is_exn name entry generator</code> same as
    <code class="code">add_generator</code>, but the generator may accept an argument, which is
    parsed with <code class="code">entry</code>.</div></div>
<pre><span class="VALrm_generator"><span class="keyword">val</span> rm_generator</span> : <code class="type">?is_exn:bool -&gt; string -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">rm_generator ?is_exn name</code> removes the code generator named <code class="code">name</code>
    for types if <code class="code">is_exn</code> is <code class="code">false</code>, or exceptions otherwise.<div class="parameters"><div class="param_info"><code class="code">is_exn</code> : = <code class="code">false</code></div></div></div></div>
<pre><span class="VALadd_sig_generator"><span class="keyword">val</span> add_sig_generator</span> : <code class="type">?delayed:bool -&gt;
?is_exn:bool -&gt;
string -&gt;
(bool -&gt; Camlp4.PreCast.Ast.ctyp -&gt; Camlp4.PreCast.Ast.sig_item) -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">add_sig_generator ?delayed ?is_exn name gen</code> adds the code generator <code class="code">gen</code>,
    which maps type or exception declarations to signature items, where
    <code class="code">is_exn</code> specifies whether the declaration is an exception.  Note that the
    original type/exception declarations get added automatically in any case. If
    <code class="code">delayed</code> is set to true, the output of this generator is appended to the
    signature in which it's defined<div class="parameters"><div class="param_info"><code class="code">delayed</code> : = <code class="code">false</code></div><div class="param_info"><code class="code">is_exn</code> : = <code class="code">false</code></div></div></div></div>
<pre><span class="VALadd_sig_generator_with_arg"><span class="keyword">val</span> add_sig_generator_with_arg</span> : <code class="type">?delayed:bool -&gt;
?is_exn:bool -&gt;
string -&gt;
'a Camlp4.PreCast.Gram.Entry.t -&gt;
('a option -&gt; bool -&gt; Camlp4.PreCast.Ast.ctyp -&gt; Camlp4.PreCast.Ast.sig_item) -&gt;
unit</code></pre><div class="info"><div class="info"><code class="code">add_sig_generator_with_arg ?delayed ?is_exn name entry generator</code> same as
    <code class="code">add_sig_generator</code>, but the generator may accept an argument,
    which is parsed with <code class="code">entry</code>.</div></div>
<pre><span class="VALrm_sig_generator"><span class="keyword">val</span> rm_sig_generator</span> : <code class="type">?is_exn:bool -&gt; string -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">rm_sig_generator ?is_exn name</code> removes the signature code generator named
    <code class="code">name</code> for types if <code class="code">is_exn</code> is <code class="code">false</code>, or exceptions otherwise.<div class="parameters"><div class="param_info"><code class="code">is_exn</code> : = <code class="code">false</code></div></div></div></div>
<pre><span class="TYPErecord_field_generator"><span class="keyword">type</span> record_field_generator</span> = <code class="type">Camlp4.PreCast.Ast.ctyp -&gt; unit</code></pre><div class="info"><div class="info">Type of record field code generators</div></div>
<pre><span class="VALadd_record_field_generator"><span class="keyword">val</span> add_record_field_generator</span> : <code class="type">string -&gt; <a href="?package=type_conv&amp;module=Pa_type_conv&amp;type=record_field_generator">record_field_generator</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">add_record_field_generator gen_name gen</code> adds the record field code
    generator <code class="code">gen</code> with name <code class="code">gen_name</code>, which acts on the location
    identifiying the record field.</div></div>
<pre><span class="VALadd_record_field_generator_with_arg"><span class="keyword">val</span> add_record_field_generator_with_arg</span> : <code class="type">string -&gt;
'a Camlp4.PreCast.Gram.Entry.t -&gt;
('a option -&gt; <a href="?package=type_conv&amp;module=Pa_type_conv&amp;type=record_field_generator">record_field_generator</a>) -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">add_record_field_generator_with_arg name entry generator</code> same as
    <code class="code">add_record_field_generator</code>, but the <code class="code">generator</code> takes an argument,
    which is parsed with <code class="code">entry</code>.  If <code class="code">None</code> is passed to the generator,
    parsing of the argument failed, otherwise <code class="code">Some arg</code> will be passed,
    where <code class="code">arg</code> is the successfully parsed argument.</div></div>
<pre><span class="VALrm_record_field_generator"><span class="keyword">val</span> rm_record_field_generator</span> : <code class="type">string -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">rm_record_field_generator name</code> removes the record field code generator
    named <code class="code">name</code>.</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Generator sets registration</h6></div></div>
<pre><span class="VALadd_sig_set"><span class="keyword">val</span> add_sig_set</span> : <code class="type">?is_exn:bool -&gt; string -&gt; set:string list -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">add_sig_set ?is_exn id ~set</code> adds the generator <code class="code">id</code> to the list
    of generators for signatures.
    This generator will behave as if is all the generators from <code class="code">set</code>
    had been given instead. Any duplicate arising from repeatedly
    expanding such generators are removed.
    If <code class="code">is_exn</code>, then it is a generator for exception declaration, or
    else it is a generator for type declaration.</div></div>
<pre><span class="VALadd_str_set"><span class="keyword">val</span> add_str_set</span> : <code class="type">?is_exn:bool -&gt; string -&gt; set:string list -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">add_str_set ?is_exn id ~set</code> behaves exactly like
    <code class="code">add_sig_set ?is_exn id ~set</code> but for structure items instead of
    signatures items.</div></div>
<pre><span class="VALadd_set"><span class="keyword">val</span> add_set</span> : <code class="type">kind:[ `Both | `Sig | `Str ] -&gt;
is_exn:[ `Both | `No | `Yes ] -&gt; string -&gt; set:string list -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">add_set ~kind ~is_exn id ~set</code> is a shorthand for doing multiple
    calls to <code class="code">add_str_set</code> and <code class="code">add_sig_set</code></div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Utility functions</h6></div></div>
<pre><span class="VALget_loc_err"><span class="keyword">val</span> get_loc_err</span> : <code class="type">Camlp4.PreCast.Ast.Loc.t -&gt; string -&gt; string</code></pre><div class="info"><div class="info"><code class="code">get_loc_err loc msg</code> generates a compile-time error message.</div></div>
<pre><span class="VALhash_variant"><span class="keyword">val</span> hash_variant</span> : <code class="type">string -&gt; int</code></pre><div class="info"><div class="info"><code class="code">hash_variant str</code> <b>Returns</b> the integer encoding a variant tag with
    name <code class="code">str</code>.</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">General purpose code generation module</h6></div></div>
<div class="ocaml_module sig" name="Gen"><pre><span class="keyword">module</span> <a href="?package=type_conv&amp;module=Pa_type_conv.Gen">Gen</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="VALexApp_of_list"><span class="keyword">val</span> exApp_of_list</span> : <code class="type">Camlp4.PreCast.Ast.expr list -&gt; Camlp4.PreCast.Ast.expr</code></pre><div class="info"><div class="info"><code class="code">expr_app_of_list l</code> takes list <code class="code">l</code> of expressions <code class="code">e1; e2; e3; ...</code>
      and returns the expression <code class="code">e1 e2 e3</code>.  C.f.: <code class="code">Ast.exSem_of_list</code>.</div></div>
<pre><span class="VALtyArr_of_list"><span class="keyword">val</span> tyArr_of_list</span> : <code class="type">Camlp4.PreCast.Ast.ctyp list -&gt; Camlp4.PreCast.Ast.ctyp</code></pre><div class="info"><div class="info"><code class="code">tyArr_of_list l</code> takes list <code class="code">l</code> of types <code class="code">e1; e2; e3; ...</code> and
      returns the type <code class="code">e1 e2 e3</code>.  C.f.: <code class="code">Ast.exSem_of_list</code>.</div></div>
<pre><span class="VALpaOr_of_list"><span class="keyword">val</span> paOr_of_list</span> : <code class="type">Camlp4.PreCast.Ast.patt list -&gt; Camlp4.PreCast.Ast.patt</code></pre><div class="info"><div class="info"><code class="code">paOr_of_list l</code> takes list <code class="code">l</code> of patterns <code class="code">p1; p2; p3; ...</code> and returns
      the pattern <code class="code">p1 | p2 | p3 | ...</code></div></div>
<pre><span class="VALgensym"><span class="keyword">val</span> gensym</span> : <code class="type">?prefix:string -&gt; unit -&gt; string</code></pre><div class="info"><div class="info"><code class="code">gensym ?prefix ()</code> generates a fresh variable name with <code class="code">prefix</code>.
      When used with the default parameters, it will return: <code class="code">_x__001</code>,
      <code class="code">_x__002</code>, <code class="code">_x__003</code>, ...<div class="parameters"><div class="param_info"><code class="code">prefix</code> : default = &quot;_x&quot;</div></div></div></div>
<pre><span class="VALerror"><span class="keyword">val</span> error</span> : <code class="type">Camlp4.PreCast.Ast.ctyp -&gt; fn:string -&gt; msg:string -&gt; 'a</code></pre><div class="info"><div class="info"><code class="code">error tp ~fn ~msg</code> raises an error with <code class="code">msg</code> on type <code class="code">tp</code> occuring
      in function <code class="code">fn</code>.</div></div>
<pre><span class="VALunknown_type"><span class="keyword">val</span> unknown_type</span> : <code class="type">Camlp4.PreCast.Ast.ctyp -&gt; string -&gt; 'a</code></pre><div class="info"><div class="info"><code class="code">unknown_type tp fn</code> type <code class="code">tp</code> cannot be handled by function <code class="code">fn</code>.</div></div>
<pre><span class="VALty_var_list_of_ctyp"><span class="keyword">val</span> ty_var_list_of_ctyp</span> : <code class="type">Camlp4.PreCast.Ast.ctyp -&gt; string list -&gt; string list</code></pre><div class="info"><div class="info"><code class="code">ty_var_list_of_ctyp tp acc</code> accumulates a list of type parameters
      contained in <code class="code">tp</code> into <code class="code">acc</code> as strings.</div></div>
<pre><span class="VALget_rev_id_path"><span class="keyword">val</span> get_rev_id_path</span> : <code class="type">Camlp4.PreCast.Ast.ident -&gt; string list -&gt; string list</code></pre><div class="info"><div class="info"><code class="code">get_rev_id_path id acc</code> takes an identifier. <b>Returns</b> a reversed
      module path (list of strings) denoting this identifier, appending
      it to <code class="code">acc</code>.</div></div>
<pre><span class="VALident_of_rev_path"><span class="keyword">val</span> ident_of_rev_path</span> : <code class="type">Camlp4.PreCast.Ast.Loc.t -&gt; string list -&gt; Camlp4.PreCast.Ast.ident</code></pre><div class="info"><div class="info"><code class="code">ident_of_rev_path loc path</code> takes a location <code class="code">loc</code> and a reversed path
      <code class="code">rev_path</code> to an identifier. <b>Returns</b> identifier denoting the
      bound value.</div></div>
<pre><span class="VALget_appl_path"><span class="keyword">val</span> get_appl_path</span> : <code class="type">Camlp4.PreCast.Ast.Loc.t -&gt;
Camlp4.PreCast.Ast.ctyp -&gt; Camlp4.PreCast.Ast.ident</code></pre><div class="info"><div class="info"><code class="code">get_appl_path loc tp</code> <b>Returns</b> the identifier path associated with
      a polymorphic type.</div></div>
<pre><span class="VALabstract"><span class="keyword">val</span> abstract</span> : <code class="type">Camlp4.PreCast.Ast.Loc.t -&gt;
Camlp4.PreCast.Ast.patt list -&gt;
Camlp4.PreCast.Ast.expr -&gt; Camlp4.PreCast.Ast.expr</code></pre><div class="info"><div class="info"><code class="code">abstract loc patts body</code> takes a location <code class="code">loc</code>, a pattern list
      <code class="code">patts</code>, and an expression <code class="code">body</code>. <b>Returns</b> a function expression
      that takes the patterns as arguments, and binds them in <code class="code">body</code>.</div></div>
<pre><span class="VALapply"><span class="keyword">val</span> apply</span> : <code class="type">Camlp4.PreCast.Ast.Loc.t -&gt;
Camlp4.PreCast.Ast.expr -&gt;
Camlp4.PreCast.Ast.expr list -&gt; Camlp4.PreCast.Ast.expr</code></pre><div class="info"><div class="info"><code class="code">apply loc f_expr arg_exprs</code> takes a location <code class="code">loc</code>, an expression
      <code class="code">f_expr</code> representing a function, and a list of argument expressions
      <code class="code">arg_exprs</code>. <b>Returns</b> an expression in which the function is
      applied to its arguments.</div></div>
<pre><span class="VALswitch_tp_def"><span class="keyword">val</span> switch_tp_def</span> : <code class="type">alias:(Camlp4.PreCast.Ast.Loc.t -&gt; Camlp4.PreCast.Ast.ctyp -&gt; 'a) -&gt;
sum:(Camlp4.PreCast.Ast.Loc.t -&gt; Camlp4.PreCast.Ast.ctyp -&gt; 'a) -&gt;
record:(Camlp4.PreCast.Ast.Loc.t -&gt; Camlp4.PreCast.Ast.ctyp -&gt; 'a) -&gt;
variants:(Camlp4.PreCast.Ast.Loc.t -&gt; Camlp4.PreCast.Ast.ctyp -&gt; 'a) -&gt;
mani:(Camlp4.PreCast.Ast.Loc.t -&gt;
      Camlp4.PreCast.Ast.ctyp -&gt; Camlp4.PreCast.Ast.ctyp -&gt; 'a) -&gt;
nil:(Camlp4.PreCast.Ast.Loc.t -&gt; 'a) -&gt; Camlp4.PreCast.Ast.ctyp -&gt; 'a</code></pre><div class="info"><div class="info"><code class="code">switch_tp_def ~alias ~sum ~record ~variants ~mani tp_def</code>
      takes a handler function for each kind of type definition and
      applies the appropriate handler when <code class="code">tp_def</code> matches.</div></div>
<pre><span class="VALmk_expr_lst"><span class="keyword">val</span> mk_expr_lst</span> : <code class="type">Camlp4.PreCast.Ast.Loc.t -&gt;
Camlp4.PreCast.Ast.expr list -&gt; Camlp4.PreCast.Ast.expr</code></pre><div class="info"><div class="info"><code class="code">mk_expr_lst loc expr_list</code> takes a list of expressions. <b>Returns</b> an expression representing a list of expressions.</div></div>
<pre><span class="VALmk_patt_lst"><span class="keyword">val</span> mk_patt_lst</span> : <code class="type">Camlp4.PreCast.Ast.Loc.t -&gt;
Camlp4.PreCast.Ast.patt list -&gt; Camlp4.PreCast.Ast.patt</code></pre><div class="info"><div class="info"><code class="code">mk_patt_lst _loc patt_list</code> takes a list of patterns. <b>Returns</b> a pattern representing a list of patterns.</div></div>
<pre><span class="VALget_tparam_id"><span class="keyword">val</span> get_tparam_id</span> : <code class="type">Camlp4.PreCast.Ast.ctyp -&gt; string</code></pre><div class="info"><div class="info"><code class="code">get_tparam_id tp</code> <b>Raises</b> <code>Failure</code> otherwise.<br/> <b>Returns</b> the string identifier associated with
      <code class="code">tp</code> if it is a type parameter.</div></div>
<pre><span class="VALtype_is_recursive"><span class="keyword">val</span> type_is_recursive</span> : <code class="type">?stop_on_functions:bool -&gt;
?short_circuit:(Camlp4.PreCast.Ast.ctyp -&gt; bool option) -&gt;
string -&gt; Camlp4.PreCast.Ast.ctyp -&gt; bool</code></pre><div class="info"><div class="info"><code class="code">type_is_recursive ?short_circuit id tp</code><div class="parameters"><div class="param_info"><code class="code">short_circuit</code> : allows you to override the search for certain
      type expressions.</div><div class="param_info"><code class="code">stop_on_functions</code> : allows to disregard the recursive occurences appearing in
      arrow types. The default is to disregard them.</div></div> <b>Returns</b> whether the type <code class="code">tp</code> with name <code class="code">id</code>
      refers to itself, assuming that it is not mutually recursive with
      another type.</div></div>
<pre><span class="VALdrop_variance_annotations"><span class="keyword">val</span> drop_variance_annotations</span> : <code class="type">Camlp4.PreCast.Ast.ctyp -&gt; Camlp4.PreCast.Ast.ctyp</code></pre><div class="info"><div class="info"><code class="code">drop_variance_annotations tp</code> <b>Returns</b> the type resulting from dropping
      all variance annotations in <code class="code">tp</code>.</div></div>
<pre><span class="VALfind_record_default"><span class="keyword">val</span> find_record_default</span> : <code class="type">Camlp4.PreCast.Ast.Loc.t -&gt; Camlp4.PreCast.Ast.expr option</code></pre><div class="info"><div class="info"><code class="code">find_record_default loc</code> <b>Returns</b> the optional default expression
      associated with the record field at source location <code class="code">loc</code> if defined.</div></div>
<pre><span class="VALdelay_sig_item"><span class="keyword">val</span> delay_sig_item</span> : <code class="type">Camlp4.PreCast.Ast.sig_item -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">delay_sig_item item</code> places <code class="code">item</code> at the end of the current signature</div></div></div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Utility functions to rewrite type definitions</h6></div></div>
<div class="ocaml_module sig" name="Rewrite_tds"><pre><span class="keyword">module</span> <a href="?package=type_conv&amp;module=Pa_type_conv.Rewrite_tds">Rewrite_tds</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="VALsig_"><span class="keyword">val</span> sig_</span> : <code class="type">Camlp4.PreCast.Ast.Loc.t -&gt;
bool -&gt; Camlp4.PreCast.Ast.ctyp -&gt; Camlp4.PreCast.Ast.sig_item</code></pre><div class="info"><div class="info"><code class="code">sig_ loc rec_ typedefs</code> rewrites the given type definition to make it either
      recursive or non recursive.
      For instance, the parser calls <code class="code">sig_ loc false (TyDcl (_, t, [], t, []))</code> when it
      encouters <code class="code">type t = t</code> and calls <code class="code">sig_ loc true (TyDcl (_, t, [], t, []))</code> when it
      encouters <code class="code">type nonrec t = t</code> in signatures.</div></div>
<pre><span class="VALstr_"><span class="keyword">val</span> str_</span> : <code class="type">Camlp4.PreCast.Ast.Loc.t -&gt;
bool -&gt; Camlp4.PreCast.Ast.ctyp -&gt; Camlp4.PreCast.Ast.str_item</code></pre><div class="info"><div class="info"><code class="code">str_ loc rec_ typedefs</code> does the same thing as <code class="code">sig_ loc rec_ typedefs</code>, except
      that it returns a structure item instead of a signature item.</div></div></div></div>
</div>