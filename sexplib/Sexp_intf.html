<div class="ocaml_toplevel_module"><div class="info">Sexp_intf: interface specification for handling S-expressions (I/O, etc.)</div>
<div class="ocaml_module sig" name="S"><pre><span class="keyword">module type</span> <a href="?package=sexplib&amp;module=Sexp_intf.S">S</a> = <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEt"><span class="keyword">type</span> t</span> = <code class="type"><a href="?package=sexplib&amp;module=Type&amp;type=t">Type.t</a></code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.Atom"><span class="constructor">Atom</span></span> <span class="keyword">of</span> <code class="type">string</code></code></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.List"><span class="constructor">List</span></span> <span class="keyword">of</span> <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> list</code></code></td></tr></table><div class="info"><div class="info">Type of S-expressions</div><div class="info">Type of bigstrings</div></div>
<pre><span class="TYPEbigstring"><span class="keyword">type</span> bigstring</span> = <code class="type">(char, <a href="?package=ocaml&amp;module=Bigarray&amp;type=int8_unsigned_elt">Bigarray.int8_unsigned_elt</a>, <a href="?package=ocaml&amp;module=Bigarray&amp;type=c_layout">Bigarray.c_layout</a>) <a href="?package=ocaml&amp;module=Bigarray.Array1&amp;type=t">Bigarray.Array1.t</a></code></pre>
<div class="info"><div class="info"><h6 id="6_TITLE">Defaults</h6></div></div>
<pre><span class="VALdefault_indent"><span class="keyword">val</span> default_indent</span> : <code class="type">int <a href="?package=ocaml&amp;module=Pervasives&amp;type=ref">Pervasives.ref</a></code></pre><div class="info"><div class="info"><code class="code">default_indent</code> reference to default indentation level for
      human-readable conversions.  Initialisation value: 2.</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">S-expression size</h6></div></div>
<pre><span class="VALsize"><span class="keyword">val</span> size</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; int * int</code></pre><div class="info"><div class="info"><code class="code">size sexp</code> <b>Returns</b> <code class="code">(n_atoms, n_chars)</code>, where <code class="code">n_atoms</code> is
      the number of atoms in S-expression <code class="code">sexp</code>, and <code class="code">n_chars</code> is the
      number of characters in the atoms of the S-expression.</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Scan functions</h6></div></div>
<pre><span class="VALscan_sexp"><span class="keyword">val</span> scan_sexp</span> : <code class="type">?buf:<a href="?package=ocaml&amp;module=Buffer&amp;type=t">Buffer.t</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">scan_sexp ?buf lexbuf</code> scans an S-expression from lex buffer
      <code class="code">lexbuf</code> using the optional string buffer <code class="code">buf</code> for storing
      intermediate strings.</div></div>
<pre><span class="VALscan_sexps"><span class="keyword">val</span> scan_sexps</span> : <code class="type">?buf:<a href="?package=ocaml&amp;module=Buffer&amp;type=t">Buffer.t</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> list</code></pre><div class="info"><div class="info"><code class="code">scan_sexps ?buf lexbuf</code> reads a list of whitespace separated
      S-expressions from lex buffer <code class="code">lexbuf</code> using the optional string
      buffer <code class="code">buf</code> for storing intermediate strings.</div></div>
<pre><span class="VALscan_rev_sexps"><span class="keyword">val</span> scan_rev_sexps</span> : <code class="type">?buf:<a href="?package=ocaml&amp;module=Buffer&amp;type=t">Buffer.t</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> list</code></pre><div class="info"><div class="info"><code class="code">scan_rev_sexps ?buf lexbuf</code> same as  <a href="#scan_sexps">scan_sexps</a>, but returns the
      reversed list and is slightly more efficient.</div></div>
<pre><span class="VALscan_sexp_opt"><span class="keyword">val</span> scan_sexp_opt</span> : <code class="type">?buf:<a href="?package=ocaml&amp;module=Buffer&amp;type=t">Buffer.t</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> option</code></pre><div class="info"><div class="info"><code class="code">scan_sexp_opt ?buf lexbuf</code> is equivalent to <code class="code">scan_sexp ?buf lexbuf</code>
      except that it returns <code class="code">None</code> when the eof is reached.</div></div>
<pre><span class="VALscan_iter_sexps"><span class="keyword">val</span> scan_iter_sexps</span> : <code class="type">?buf:<a href="?package=ocaml&amp;module=Buffer&amp;type=t">Buffer.t</a> -&gt; f:(<a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; unit) -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">scan_iter_sexps ?buf ~f lexbuf</code> iterates over all whitespace
      separated S-expressions scanned from lex buffer <code class="code">lexbuf</code> using
      function <code class="code">f</code>, and the optional string buffer <code class="code">buf</code> for storing
      intermediate strings.</div></div>
<pre><span class="VALscan_fold_sexps"><span class="keyword">val</span> scan_fold_sexps</span> : <code class="type">?buf:<a href="?package=ocaml&amp;module=Buffer&amp;type=t">Buffer.t</a> -&gt; f:('a -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; 'a) -&gt; init:'a -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a</code></pre><div class="info"><div class="info"><code class="code">scan_fold_sexps ?buf ~f ~init lexbuf</code> folds over all whitespace
      separated S-expressions scanned from lex buffer <code class="code">lexbuf</code> using
      function <code class="code">f</code>, initial state <code class="code">init</code>, and the optional string buffer
      <code class="code">buf</code> for storing intermediate strings.</div></div>
<pre><span class="VALscan_sexps_conv"><span class="keyword">val</span> scan_sexps_conv</span> : <code class="type">?buf:<a href="?package=ocaml&amp;module=Buffer&amp;type=t">Buffer.t</a> -&gt; f:(<a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; 'a) -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a list</code></pre><div class="info"><div class="info"><code class="code">scan_sexps_conv ?buf ~f lexbuf</code> maps all whitespace separated
      S-expressions scanned from lex buffer <code class="code">lexbuf</code> to some list using
      function <code class="code">f</code>, and the optional string buffer <code class="code">buf</code> for storing
      intermediate strings.</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Type and exception definitions for (partial) parsing</h6></div></div>
<div class="ocaml_module sig" name="Parse_pos"><pre><span class="keyword">module</span> <a href="?package=sexplib&amp;module=Sexp_intf.S.Parse_pos">Parse_pos</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEt"><span class="keyword">type</span> t</span> = {<code class="type"><a href="?package=sexplib&amp;module=Pre_sexp.Parse_pos&amp;type=t">Pre_sexp.Parse_pos.t</a></code>}<span class="keyword">private</span></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTt.text_line">text_line</span> : <code class="type">int</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">Line position in parsed text</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTt.text_char">text_char</span> : <code class="type">int</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">Character position in parsed text</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTt.global_offset">global_offset</span> : <code class="type">int</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">Global/logical offset</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTt.buf_pos">buf_pos</span> : <code class="type">int</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">Read position in string buffer</div></td></tr><tr><td>}</td></tr></table><div class="info"><div class="info">Position information after complete parse</div></div>
<pre><span class="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">?text_line:int -&gt;
?text_char:int -&gt; ?buf_pos:int -&gt; ?global_offset:int -&gt; unit -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.Parse_pos&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">create ?text_line ?text_char ?buf_pos ?global_offset ()</code><div class="parameters"><div class="param_info"><code class="code">text_line</code> : default = <code class="code">1</code></div><div class="param_info"><code class="code">text_char</code> : default = <code class="code">0</code></div><div class="param_info"><code class="code">global_offset</code> : default = <code class="code">0</code></div><div class="param_info"><code class="code">buf_pos</code> : default = <code class="code">0</code></div></div> <b>Returns</b> a parse position with the given parameters.</div></div>
<pre><span class="VALwith_buf_pos"><span class="keyword">val</span> with_buf_pos</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.Parse_pos&amp;type=t">t</a> -&gt; int -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.Parse_pos&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">with_buf_pos t pos</code> <b>Returns</b> a copy of the parse position <code class="code">t</code> where
        <code class="code">buf_pos</code> is set to <code class="code">pos</code>.</div></div></div></div>
<div class="ocaml_module sig" name="Cont_state"><pre><span class="keyword">module</span> <a href="?package=sexplib&amp;module=Sexp_intf.S.Cont_state">Cont_state</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEt"><span class="keyword">type</span> t</span> = <code class="type"><a href="?package=sexplib&amp;module=Pre_sexp.Cont_state&amp;type=t">Pre_sexp.Cont_state.t</a></code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.Parsing_whitespace"><span class="constructor">Parsing_whitespace</span></span></code></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.Parsing_atom"><span class="constructor">Parsing_atom</span></span></code></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.Parsing_list"><span class="constructor">Parsing_list</span></span></code></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.Parsing_sexp_comment"><span class="constructor">Parsing_sexp_comment</span></span></code></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.Parsing_block_comment"><span class="constructor">Parsing_block_comment</span></span></code></td></tr></table><div class="info"><div class="info">State of parser continuations</div></div>
<pre><span class="VALto_string"><span class="keyword">val</span> to_string</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.Cont_state&amp;type=t">t</a> -&gt; string</code></pre><div class="info"><div class="info"><code class="code">to_string cont_state</code> converts state of parser continuation
        <code class="code">cont_state</code> to a string.</div></div></div></div>
<pre><span class="TYPEparse_result"><span class="keyword">type</span> <code class="type">('a, 't) </code>parse_result</span> = <code class="type">('a, 't) <a href="?package=sexplib&amp;module=Pre_sexp&amp;type=parse_result">Pre_sexp.parse_result</a></code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTparse_result.Done"><span class="constructor">Done</span></span> <span class="keyword">of</span> <code class="type">'t * <a href="?package=sexplib&amp;module=Sexp_intf.S.Parse_pos&amp;type=t">Parse_pos.t</a></code></code></td><td class="typefieldcomment" align="left"><div class="info"><code class="code">Done (t, parse_pos)</code> finished parsing
                                    an S-expression.  Current parse position
                                    is <code class="code">parse_pos</code>.</div></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTparse_result.Cont"><span class="constructor">Cont</span></span> <span class="keyword">of</span> <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.Cont_state&amp;type=t">Cont_state.t</a> * ('a, 't) parse_fun</code></code></td><td class="typefieldcomment" align="left"><div class="info"><code class="code">Cont (cont_state, parse_fun)</code> met the end of input before completely
          parsing an S-expression.  The user has to call <code class="code">parse_fun</code> to
          continue parsing the S-expression in another buffer.  <code class="code">cont_state</code>
          is the current parsing state of the continuation.
          NOTE: the continuation may only be called once and will raise
          <code class="code">Failure</code> otherwise!</div></td></tr></table><div class="info"><div class="info">Type of result from calling  <a href="#Sexp.parse">Sexp.parse</a>.</div></div>
<pre><span class="TYPEparse_fun"><span class="keyword">type</span> <code class="type">('a, 't) </code>parse_fun</span> = <code class="type">pos:int -&gt; len:int -&gt; 'a -&gt; ('a, 't) <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=parse_result">parse_result</a></code></pre><div class="info"><div class="info">Type of parsing functions with given offsets and lengths.</div></div>
<div class="ocaml_module sig" name="Annotated"><pre><span class="keyword">module</span> <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated">Annotated</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="info"><div class="info">Module for parsing S-expressions annotated with location information</div></div><div class="ocaml_module_content">
<pre><span class="TYPEpos"><span class="keyword">type</span> pos</span> = {<code class="type"><a href="?package=sexplib&amp;module=Pre_sexp.Annotated&amp;type=pos">Pre_sexp.Annotated.pos</a></code>}</pre><table class="typetable">
		    <tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTpos.line">line</span> : <code class="type">int</code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTpos.col">col</span> : <code class="type">int</code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTpos.offset">offset</span> : <code class="type">int</code>;</code></td></tr><tr><td>}</td></tr></table><div class="info"><div class="info">Position information for annotated S-expressions</div></div>
<pre><span class="TYPErange"><span class="keyword">type</span> range</span> = {<code class="type"><a href="?package=sexplib&amp;module=Pre_sexp.Annotated&amp;type=range">Pre_sexp.Annotated.range</a></code>}</pre><table class="typetable">
		    <tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTrange.start_pos">start_pos</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=pos">pos</a></code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTrange.end_pos">end_pos</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=pos">pos</a></code>;</code></td></tr><tr><td>}</td></tr></table><div class="info"><div class="info">Range information for annotated S-expressions</div></div>
<pre><span class="TYPEt"><span class="keyword">type</span> t</span> = <code class="type"><a href="?package=sexplib&amp;module=Pre_sexp.Annotated&amp;type=t">Pre_sexp.Annotated.t</a></code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.Atom"><span class="constructor">Atom</span></span> <span class="keyword">of</span> <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=range">range</a> * <a href="?package=sexplib&amp;module=Type&amp;type=t">Type.t</a></code></code></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.List"><span class="constructor">List</span></span> <span class="keyword">of</span> <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=range">range</a> * <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=t">t</a> list * <a href="?package=sexplib&amp;module=Type&amp;type=t">Type.t</a></code></code></td></tr></table><div class="info"><div class="info">S-expression annotated with location information</div><div class="info">Type of conversion results of annotated S-expressions.</div></div>
<pre><span class="TYPEconv"><span class="keyword">type</span> <code class="type">'a </code>conv</span> = <code class="type">[ `Error of exn * <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=t">t</a> | `Result of 'a ]</code></pre>
<pre><span class="EXCEPTIONConv_exn"><span class="keyword">exception</span> Conv_exn</span> <span class="keyword">of</span> <code class="type">string * exn</code></pre><div class="info"><div class="info">Exception associated with conversion errors.  First argument describes
        the location, the second the reason.</div></div>
<pre><span class="TYPEstack"><span class="keyword">type</span> stack</span> = {<code class="type"><a href="?package=sexplib&amp;module=Pre_sexp.Annotated&amp;type=stack">Pre_sexp.Annotated.stack</a></code>}</pre><table class="typetable">
		    <tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTstack.positions">positions</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=pos">pos</a> list</code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTstack.stack">stack</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=t">t</a> list list</code>;</code></td></tr><tr><td>}</td></tr></table><div class="info"><div class="info">Stack used by annotation parsers</div></div>
<pre><span class="VALget_sexp"><span class="keyword">val</span> get_sexp</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Type&amp;type=t">Type.t</a></code></pre><div class="info"><div class="info"><code class="code">get_sexp annot_sexp</code> <b>Returns</b> S-expression associated with annotated
        S-expression <code class="code">annot_sexp</code>.</div></div>
<pre><span class="VALget_range"><span class="keyword">val</span> get_range</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=range">range</a></code></pre><div class="info"><div class="info"><code class="code">get_range annot_sexp</code> <b>Returns</b> the range associated with annotated
        S-expression <code class="code">annot_sexp</code>.</div></div>
<pre><span class="VALfind_sexp"><span class="keyword">val</span> find_sexp</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Type&amp;type=t">Type.t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=t">t</a> option</code></pre><div class="info"><div class="info"><code class="code">find_sexp annot_sexp sexp</code> <b>Returns</b> <code class="code">Some res</code> where <code class="code">res</code> is the
        annotated S-expression that is physically equivalent to <code class="code">sexp</code> in
        <code class="code">annot_sexp</code>, or <code class="code">None</code> if there is no such S-expression.</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Annotated (partial) parsing</h6></div></div>
<pre><span class="VALparse"><span class="keyword">val</span> parse</span> : <code class="type">?parse_pos:<a href="?package=sexplib&amp;module=Sexp_intf.S.Parse_pos&amp;type=t">Parse_pos.t</a> -&gt; ?len:int -&gt; string -&gt; (string, <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=t">t</a>) <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=parse_result">parse_result</a></code></pre><div class="info"><div class="info"><code class="code">parse ?parse_pos ?len str</code> same as  <a href="#parse">parse</a>, but returns an
        S-expression annotated with location information.</div></div>
<pre><span class="VALparse_bigstring"><span class="keyword">val</span> parse_bigstring</span> : <code class="type">?parse_pos:<a href="?package=sexplib&amp;module=Sexp_intf.S.Parse_pos&amp;type=t">Parse_pos.t</a> -&gt;
?len:int -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=bigstring">bigstring</a> -&gt; (<a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=bigstring">bigstring</a>, <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=t">t</a>) <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=parse_result">parse_result</a></code></pre><div class="info"><div class="info"><code class="code">parse_bigstring ?parse_pos ?len str</code> same as  <a href="#parse_bigstring">parse_bigstring</a>,
        but returns an S-expression annotated with location information.</div></div>
<pre><span class="VALinput_sexp"><span class="keyword">val</span> input_sexp</span> : <code class="type">?parse_pos:<a href="?package=sexplib&amp;module=Sexp_intf.S.Parse_pos&amp;type=t">Parse_pos.t</a> -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=in_channel">Pervasives.in_channel</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">input_sexp ?parse_pos ic</code> like  <a href="#input_sexp">input_sexp</a>, but returns an
        annotated S-expression instead.</div></div>
<pre><span class="VALinput_sexps"><span class="keyword">val</span> input_sexps</span> : <code class="type">?parse_pos:<a href="?package=sexplib&amp;module=Sexp_intf.S.Parse_pos&amp;type=t">Parse_pos.t</a> -&gt; ?buf:string -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=in_channel">Pervasives.in_channel</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=t">t</a> list</code></pre><div class="info"><div class="info"><code class="code">input_sexps ?parse_pos ?buf ic</code> like  <a href="#input_sexps">input_sexps</a>, but returns
        a list of annotated S-expressions.</div></div>
<pre><span class="VALinput_rev_sexps"><span class="keyword">val</span> input_rev_sexps</span> : <code class="type">?parse_pos:<a href="?package=sexplib&amp;module=Sexp_intf.S.Parse_pos&amp;type=t">Parse_pos.t</a> -&gt; ?buf:string -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=in_channel">Pervasives.in_channel</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=t">t</a> list</code></pre><div class="info"><div class="info"><code class="code">input_sexps ?parse_pos ?buf ic</code> like  <a href="#input_rev_sexps">input_rev_sexps</a>, but
        returns a list of annotated S-expressions.</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Loading of annotated S-expressions</h6></div></div>
<div class="info"><div class="info">NOTE: these functions should only be used if an annotated S-expression
        is required.</div></div>
<pre><span class="VALload_sexp"><span class="keyword">val</span> load_sexp</span> : <code class="type">?strict:bool -&gt; ?buf:string -&gt; string -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">load_sexp ?strict ?buf file</code> like  <a href="#load_sexp">load_sexp</a>, but returns an
        annotated S-expression.</div></div>
<pre><span class="VALload_sexps"><span class="keyword">val</span> load_sexps</span> : <code class="type">?buf:string -&gt; string -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=t">t</a> list</code></pre><div class="info"><div class="info"><code class="code">load_sexps ?buf file</code> like  <a href="#load_sexps">load_sexps</a>, but returns a list of
        annotated S-expressions.</div></div>
<pre><span class="VALload_rev_sexps"><span class="keyword">val</span> load_rev_sexps</span> : <code class="type">?buf:string -&gt; string -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=t">t</a> list</code></pre><div class="info"><div class="info"><code class="code">load_rev_sexps ?buf file</code> like  <a href="#load_rev_sexps">load_rev_sexps</a>, but returns a
        list of annotated S-expressions.</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">String and bigstring conversions</h6></div></div>
<pre><span class="VALof_string"><span class="keyword">val</span> of_string</span> : <code class="type">string -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">of_string str</code> same as  <a href="#of_string">of_string</a>, but returns an annotated
        S-expression.</div></div>
<pre><span class="VALof_bigstring"><span class="keyword">val</span> of_bigstring</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=bigstring">bigstring</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">of_bigstring bstr</code> same as  <a href="#of_string">of_string</a>, but operates on bigstrings.</div></div>
<div class="info"><div class="info">Converters using annotations for determining error locations</div></div>
<pre><span class="VALconv"><span class="keyword">val</span> conv</span> : <code class="type">(<a href="?package=sexplib&amp;module=Type&amp;type=t">Type.t</a> -&gt; 'a) -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=t">t</a> -&gt; 'a <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=conv">conv</a></code></pre><div class="info"><div class="info"><code class="code">conv f annot_sexp</code> converts the S-expression associated with
        annotated S-expression <code class="code">annot_sexp</code> using <code class="code">f</code>. <b>Returns</b> <code class="code">`Result
        res</code> on success, or <code class="code">`Error (exn, sub_annot_sexp)</code> otherwise, where
        <code class="code">exn</code> is the exception associated with the conversion error, and
        <code class="code">sub_annot_sexp</code> is the annotated S-expression on which conversion
        failed.</div></div>
<pre><span class="VALget_conv_exn"><span class="keyword">val</span> get_conv_exn</span> : <code class="type">file:string -&gt; exc:exn -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=t">t</a> -&gt; exn</code></pre><div class="info"><div class="info"><code class="code">get_conv_exn ~file ~exc annot_sexp</code> <b>Returns</b> the exception that
        would be raised for a given <code class="code">file</code> and exception <code class="code">exc</code>
        if conversion had failed on annotated S-expression <code class="code">annot_sexp</code>.
        The format of the exception message is &quot;file:line:col&quot;</div></div></div></div>
<pre><span class="TYPEparse_state"><span class="keyword">type</span> <code class="type">'t </code>parse_state</span> = {<code class="type">'t <a href="?package=sexplib&amp;module=Pre_sexp&amp;type=parse_state">Pre_sexp.parse_state</a></code>}<span class="keyword">private</span></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTparse_state.parse_pos">parse_pos</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.Parse_pos&amp;type=t">Parse_pos.t</a></code>;</code></td><td class="typefieldcomment" align="left"><div class="info">Current parse position</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTparse_state.pstack">pstack</span> : <code class="type">'t</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">Stack of found S-expression lists</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTparse_state.pbuf">pbuf</span> : <code class="type"><a href="?package=ocaml&amp;module=Buffer&amp;type=t">Buffer.t</a></code>;</code></td><td class="typefieldcomment" align="left"><div class="info">Current atom buffer</div></td></tr><tr><td>}</td></tr></table><div class="info"><div class="info">Type of state maintained during parsing</div></div>
<pre><span class="TYPEparse_error"><span class="keyword">type</span> parse_error</span> = {<code class="type"><a href="?package=sexplib&amp;module=Pre_sexp&amp;type=parse_error">Pre_sexp.parse_error</a></code>}</pre><table class="typetable">
		    <tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTparse_error.location">location</span> : <code class="type">string</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">Function in which the parse failed</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTparse_error.err_msg">err_msg</span> : <code class="type">string</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">Reason why parsing failed</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTparse_error.parse_state">parse_state</span> : <code class="type">[ `Annot of <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=stack">Annotated.stack</a> <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=parse_state">parse_state</a> | `Sexp of <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> list list <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=parse_state">parse_state</a> ]</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">State of parser</div></td></tr><tr><td>}</td></tr></table><div class="info"><div class="info">Type of parse errors</div></div>
<pre><span class="EXCEPTIONParse_error"><span class="keyword">exception</span> Parse_error</span> <span class="keyword">of</span> <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=parse_error">parse_error</a></code></pre><div class="info"><div class="info">Exception raised during partial parsing</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Unannotated (partial) parsing</h6></div></div>
<pre><span class="VALparse"><span class="keyword">val</span> parse</span> : <code class="type">?parse_pos:<a href="?package=sexplib&amp;module=Sexp_intf.S.Parse_pos&amp;type=t">Parse_pos.t</a> -&gt; ?len:int -&gt; string -&gt; (string, <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a>) <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=parse_result">parse_result</a></code></pre><div class="info"><div class="info"><code class="code">parse ?parse_pos ?len str</code> (partially) parses an S-expression in string buffer
      <code class="code">str</code> starting out with position information provided in <code class="code">parse_pos</code> and reading at
      most <code class="code">len</code> characters.  To parse a single atom that is not delimited by whitespace
      it is necessary to call this function a second time with the returned continuation,
      and a dummy buffer that contains whitespace.<br/>      <code class="code">parse</code> starts parsing <code class="code">str</code> at position <code class="code">parse_pos.buf_pos</code>.  Each subsequent
      <code class="code">parse_fun</code> from a <code class="code">Cont</code> uses the <code class="code">buf</code> and <code class="code">pos</code> that is supplied to it.  The
      final <code class="code">parse_fun</code> that returns <code class="code">Done</code> mutates the <code class="code">buf_pos</code> in the originally
      supplied <code class="code">parse_pos</code>, and then returns it.<div class="parameters"><div class="param_info"><code class="code">parse_pos</code> : default = <code class="code">Parse_pos.create ()</code></div><div class="param_info"><code class="code">len</code> : default = <code class="code">String.length str - parse_pos.Parse_pos.buf_pos</code></div></div></div></div>
<pre><span class="VALparse_bigstring"><span class="keyword">val</span> parse_bigstring</span> : <code class="type">?parse_pos:<a href="?package=sexplib&amp;module=Sexp_intf.S.Parse_pos&amp;type=t">Parse_pos.t</a> -&gt;
?len:int -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=bigstring">bigstring</a> -&gt; (<a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=bigstring">bigstring</a>, <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a>) <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=parse_result">parse_result</a></code></pre><div class="info"><div class="info"><code class="code">parse_bigstring ?parse_pos ?len str</code> same as  <a href="#parse">parse</a>, but operates on
      bigstrings.</div></div>
<pre><span class="VALinput_sexp"><span class="keyword">val</span> input_sexp</span> : <code class="type">?parse_pos:<a href="?package=sexplib&amp;module=Sexp_intf.S.Parse_pos&amp;type=t">Parse_pos.t</a> -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=in_channel">Pervasives.in_channel</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">input_sexp ?parse_pos ic</code> parses an S-expression from input channel
      <code class="code">ic</code> using initial position information in <code class="code">parse_pos</code>.  NOTE: this
      function is not as fast on files as  <a href="#Sexp.load_sexp">Sexp.load_sexp</a>, and is also
      slightly slower than the scan-functions.  But it is guaranteed that
      <code class="code">input_sexp</code> is only going to read data parseable as an S-expression.
      Thus, subsequent input functions will see the data immediately
      following it.<div class="parameters"><div class="param_info"><code class="code">parse_pos</code> : default = <code class="code">Parse_pos.create ()</code></div></div></div></div>
<pre><span class="VALinput_sexps"><span class="keyword">val</span> input_sexps</span> : <code class="type">?parse_pos:<a href="?package=sexplib&amp;module=Sexp_intf.S.Parse_pos&amp;type=t">Parse_pos.t</a> -&gt; ?buf:string -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=in_channel">Pervasives.in_channel</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> list</code></pre><div class="info"><div class="info"><code class="code">input_sexps ?parse_pos ?buf ic</code> parses whitespace separated
      S-expressions from input channel <code class="code">ic</code> until EOF is reached.  Faster than
      the scan-functions.<div class="parameters"><div class="param_info"><code class="code">parse_pos</code> : default = <code class="code">Parse_pos.create ()</code></div></div></div></div>
<pre><span class="VALinput_rev_sexps"><span class="keyword">val</span> input_rev_sexps</span> : <code class="type">?parse_pos:<a href="?package=sexplib&amp;module=Sexp_intf.S.Parse_pos&amp;type=t">Parse_pos.t</a> -&gt; ?buf:string -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=in_channel">Pervasives.in_channel</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> list</code></pre><div class="info"><div class="info"><code class="code">input_rev_sexps ?parse_pos ?buf ic</code> same as  <a href="#Sexp.input_sexps">Sexp.input_sexps</a>,
      but returns a reversed list of S-expressions, which is slightly more
      efficient.</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Loading of (converted) S-expressions</h6></div></div>
<pre><span class="VALload_sexp"><span class="keyword">val</span> load_sexp</span> : <code class="type">?strict:bool -&gt; ?buf:string -&gt; string -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">load_sexp ?strict ?buf file</code> reads one S-expression from <code class="code">file</code> using
      buffer <code class="code">buf</code> for storing intermediate data.  Faster than the
      scan-functions.<div class="parameters"><div class="param_info"><code class="code">strict</code> : default = <code class="code">true</code></div></div> <b>Raises</b> <code>Parse_error</code> if the S-expression is unparseable.<br/><code>Failure</code> if parsing reached the end of file before one S-expression
      could be read.<br/><code>Failure</code> if <code class="code">strict</code> is true and there is more than one
      S-expression in the file.<br/></div></div>
<pre><span class="VALload_sexps"><span class="keyword">val</span> load_sexps</span> : <code class="type">?buf:string -&gt; string -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> list</code></pre><div class="info"><div class="info"><code class="code">load_sexps ?buf file</code> reads a list of whitespace separated S-expressions
      from <code class="code">file</code> using buffer <code class="code">buf</code> for storing intermediate data.
      Faster than the scan-functions. <b>Raises</b> <code>Parse_error</code> if there is unparseable data in the file.<br/><code>Failure</code> if parsing reached the end of file before the last
      S-expression could be fully read.<br/></div></div>
<pre><span class="VALload_rev_sexps"><span class="keyword">val</span> load_rev_sexps</span> : <code class="type">?buf:string -&gt; string -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> list</code></pre><div class="info"><div class="info"><code class="code">load_rev_sexps ?buf file</code> same as  <a href="#Sexp.load_sexps">Sexp.load_sexps</a>, but returns a
      reversed list of S-expressions, which is slightly more efficient.</div></div>
<pre><span class="VALload_sexp_conv"><span class="keyword">val</span> load_sexp_conv</span> : <code class="type">?strict:bool -&gt; ?buf:string -&gt; string -&gt; (<a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; 'a) -&gt; 'a <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=conv">Annotated.conv</a></code></pre><div class="info"><div class="info"><code class="code">load_sexp_conv ?strict ?buf file f</code> like  <a href="#Sexp.load_sexp">Sexp.load_sexp</a>, but
      performs a conversion on the fly using <code class="code">f</code>.  Performance is equivalent
      to executing  <a href="#Sexp.load_sexp">Sexp.load_sexp</a> and performing conversion when there
      are no errors.  In contrast to the plain S-expression loader, this
      function not only performs the conversion, it will give exact error
      ranges for conversion errors. <b>Raises</b> <code>Parse_error</code> if there is unparseable data in the file.<br/><code>Failure</code> if parsing reached the end of file before the last
      S-expression could be fully read.<br/></div></div>
<pre><span class="VALload_sexp_conv_exn"><span class="keyword">val</span> load_sexp_conv_exn</span> : <code class="type">?strict:bool -&gt; ?buf:string -&gt; string -&gt; (<a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; 'a) -&gt; 'a</code></pre><div class="info"><div class="info"><code class="code">load_sexp_conv_exn ?strict ?buf file f</code> like  <a href="#load_sexp_conv">load_sexp_conv</a>,
      but returns the converted value or raises <code class="code">Of_sexp_error</code> with exact
      location information in the case of a conversion error.</div></div>
<pre><span class="VALload_sexps_conv"><span class="keyword">val</span> load_sexps_conv</span> : <code class="type">?buf:string -&gt; string -&gt; (<a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; 'a) -&gt; 'a <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=conv">Annotated.conv</a> list</code></pre><div class="info"><div class="info"><code class="code">load_sexps_conv ?buf file f</code> like  <a href="#Sexp.load_sexps">Sexp.load_sexps</a>, but performs
      a conversion on the fly using <code class="code">f</code>.  Performance is equivalent to
      executing  <a href="#Sexp.load_sexps">Sexp.load_sexps</a> and performing conversion when there
      are no errors.  In contrast to the plain S-expression loader, this
      function not only performs the conversion, it will give exact error
      ranges for conversion errors. <b>Raises</b> <code>Parse_error</code> if there is unparseable data in the file.<br/><code>Failure</code> if parsing reached the end of file before the last
      S-expression could be fully read.<br/></div></div>
<pre><span class="VALload_sexps_conv_exn"><span class="keyword">val</span> load_sexps_conv_exn</span> : <code class="type">?buf:string -&gt; string -&gt; (<a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; 'a) -&gt; 'a list</code></pre><div class="info"><div class="info"><code class="code">load_sexps_conv_exn ?buf file f</code> like  <a href="#load_sexps_conv">load_sexps_conv</a>, but returns
      the converted value or raises <code class="code">Of_sexp_error</code> with exact location
      information in the case of a conversion error.</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Output of S-expressions to I/O-channels</h6></div></div>
<div class="info"><div class="info">NOTE: for performance reasons these output functions may need to
      allocate large strings to write out huge S-expressions.  This may
      cause problems on 32-bit platforms.  If you think that you may need to
      write huge S-expressions on such platforms, you might want to use the
      pretty-printers that write to formatters instead (see further below).</div></div>
<pre><span class="VALoutput_hum"><span class="keyword">val</span> output_hum</span> : <code class="type"><a href="?package=ocaml&amp;module=Pervasives&amp;type=out_channel">Pervasives.out_channel</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">output_hum oc sexp</code> outputs S-expression <code class="code">sexp</code> to output channel
      <code class="code">oc</code> in human readable form.</div></div>
<pre><span class="VALoutput_hum_indent"><span class="keyword">val</span> output_hum_indent</span> : <code class="type">int -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=out_channel">Pervasives.out_channel</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">output_hum_indent indent oc sexp</code> outputs S-expression <code class="code">sexp</code>
      to output channel <code class="code">oc</code> in human readable form using indentation level
      <code class="code">indent</code>.</div></div>
<pre><span class="VALoutput_mach"><span class="keyword">val</span> output_mach</span> : <code class="type"><a href="?package=ocaml&amp;module=Pervasives&amp;type=out_channel">Pervasives.out_channel</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">output_mach oc sexp</code> outputs S-expression <code class="code">sexp</code> to output channel
      <code class="code">oc</code> in machine readable (i.e. most compact) form.</div></div>
<pre><span class="VALoutput"><span class="keyword">val</span> output</span> : <code class="type"><a href="?package=ocaml&amp;module=Pervasives&amp;type=out_channel">Pervasives.out_channel</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">output oc sexp</code> same as <code class="code">output_mach</code>.</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Output of S-expressions to file</h6></div></div>
<div class="info"><div class="info">All save-functions write to a temporary file before moving it into
      place to avoid intermittent garbling of existing files, which may
      cause problems for other processes that try to read.</div></div>
<pre><span class="VALsave_hum"><span class="keyword">val</span> save_hum</span> : <code class="type">?perm:int -&gt; string -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">save_hum ?perm file sexp</code> outputs S-expression <code class="code">sexp</code> to <code class="code">file</code> in human
      readable form.<div class="parameters"><div class="param_info"><code class="code">perm</code> : default = umask</div></div></div></div>
<pre><span class="VALsave_mach"><span class="keyword">val</span> save_mach</span> : <code class="type">?perm:int -&gt; string -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">save_mach ?perm file sexp</code> outputs S-expression <code class="code">sexp</code> to <code class="code">file</code>
      in machine readable (i.e. most compact) form.<div class="parameters"><div class="param_info"><code class="code">perm</code> : default = umask</div></div></div></div>
<pre><span class="VALsave"><span class="keyword">val</span> save</span> : <code class="type">?perm:int -&gt; string -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">save ?perm file sexp</code> same as  <a href="#save_mach">save_mach</a>.</div></div>
<pre><span class="VALsave_sexps_hum"><span class="keyword">val</span> save_sexps_hum</span> : <code class="type">?perm:int -&gt; string -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> list -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">save_sexps_hum ?perm file sexps</code> outputs S-expression list <code class="code">sexps</code> to
      <code class="code">file</code> in human readable form, each sexp being followed by a newline.<div class="parameters"><div class="param_info"><code class="code">perm</code> : default = umask</div></div></div></div>
<pre><span class="VALsave_sexps_mach"><span class="keyword">val</span> save_sexps_mach</span> : <code class="type">?perm:int -&gt; string -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> list -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">save_sexps_mach ?perm file sexps</code> outputs S-expression list <code class="code">sexps</code> to
      <code class="code">file</code> in machine readable form, each sexp being followed by a
      newline.<div class="parameters"><div class="param_info"><code class="code">perm</code> : default = umask</div></div></div></div>
<pre><span class="VALsave_sexps"><span class="keyword">val</span> save_sexps</span> : <code class="type">?perm:int -&gt; string -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> list -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">save_sexps ?perm file sexp</code> same as  <a href="#save_sexps_mach">save_sexps_mach</a>.</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Output of S-expressions to formatters</h6></div></div>
<pre><span class="VALpp_hum"><span class="keyword">val</span> pp_hum</span> : <code class="type"><a href="?package=ocaml&amp;module=Format&amp;type=formatter">Format.formatter</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">pp_hum ppf sexp</code> outputs S-expression <code class="code">sexp</code> to formatter <code class="code">ppf</code>
      in human readable form.</div></div>
<pre><span class="VALpp_hum_indent"><span class="keyword">val</span> pp_hum_indent</span> : <code class="type">int -&gt; <a href="?package=ocaml&amp;module=Format&amp;type=formatter">Format.formatter</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">pp_hum_indent n ppf sexp</code> outputs S-expression <code class="code">sexp</code> to formatter
      <code class="code">ppf</code> in human readable form and indentation level <code class="code">n</code>.</div></div>
<pre><span class="VALpp_mach"><span class="keyword">val</span> pp_mach</span> : <code class="type"><a href="?package=ocaml&amp;module=Format&amp;type=formatter">Format.formatter</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">pp_mach ppf sexp</code> outputs S-expression <code class="code">sexp</code> to formatter <code class="code">ppf</code>
      in machine readable (i.e. most compact) form.</div></div>
<pre><span class="VALpp"><span class="keyword">val</span> pp</span> : <code class="type"><a href="?package=ocaml&amp;module=Format&amp;type=formatter">Format.formatter</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">pp ppf sexp</code> same as <code class="code">pp_mach</code>.</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">String and bigstring conversions</h6></div></div>
<div class="ocaml_module sig" name="Of_string_conv_exn"><pre><span class="keyword">module</span> <a href="?package=sexplib&amp;module=Sexp_intf.S.Of_string_conv_exn">Of_string_conv_exn</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="info"><div class="info">Module encapsulating the exception raised by string converters when
      type conversions fail.</div></div><div class="ocaml_module_content">
<pre><code><span class="TYPEt"><span class="keyword">type</span> t</span> = {</code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTt.exc">exc</span> : <code class="type">exn</code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTt.sexp">sexp</span> : <code class="type"><a href="?package=sexplib&amp;module=Type&amp;type=t">Type.t</a></code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTt.sub_sexp">sub_sexp</span> : <code class="type"><a href="?package=sexplib&amp;module=Type&amp;type=t">Type.t</a></code>;</code></td></tr><tr><td>}</td></tr></table>
<pre><span class="EXCEPTIONE"><span class="keyword">exception</span> E</span> <span class="keyword">of</span> <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.Of_string_conv_exn&amp;type=t">t</a></code></pre></div></div>
<pre><span class="VALof_string"><span class="keyword">val</span> of_string</span> : <code class="type">string -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">of_string str</code> converts string <code class="code">str</code> to an S-expression.  NOTE:
      trailing whitespace is considered an error, which may be overly
      strict for some applications.  Either strip the string of trailing
      whitespace first, or, even cheaper, use  <a href="#parse">parse</a> instead.</div></div>
<pre><span class="VALof_string_conv"><span class="keyword">val</span> of_string_conv</span> : <code class="type">string -&gt; (<a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; 'a) -&gt; 'a <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=conv">Annotated.conv</a></code></pre><div class="info"><div class="info"><code class="code">of_string_conv str conv</code> like  <a href="#of_string">of_string</a>, but performs type conversion
      with <code class="code">conv</code>. <b>Returns</b> conversion result.</div></div>
<pre><span class="VALof_string_conv_exn"><span class="keyword">val</span> of_string_conv_exn</span> : <code class="type">string -&gt; (<a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; 'a) -&gt; 'a</code></pre><div class="info"><div class="info"><code class="code">of_string_conv_exn str conv</code> like  <a href="#of_string_conv">of_string_conv</a>, but raises
       <a href="#Of_string_conv_exn.E">Of_string_conv_exn.E</a> if type conversion fails. <b>Returns</b> converted
      value.</div></div>
<pre><span class="VALof_bigstring"><span class="keyword">val</span> of_bigstring</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=bigstring">bigstring</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">of_bigstring bstr</code> same as  <a href="#of_string">of_string</a>, but operates on bigstrings.</div></div>
<pre><span class="VALof_bigstring_conv"><span class="keyword">val</span> of_bigstring_conv</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=bigstring">bigstring</a> -&gt; (<a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; 'a) -&gt; 'a <a href="?package=sexplib&amp;module=Sexp_intf.S.Annotated&amp;type=conv">Annotated.conv</a></code></pre><div class="info"><div class="info"><code class="code">of_bigstring_conv bstr conv</code> like  <a href="#of_bigstring">of_bigstring</a>, but performs
      type conversion with <code class="code">conv</code>. <b>Returns</b> conversion result.</div></div>
<pre><span class="VALof_bigstring_conv_exn"><span class="keyword">val</span> of_bigstring_conv_exn</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=bigstring">bigstring</a> -&gt; (<a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; 'a) -&gt; 'a</code></pre><div class="info"><div class="info"><code class="code">of_bigstring_conv_exn bstr conv</code> like  <a href="#of_bigstring_conv">of_bigstring_conv</a>, but raises
       <a href="#Of_string_conv_exn.E">Of_string_conv_exn.E</a> if type conversion fails. <b>Returns</b> converted
      value.</div></div>
<pre><span class="VALto_string_hum"><span class="keyword">val</span> to_string_hum</span> : <code class="type">?indent:int -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; string</code></pre><div class="info"><div class="info"><code class="code">to_string_hum ?indent sexp</code> converts S-expression <code class="code">sexp</code> to a
      string in human readable form with indentation level <code class="code">indent</code>.<div class="parameters"><div class="param_info"><code class="code">indent</code> : default = <code class="code">!default_indent</code></div></div></div></div>
<pre><span class="VALto_string_mach"><span class="keyword">val</span> to_string_mach</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; string</code></pre><div class="info"><div class="info"><code class="code">to_string_mach sexp</code> converts S-expression <code class="code">sexp</code> to a string in
      machine readable (i.e. most compact) form.</div></div>
<pre><span class="VALto_string"><span class="keyword">val</span> to_string</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; string</code></pre><div class="info"><div class="info"><code class="code">to_string sexp</code> same as <code class="code">to_string_mach</code>.</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Buffer conversions</h6></div></div>
<pre><span class="VALto_buffer_hum"><span class="keyword">val</span> to_buffer_hum</span> : <code class="type">buf:<a href="?package=ocaml&amp;module=Buffer&amp;type=t">Buffer.t</a> -&gt; ?indent:int -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">to_buffer_hum ~buf ?indent sexp</code> outputs the S-expression <code class="code">sexp</code>
      converted to a string in human readable form to buffer <code class="code">buf</code>.<div class="parameters"><div class="param_info"><code class="code">indent</code> : default = <code class="code">!default_indent</code></div></div></div></div>
<pre><span class="VALto_buffer_mach"><span class="keyword">val</span> to_buffer_mach</span> : <code class="type">buf:<a href="?package=ocaml&amp;module=Buffer&amp;type=t">Buffer.t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">to_buffer_mach ~buf sexp</code> outputs the S-expression <code class="code">sexp</code> converted
      to a string in machine readable (i.e. most compact) form to buffer <code class="code">buf</code>.</div></div>
<pre><span class="VALto_buffer"><span class="keyword">val</span> to_buffer</span> : <code class="type">buf:<a href="?package=ocaml&amp;module=Buffer&amp;type=t">Buffer.t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">to_buffer ~buf sexp</code> same as  <a href="#to_buffer_mach">to_buffer_mach</a>.</div></div>
<pre><span class="VALto_buffer_gen"><span class="keyword">val</span> to_buffer_gen</span> : <code class="type">buf:'buffer -&gt;
add_char:('buffer -&gt; char -&gt; unit) -&gt;
add_string:('buffer -&gt; string -&gt; unit) -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">to_buffer_gen ~buf ~add_char ~add_string sexp</code> outputs the S-expression
      <code class="code">sexp</code> converted to a string to buffer <code class="code">buf</code> using the output functions
      <code class="code">add_char</code> and <code class="code">add_string</code>.</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Utilities for automated type conversions</h6></div></div>
<pre><span class="VALunit"><span class="keyword">val</span> unit</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">unit</code> the unit-value as expressed by an S-expression.</div></div>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">sexp_of_t sexp</code> maps S-expressions which are part of a type with
      automated S-expression conversion to themselves.</div></div>
<pre><span class="VALt_of_sexp"><span class="keyword">val</span> t_of_sexp</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">t_of_sexp sexp</code> maps S-expressions which are part of a type with
      automated S-expression conversion to themselves.</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Utilities for conversion error handling</h6></div></div>
<pre><span class="TYPEfound"><span class="keyword">type</span> found</span> = <code class="type">[ `Found | `Pos of int * <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=found">found</a> ]</code></pre><div class="info"><div class="info">Type of successful search results.  <code class="code">`Found</code> means that an
      S-expression was found at the immediate position, and <code class="code">`Pos (pos,
      found)</code> indicates that it was found at position <code class="code">pos</code> within a
      structure (= S-expression list) where <code class="code">found</code> describes recursively
      where it was found in that structure.</div></div>
<pre><span class="TYPEsearch_result"><span class="keyword">type</span> search_result</span> = <code class="type">[ `Found | `Not_found | `Pos of int * <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=found">found</a> ]</code></pre><div class="info"><div class="info">Type of search results.  <code class="code">`Not_found</code> means that an
      S-expression was not found within another S-expression.</div></div>
<pre><span class="VALsearch_physical"><span class="keyword">val</span> search_physical</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; contained:<a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=search_result">search_result</a></code></pre><div class="info"><div class="info"><code class="code">search_physical sexp ~contained</code> <b>Returns</b> the search result
      indicating whether, and if, where the S-expression <code class="code">contained</code>
      was found within S-expression <code class="code">sexp</code>.</div></div>
<pre><span class="VALsubst_found"><span class="keyword">val</span> subst_found</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; subst:<a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=found">found</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">subst_found sexp ~subst found</code> <b>Returns</b> the S-expression that
      results from substituting <code class="code">subst</code> within S-expression <code class="code">sexp</code>
      at the location described by <code class="code">found</code>.</div></div>
<div class="ocaml_module sig" name="With_layout"><pre><span class="keyword">module</span> <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout">With_layout</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="info"><div class="info">S-expressions annotated with relative source positions and comments</div></div><div class="ocaml_module_content">
<pre><span class="TYPEpos"><span class="keyword">type</span> pos</span> = {<code class="type"><a href="?package=sexplib&amp;module=Src_pos.Relative&amp;type=t">Src_pos.Relative.t</a></code>}</pre><table class="typetable">
		    <tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTpos.row">row</span> : <code class="type">int</code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTpos.col">col</span> : <code class="type">int</code>;</code></td></tr><tr><td>}</td></tr></table>
<pre><span class="VALsexp_of_pos"><span class="keyword">val</span> sexp_of_pos</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout&amp;type=pos">pos</a> -&gt; <a href="?package=sexplib&amp;module=Type&amp;type=t">Type.t</a></code></pre>
<pre><code><span class="TYPEt"><span class="keyword">type</span> t</span> = </code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.Atom"><span class="constructor">Atom</span></span> <span class="keyword">of</span> <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout&amp;type=pos">pos</a> * string * string option</code></code></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.List"><span class="constructor">List</span></span> <span class="keyword">of</span> <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout&amp;type=pos">pos</a> * t_or_comment list * <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout&amp;type=pos">pos</a></code></code></td></tr></table><div class="info"><div class="info">S-expressions annotated with relative source positions and comments</div></div>
<pre><code><span class="TYPEt_or_comment"><span class="keyword">type</span> t_or_comment</span> = </code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt_or_comment.Sexp"><span class="constructor">Sexp</span></span> <span class="keyword">of</span> <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout&amp;type=t">t</a></code></code></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt_or_comment.Comment"><span class="constructor">Comment</span></span> <span class="keyword">of</span> <code class="type">comment</code></code></td></tr></table>
<pre><code><span class="TYPEcomment"><span class="keyword">type</span> comment</span> = </code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTcomment.Plain_comment"><span class="constructor">Plain_comment</span></span> <span class="keyword">of</span> <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout&amp;type=pos">pos</a> * string</code></code></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTcomment.Sexp_comment"><span class="constructor">Sexp_comment</span></span> <span class="keyword">of</span> <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout&amp;type=pos">pos</a> * <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout&amp;type=comment">comment</a> list * <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout&amp;type=t">t</a></code></code></td></tr></table>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Type&amp;type=t">Type.t</a></code></pre>
<pre><span class="VALsexp_of_comment"><span class="keyword">val</span> sexp_of_comment</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout&amp;type=comment">comment</a> -&gt; <a href="?package=sexplib&amp;module=Type&amp;type=t">Type.t</a></code></pre>
<pre><span class="VALsexp_of_t_or_comment"><span class="keyword">val</span> sexp_of_t_or_comment</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout&amp;type=t_or_comment">t_or_comment</a> -&gt; <a href="?package=sexplib&amp;module=Type&amp;type=t">Type.t</a></code></pre>
<div class="ocaml_module sig" name="Forget"><pre><span class="keyword">module</span> <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout.Forget">Forget</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="VALt"><span class="keyword">val</span> t</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Type&amp;type=t">Type.t</a></code></pre>
<pre><span class="VALt_or_comment"><span class="keyword">val</span> t_or_comment</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout&amp;type=t_or_comment">t_or_comment</a> -&gt; <a href="?package=sexplib&amp;module=Type&amp;type=t">Type.t</a> option</code></pre>
<pre><span class="VALt_or_comments"><span class="keyword">val</span> t_or_comments</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout&amp;type=t_or_comment">t_or_comment</a> list -&gt; <a href="?package=sexplib&amp;module=Type&amp;type=t">Type.t</a> list</code></pre></div></div>
<div class="ocaml_module sig" name="Render"><pre><span class="keyword">module</span> <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout.Render">Render</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code> with type <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout.Render&amp;type=asexp">asexp</a> := <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout&amp;type=t_or_comment">t_or_comment</a></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEasexp"><span class="keyword">type</span> asexp</span> </pre>
<pre><span class="TYPEt"><span class="keyword">type</span> <code class="type">'a </code>t</span> </pre>
<pre><span class="VALreturn"><span class="keyword">val</span> return</span> : <code class="type">'a -&gt; 'a <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout.Render&amp;type=t">t</a></code></pre>
<pre><span class="VALbind"><span class="keyword">val</span> bind</span> : <code class="type">'a <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout.Render&amp;type=t">t</a> -&gt; ('a -&gt; 'b <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout.Render&amp;type=t">t</a>) -&gt; 'b <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout.Render&amp;type=t">t</a></code></pre>
<pre><span class="VALsexp"><span class="keyword">val</span> sexp</span> : <code class="type"><a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout.Render&amp;type=asexp">asexp</a> -&gt; unit <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout.Render&amp;type=t">t</a></code></pre>
<pre><span class="VALrun"><span class="keyword">val</span> run</span> : <code class="type">(char -&gt; unit) -&gt; unit <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout.Render&amp;type=t">t</a> -&gt; unit</code></pre></div></div>
<div class="ocaml_module sig" name="Parser"><pre><span class="keyword">module</span> <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout.Parser">Parser</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEtoken"><span class="keyword">type</span> token</span> </pre>
<pre><span class="VALsexp"><span class="keyword">val</span> sexp</span> : <code class="type">(<a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout.Parser&amp;type=token">token</a>) -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout&amp;type=t_or_comment">t_or_comment</a></code></pre>
<pre><span class="VALsexp_opt"><span class="keyword">val</span> sexp_opt</span> : <code class="type">(<a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout.Parser&amp;type=token">token</a>) -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout&amp;type=t_or_comment">t_or_comment</a> option</code></pre>
<pre><span class="VALsexps"><span class="keyword">val</span> sexps</span> : <code class="type">(<a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout.Parser&amp;type=token">token</a>) -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout&amp;type=t_or_comment">t_or_comment</a> list</code></pre>
<pre><span class="VALrev_sexps"><span class="keyword">val</span> rev_sexps</span> : <code class="type">(<a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout.Parser&amp;type=token">token</a>) -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout&amp;type=t_or_comment">t_or_comment</a> list</code></pre>
<pre><span class="VALsexps_abs"><span class="keyword">val</span> sexps_abs</span> : <code class="type">(<a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout.Parser&amp;type=token">token</a>) -&gt;
<a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=sexplib&amp;module=Type_with_layout.Parsed&amp;type=t_or_comment">Type_with_layout.Parsed.t_or_comment</a> list</code></pre></div></div>
<div class="ocaml_module sig" name="Lexer"><pre><span class="keyword">module</span> <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout.Lexer">Lexer</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="VALmain"><span class="keyword">val</span> main</span> : <code class="type">?buf:<a href="?package=ocaml&amp;module=Buffer&amp;type=t">Buffer.t</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=sexplib&amp;module=Sexp_intf.S.With_layout.Parser&amp;type=token">Parser.token</a></code></pre></div></div></div></div></div></div>
</div>