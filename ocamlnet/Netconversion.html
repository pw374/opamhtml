<div class="ocaml_toplevel_module"><div class="info">Conversion between character encodings <br/> <b>Contents</b>
 <ul><li> <a href="#Netconversion.interface">Netconversion.interface</a>
     <ul><li> <a href="#Netconversion.unicode_functions">Netconversion.unicode_functions</a></li><li> <a href="#Netconversion.cursors">Netconversion.cursors</a>
           <ul><li> <a href="#Netconversion.bom">Netconversion.bom</a></li></ul></li><li> <a href="#Netconversion.direct_conv">Netconversion.direct_conv</a></li></ul>
   </li><li> <a href="#Netconversion.preliminaries">Netconversion.preliminaries</a>
     <ul><li> <a href="#Netconversion.problems">Netconversion.problems</a></li><li> <a href="#Netconversion.domain">Netconversion.domain</a></li><li> <a href="#Netconversion.linking">Netconversion.linking</a></li><li> <a href="#Netconversion.subsets">Netconversion.subsets</a></li><li> <a href="#Netconversion.unicode">Netconversion.unicode</a></li></ul></li></ul></div>
<div class="info"><div class="info"><h1 id="preliminaries">Preliminaries</h1><br/> A <b>character set</b> is a set of characters where every character is
 identified by a <b>code point</b>. An <b>encoding</b> is a way of 
 representing characters from a set in byte strings. For example,
 the Unicode character set has more than 96000 characters, and
 the code points have values from 0 to 0x10ffff (not all code points
 are assigned yet). The UTF-8 encoding represents the code points
 by sequences of 1 to 4 bytes. There are also encodings that 
 represent code points from several sets, e.g EUC-JP covers four
 sets.<br/> Encodings are enumerated by the type <code class="code">encoding</code>, and names follow
 the convention <code class="code">`Enc_*</code>, e.g. <code class="code">`Enc_utf8</code>. 
 Character sets are enumerated by the type
 <code class="code">charset</code>, and names follow the convention <code class="code">`Set_*</code>, e.g.
 <code class="code">`Set_unicode</code>.<br/> This module deals mainly with encodings. It is important to know
 that the same character set may have several encodings. For example,
 the Unicode character set can be encoded as UTF-8 or UTF-16.
 For the 8 bit character sets, however, there is usually only one
 encoding, e.g <code class="code">`Set_iso88591</code> is always encoded as <code class="code">`Enc_iso88591</code>.<br/> In a <b>single-byte encoding</b> every code point is represented by
 one byte. This is what many programmers are accustomed at, and
 what the O'Caml language specially supports: A <code class="code">string</code> is
 a sequence of <code class="code">char</code>s, where <code class="code">char</code> means an 8 bit quantity
 interpreted as character. For example, the following piece of code allocates
 a <code class="code">string</code> of four <code class="code">char</code>s, and assigns them individually:<br/> <pre class="codepre"><code class="code">
 let s = String.create 4 in
 s.[0] &lt;- 'G';
 s.[1] &lt;- 'e';
 s.[2] &lt;- 'r';
 s.[3] &lt;- 'd';
 </code></pre><br/> In a <b>multi-byte encoding</b> there are code points that are represented
 by several bytes. As we still represent such text as <code class="code">string</code>, the
 problem arises that a single <code class="code">char</code>, actually a byte, often represents 
 only a fraction of a full multi-byte character. There are two solutions:<ul><li>Give up the principle that text is represented by <code class="code">string</code>.
   This is, for example, the approach chosen by <code class="code">Camomile</code>, another O'Caml
   library dealing with Unicode. Instead, text is represented as
   <code class="code">int array</code>. This way, the algorithms processing the text can
   remain the same.</li><li>Give up the principle that individual characters can be directly
   accessed in a text. This is the primary way chosen by Ocamlnet.
   This means that there is not any longer the possibility to read
   or write the <code class="code">n</code>th character of a text. One can, however, still 
   compose texts by just concatenating the strings representing
   individual characters. Furthermore, it is possible to define
   a cursor for a text that moves sequentially along the text.
   The consequence is that programmers are restricted to sequential
   algorithms. Note that the majority of text processing falls into
   this class.</li></ul> The corresponding piece of code for Ocamlnet's Unicode implementation
 is:
 <pre class="codepre"><code class="code">
 let b = Buffer.create 80 in
 Buffer.add b (ustring_of_uchar `Enc_utf8 71);  (* 71 = code point of 'G' *)
 Buffer.add b (ustring_of_uchar `Enc_utf8 101); (* 101 = code point of 'e' *)
 Buffer.add b (ustring_of_uchar `Enc_utf8 114); (* 114 = code point of 'r' *)
 Buffer.add b (ustring_of_uchar `Enc_utf8 100); (* 100 = code point of 'd' *)
 let s = Buffer.contents b
 </code></pre><br/> It is important to always remember that a <code class="code">char</code> is no longer 
 a character but simply a byte. In many of the following explanations,
 we strictly distinguish between <b>byte positions</b> or <b>byte counts</b>,
 and <b>character positions</b> or <b>character counts</b>.<br/> There a number of special effects that usually only occur in
 multi-byte encodings:<br/> - Bad encodings: Not every byte sequence is legal. When scanning
   such text, the functions will raise the exception <code class="code">Malformed_code</code>
   when they find illegal bytes.<ul><li>Unassigned code points: It may happen that a byte sequence is
   a correct representation for a code point, but that the code point
   is unassigned in the character set. When scanning, this is also
   covered by the exception <code class="code">Malformed_code</code>. When converting from
   one encoding to another, it is also possible that the code point
   is only unassigned in the target character set. This case is
   usually handled by a substitution function <code class="code">subst</code>, and if no such
   function is defined, by the exception <code class="code">Cannot_represent</code>.</li><li>Incomplete characters: The trailing bytes of a string may be the
   correct beginning of a byte sequence for a character, but not a
   complete sequence. Of course, if that string is the end of a
   text, this is just illegal, and also a case for <code class="code">Malformed_code</code>.
   However, when text is processed chunk by chunk, this phenomenon
   may happen legally for all chunks but the last. For this reason,
   some of the functions below handle this case specially.</li><li>Byte order marks: Some encodings have both big and little endian
   variants. A byte order mark at the beginning of the text declares
   which variant is actually used. This byte order mark is a 
   declaration written like a character, but actually not a 
   character.</li></ul> There is a special class of encodings known as <b>ASCII-compatible</b>.
 They are important because there are lots of programs and protocols
 that only interpret bytes from 0 to 127, and treat the bytes from
 128 to 255 as data. These programs can process texts as long as
 the bytes from 0 to 127 are used as in ASCII. Fortunately, many
 encodings are ASCII-compatible, including UTF-8.<br/> <h2 id="unicode">Unicode</h2><br/> <code class="code">Netconversion</code> is centred around Unicode.
 The conversion from one encoding to another works by finding the
 Unicode code point of the character
 to convert, and by representing the code point in the target encoding,
 even if neither encodings have to do with Unicode.
 Of course, this approach requires that all character sets handled
 by <code class="code">Netconversion</code> are subsets of Unicode.<br/> The supported range of Unicode code points: 0 to 0xd7ff, 0xe000 to 0xfffd,
 0x10000 to 0x10ffff. All these code points can be represented in 
 UTF-8 and UTF-16. <code class="code">Netconversion</code> does not know which of the code
 points are assigned and which not, and because of this, it simply
 allows all code points of the mentioned ranges (but for other character
 sets, the necessary lookup tables exist).<br/> <b>UTF-8:</b> The UTF-8 representation can have one to four bytes. Malformed 
   byte sequences are always rejected, even those that want to cheat the
   reader like &quot;0xc0 0x80&quot; for the code point 0. There is special support
   for the Java variant of UTF-8 (<code class="code">`Enc_java</code>). UTF-8 strings must not
   have a byte order mark (it would be interpreted as &quot;zero-width space&quot;
   character).<br/> <b>UTF-16:</b> When reading from a string encoded as <code class="code">`Enc_utf16</code>, a byte
   order mark is expected at the beginning. The detected variant 
   (<code class="code">`Enc_utf16_le</code> or <code class="code">`Enc_utf16_be</code>) is usually returned by the parsing
   function. The byte order mark is not included into the output string. - 
   Some functions of this
   module cannot cope with <code class="code">`Enc_utf16</code> (i.e. UTF-16 without endianess
   annotation), and will fail.<br/>   Once the endianess is determined, the code point 0xfeff is no longer
   interpreted as byte order mark, but as &quot;zero-width non-breakable space&quot;.<br/>   Some code points are represented by pairs of 16 bit values, these
   are the so-called &quot;surrogate pairs&quot;. They can only occur in UTF-16.<br/> <h2 id="subsets">Subsets of Unicode</h2><br/> The non-Unicode character sets are subsets of Unicode. Here, it may
 happen that a Unicode code point does not have a corresponding 
 code point. In this case, certain rules are applied to handle
 this (see below). It is, however, ensured that every non-Unicode
 code point has a corresponding Unicode code point. (In other words,
 character sets cannot be supported for which this property does
 not hold.)<br/> It is even possible to create further subsets artificially. The
 encoding <code class="code">`Enc_subset(e,def)</code> means to derive a new encoding from
 the existing one <code class="code">e</code>, but to only accept the code points for which
 the definition function <code class="code">def</code> yields the value <code class="code">true</code>. For example,
 the encoding 
 <pre class="codepre"><code class="code"> `Enc_subset(`Enc_usascii, 
             fun i -&gt; i &lt;&gt; 34 &amp;&amp; i &lt;&gt; 38 &amp;&amp; i &lt;&gt; 60 &amp;&amp; i &lt;&gt; 62) </code></pre>
 is ASCII without the bracket angles, the quotation mark, and the
 ampersand character, i.e. the subset of ASCII that can be included
 in HTML text without escaping.<br/> If a code point is not defined by the encoding but found in a text, 
 the reader will raise the exception <code class="code">Malformed_code</code>. When text is
 output, however, the <code class="code">subst</code> function will be called for undefined code 
 points (which raises <code class="code">Cannot_represent</code> by default). The <code class="code">subst</code>
 function is an optional argument of many conversion functions that
 allows it to insert a substitution text for undefined code points.
 Note, however, that the substitution text is restricted to at most
 50 characters (because unlimited length would lead to difficult
 problems we would like to avoid).<br/> <h2 id="linking">Linking this module</h2><br/> Many encodings require lookup tables. The following encodings
 are built-in and always supported:<br/> - Unicode: <code class="code">`Enc_utf8</code>, <code class="code">`Enc_java</code>, <code class="code">`Enc_utf16</code>, <code class="code">`Enc_utf16_le</code>, 
     <code class="code">`Enc_utf16_be</code><ul><li>Other: <code class="code">`Enc_usascii</code>, <code class="code">`Enc_iso88591</code>, <code class="code">`Enc_empty</code></li></ul> The lookup tables for the other encodings are usually loaded at
 runtime, but it is also possible to embed them in the generated
 binary executable. See the file <code class="code">INSTALL</code> for details. The functions
 <code class="code">available_input_encodings</code> and <code class="code">available_output_encodings</code> can
 be invoked to find out which encodings can be loaded, or are available
 otherwise.<br/> <h2 id="domain">Supported Encodings, Restrictions</h2><br/> I took the mappings from <code class="code">www.unicode.org</code>, and the standard names of
 the character sets from IANA. Obviously, many character sets are missing
 that can be supported; especially ISO646 character sets, and many EBCDIC 
 code pages. Stateful encodings like generic ISO-2022 have been omitted
 (stateless subsets of ISO-2022 like EUC can be supported, however;
 currently we support EUC-JP and EUC-KR).<br/> Because of the copyright statement from Unicode, I cannot put the
 source tables that describe the mappings into the distribution. They
 are publicly available from <code class="code">www.unicode.org</code>.<br/> <h2 id="problems">Known Problems</h2><br/> - The following charsets do not have a bijective mapping to Unicode:
   adobe_standard_encoding, adobe_symbol_encoding, 
   adobe_zapf_dingbats_encoding, cp1002 (0xFEBE). The current implementation
   simply removes one of the conflicting code point pairs - this might
   not what you want.<ul><li>Japanese encodings: 
   JIS X 0208: The character 1/32 is mapped to 0xFF3C, and not
   to 0x005C.
 </li></ul></div></div>
<div class="info"><div class="info"><h1 id="interface">Interface</h1><br/> <b>Naming conventions:</b><br/> As it is possible to refer to substrings by either giving a byte
 offset or by counting whole characters, these naming conventions
 are helpful:<br/> - Labels called <code class="code">range_pos</code> and <code class="code">range_len</code> refer to byte positions of
   characters, or substrings<ul><li>Labels called <code class="code">count</code> refer to positions given as the number of characters
   relative to an origin</li></ul> Furthermore:<br/> - A <code class="code">uchar</code> is a single Unicode code point represented as int<ul><li>A <code class="code">ustring</code> is a string of encoded characters</li><li>A <code class="code">uarray</code> is an <code class="code">array of int</code> representing a string
 </li></ul></div></div>
<pre><span class="EXCEPTIONMalformed_code"><span class="keyword">exception</span> Malformed_code</span></pre><div class="info"><div class="info">Raised when an illegal byte sequence is found</div></div>
<pre><span class="EXCEPTIONCannot_represent"><span class="keyword">exception</span> Cannot_represent</span> <span class="keyword">of</span> <code class="type">int</code></pre><div class="info"><div class="info">Raised when a certain Unicode code point cannot be represented in
 the selected output encoding</div></div>
<pre><span class="TYPEencoding"><span class="keyword">type</span> encoding</span> = <code class="type">[ `Enc_adobe_standard_encoding
| `Enc_adobe_symbol_encoding
| `Enc_adobe_zapf_dingbats_encoding
| `Enc_cp037
| `Enc_cp1006
| `Enc_cp1026
| `Enc_cp1047
| `Enc_cp424
| `Enc_cp437
| `Enc_cp500
| `Enc_cp737
| `Enc_cp775
| `Enc_cp850
| `Enc_cp852
| `Enc_cp855
| `Enc_cp856
| `Enc_cp857
| `Enc_cp860
| `Enc_cp861
| `Enc_cp862
| `Enc_cp863
| `Enc_cp864
| `Enc_cp865
| `Enc_cp866
| `Enc_cp869
| `Enc_cp874
| `Enc_cp875
| `Enc_empty
| `Enc_eucjp
| `Enc_euckr
| `Enc_iso88591
| `Enc_iso885910
| `Enc_iso885911
| `Enc_iso885913
| `Enc_iso885914
| `Enc_iso885915
| `Enc_iso885916
| `Enc_iso88592
| `Enc_iso88593
| `Enc_iso88594
| `Enc_iso88595
| `Enc_iso88596
| `Enc_iso88597
| `Enc_iso88598
| `Enc_iso88599
| `Enc_java
| `Enc_jis0201
| `Enc_koi8r
| `Enc_macroman
| `Enc_subset of <a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> * (int -&gt; bool)
| `Enc_usascii
| `Enc_utf16
| `Enc_utf16_be
| `Enc_utf16_le
| `Enc_utf8
| `Enc_windows1250
| `Enc_windows1251
| `Enc_windows1252
| `Enc_windows1253
| `Enc_windows1254
| `Enc_windows1255
| `Enc_windows1256
| `Enc_windows1257
| `Enc_windows1258 ]</code></pre><div class="info"><div class="info">The polymorphic variant enumerating the supported encodings. We have:<ul><li><code class="code">`Enc_utf8</code>: UTF-8</li><li><code class="code">`Enc_java</code>: The UTF-8 variant used by Java (the only difference is
   the representation of NUL)</li><li><code class="code">`Enc_utf16</code>: UTF-16 with unspecified endianess (restricted)</li><li><code class="code">`Enc_utf16_le</code>: UTF-16 little endian</li><li><code class="code">`Enc_utf16_be</code>: UTF-16 big endian</li><li><code class="code">`Enc_usascii</code>: US-ASCII (7 bits)</li><li><code class="code">`Enc_iso8859</code><i>n</i>: ISO-8859-<i>n</i></li><li><code class="code">`Enc_koi8r</code>: KOI8-R</li><li><code class="code">`Enc_jis0201</code>: JIS-X-0201 (Roman and Katakana)</li><li><code class="code">`Enc_eucjp</code>: EUC-JP (code points from US-ASCII, JIS-X-0202, -0208, and
   -0212)</li><li><code class="code">`Enc_euckr</code>: EUC-KR (code points from US-ASCII, KS-X-1001)</li><li><code class="code">`Enc_windows</code><i>n</i>: WINDOWS-<i>n</i></li><li><code class="code">`Enc_cp</code><i>n</i>: IBM code page <i>n</i>. Note that there are both ASCII-
   and EBCDIC-based code pages</li><li><code class="code">`Enc_adobe_*</code>: Adobe-specific encodings, e.g. used in Adobe fonts</li><li><code class="code">`Enc_mac*</code>: Macintosh-specific encodings</li><li><code class="code">`Enc_subset(e,def)</code>: The subset of <code class="code">e</code> by applying the definition 
   function <code class="code">def</code></li><li><code class="code">`Enc_empty</code>: The empty encoding (does not represent any character)
 </li></ul></div></div>
<pre><span class="TYPEcharset"><span class="keyword">type</span> charset</span> = <code class="type">[ `Set_adobe_standard_encoding
| `Set_adobe_symbol_encoding
| `Set_adobe_zapf_dingbats_encoding
| `Set_cp037
| `Set_cp1006
| `Set_cp1026
| `Set_cp1047
| `Set_cp424
| `Set_cp437
| `Set_cp500
| `Set_cp737
| `Set_cp775
| `Set_cp850
| `Set_cp852
| `Set_cp855
| `Set_cp856
| `Set_cp857
| `Set_cp860
| `Set_cp861
| `Set_cp862
| `Set_cp863
| `Set_cp864
| `Set_cp865
| `Set_cp866
| `Set_cp869
| `Set_cp874
| `Set_cp875
| `Set_iso88591
| `Set_iso885910
| `Set_iso885911
| `Set_iso885913
| `Set_iso885914
| `Set_iso885915
| `Set_iso885916
| `Set_iso88592
| `Set_iso88593
| `Set_iso88594
| `Set_iso88595
| `Set_iso88596
| `Set_iso88597
| `Set_iso88598
| `Set_iso88599
| `Set_jis0201
| `Set_jis0208
| `Set_jis0212
| `Set_koi8r
| `Set_ks1001
| `Set_macroman
| `Set_unicode
| `Set_usascii
| `Set_windows1250
| `Set_windows1251
| `Set_windows1252
| `Set_windows1253
| `Set_windows1254
| `Set_windows1255
| `Set_windows1256
| `Set_windows1257
| `Set_windows1258 ]</code></pre><div class="info"><div class="info">A <code class="code">charset</code> is simply a set of code points. It does not say how
 the code points are encoded as bytes. Every encoding implies a certain
 charset (or several charsets) that can be encoded, but the reverse is 
 not true.</div></div>
<div class="info"><div class="info"><b>Pre-evaluation of the encoding argument:</b><br/> A number of the following functions can be made run faster if they are
 called several times for the same encoding. In this case, it is recommended
 to apply the function once partially with the encoding argument, and to
 call the resulting closure instead. For example, <code class="code">ustring_of_uchar</code> supports
 this technique:<br/> <pre class="codepre"><code class="code">
   let my_ustring_of_uchar = ustring_of_uchar my_enc in
   let s1 = my_ustring_of_uchar u1 ...
   let s2 = my_ustring_of_uchar u2 ... </code></pre><br/> This is <b>much</b> faster than<br/> <pre class="codepre"><code class="code">
   let s1 = ustring_of_uchar my_enc u1 ...
   let s2 = ustring_of_uchar my_enc u2 ... </code></pre><br/> The availability of this optimization is indicated by the predicate
 PRE_EVAL(<i>arg</i>) where <i>arg</i> identifies the encoding argument.<br/> <b>Inlining</b><br/> When a function can be inlined across module/library boundaries,
 this is indicated by the predicate INLINED. Of course, this works
 only for the ocamlopt compiler.</div></div>
<pre><span class="VALencoding_of_string"><span class="keyword">val</span> encoding_of_string</span> : <code class="type">string -&gt; <a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a></code></pre><div class="info"><div class="info">Returns the encoding of the name of the encoding. Fails if the 
 encoding is unknown.
 E.g. <code class="code">encoding_of_string &quot;iso-8859-1&quot; = `Enc_iso88591</code> <br/> Punctuation characters (e.g. &quot;-&quot;) and year suffixes (e.g.
 &quot;:1991&quot;) are ignored.</div></div>
<pre><span class="VALstring_of_encoding"><span class="keyword">val</span> string_of_encoding</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; string</code></pre><div class="info"><div class="info">Returns the name of the encoding.</div></div>
<pre><span class="VALis_ascii_compatible"><span class="keyword">val</span> is_ascii_compatible</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; bool</code></pre><div class="info"><div class="info">&quot;ASCII compatible&quot; means: The bytes 1 to 127 represent the ASCII
 codes 1 to 127, and no other representation of a character contains
 the bytes 1 to 127.<br/> For example, ISO-8859-1 is ASCII-compatible because the byte 1 to
 127 mean the same as in ASCII, and all other characters use bytes
 greater than 127. UTF-8 is ASCII-compatible for the same reasons,
 it does not matter that there are multi-byte characters.
 EBCDIC is not ASCII-compatible because the bytes 1 to 127 do not mean
 the same as in ASCII. UTF-16 is not ASCII-compatible because the bytes
 1 to 127 can occur in multi-byte representations of non-ASCII
 characters.<br/> The byte 0 has been excluded from this definition because the C
 language uses it with a special meaning that has nothing to do with
 characters, so it is questionable to interpret the byte 0 anyway.</div></div>
<pre><span class="VALis_single_byte"><span class="keyword">val</span> is_single_byte</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; bool</code></pre><div class="info"><div class="info">Returns whether the encoding is a single-byte encoding</div></div>
<pre><span class="VALsame_encoding"><span class="keyword">val</span> same_encoding</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; <a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; bool</code></pre><div class="info"><div class="info">Whether both encodings are the same. <code class="code">`Enc_subset</code> encodings are only
 considered as equal when the definition functions are physically the same.<br/> Warning: Don't use ( = ) to compare encodings because this may
 fail.</div></div>
<pre><span class="VALbyte_order_mark"><span class="keyword">val</span> byte_order_mark</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; string</code></pre><div class="info"><div class="info">Returns the byte order mark that must occur at the beginning of
 files to indicate whether &quot;little endian&quot; or &quot;big endian&quot; is used.
 If this does not apply to the encoding, an empty string is returned.<br/> See also the section about &quot; <a href="#Netconversion.bom">Netconversion.bom</a>&quot; below.</div></div>
<pre><span class="VALmakechar"><span class="keyword">val</span> makechar</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; int -&gt; string</code></pre><div class="info"><div class="info"><code class="code">makechar enc i:</code>
 Creates the string representing the Unicode code point <code class="code">i</code> in encoding
 <code class="code">enc</code>. Raises <code class="code">Not_found</code> if the character is legal but cannot be 
 represented in <code class="code">enc</code>.<br/> Possible encodings: everything but <code class="code">`Enc_utf16</code>.<br/> Evaluation hints:<ul><li>PRE_EVAL(encoding)</li></ul><span class="warning">Deprecated.</span> This function is deprecated since ocamlnet-0.96. Use
   <code class="code">ustring_of_uchar</code> instead.<br/></div></div>
<pre><span class="VALustring_of_uchar"><span class="keyword">val</span> ustring_of_uchar</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; int -&gt; string</code></pre><div class="info"><div class="info"><code class="code">ustring_of_uchar enc i</code>:
 Creates the string representing the Unicode code point <code class="code">i</code> in encoding
 <code class="code">enc</code>. Raises <code class="code">Cannot_represent i</code> if the character is legal but cannot be 
 represented in <code class="code">enc</code>.<br/> Possible encodings: everything but <code class="code">`Enc_utf16</code>.<br/> Evaluation hints:<ul><li>PRE_EVAL(encoding)
   </li></ul></div></div>
<pre><span class="VALto_unicode"><span class="keyword">val</span> to_unicode</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=charset">charset</a> -&gt; int -&gt; int</code></pre><div class="info"><div class="info">Maps the code point of the charset to the corresponding 
 Unicode code point, or raises <code class="code">Malformed_code</code>, when the
 input number does not correspond to a code point.<br/> Note <code class="code">`Set_jis0208</code> and <code class="code">`Set_jis0212</code>: Code points are usually
 given by a row and column number. The numeric code point returned by
 this function is computed by multiplying the row number (1..94) with 96,
 and by adding the column number (1..94), i.e. row*96+column.<br/> Evaluation hints:<ul><li>PRE_EVAL(charset)
   </li></ul></div></div>
<pre><span class="VALfrom_unicode"><span class="keyword">val</span> from_unicode</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=charset">charset</a> -&gt; int -&gt; int</code></pre><div class="info"><div class="info">Maps the Unicode code point to the corresponding code point of
 the charset, or raises <code class="code">Cannot_represent</code> when there is no such
 corresponding code point.<br/> Note <code class="code">`Set_jis0208</code> and <code class="code">`Set_jis0212</code>: Code points are usually
 given by a row and column number. The numeric code point returned by
 this function is computed by multiplying the row number (1..94) with 96,
 and by adding the column number (1..94), i.e. row*96+column.<br/> Evaluation hints:<ul><li>PRE_EVAL(charset)
   </li></ul></div></div>
<pre><span class="VALavailable_input_encodings"><span class="keyword">val</span> available_input_encodings</span> : <code class="type">unit -&gt; <a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> list</code></pre><div class="info"><div class="info">Returns the list of all available encodings that can be used for
 input strings. The list reflects the set of loadable/linked <code class="code">Netmapping</code>
 modules.</div></div>
<pre><span class="VALavailable_output_encodings"><span class="keyword">val</span> available_output_encodings</span> : <code class="type">unit -&gt; <a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> list</code></pre><div class="info"><div class="info">Returns the list of all available encodings that can be used for
 output strings. The list reflects the set of loadable/linked <code class="code">Netmapping</code>
 modules.</div></div>
<pre><span class="VALuser_encoding"><span class="keyword">val</span> user_encoding</span> : <code class="type">unit -&gt; <a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> option</code></pre><div class="info"><div class="info">Determines the preferred user encoding:<br/>      - Unix: This is the character set from the current locale<ul><li>Win32: This is derived from the current ANSI code page</li></ul>      If an error occurs while determining the result, the value
      <code class="code">None</code> is returned.</div></div>
<pre><span class="VALwin32_code_pages"><span class="keyword">val</span> win32_code_pages</span> : <code class="type">(int * <a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a>) list</code></pre><div class="info"><div class="info">Mapping between Win32 code page numbers and Ocamlnet encodings.
      This is incomplete. The official list:
      http://msdn.microsoft.com/en-us/library/dd317756%28v=VS.85%29.aspx</div></div>
<div class="info"><div class="info"><h2 id="direct_conv">Direct Conversion</h2></div></div>
<div class="info"><div class="info">In order to convert a string from one encoding to another, call
 <code class="code">convert</code> like in<br/> <pre class="codepre"><code class="code"> let s_utf8 = 
    convert ~in_enc:`Enc_iso88591 ~out_enc:`Enc_utf8 s_latin1 </code></pre><br/> which converts the ISO-8859-1 string <code class="code">s_latin1</code> to the UTF-8 string
 <code class="code">s_utf8</code>.<br/> It is also possible to convert while reading from or writing to a file.
 This use case is effectively handled by the class 
  <a href="#Netconversion.conversion_pipe">Netconversion.conversion_pipe</a>.
 See the explanations of this class for examples.</div></div>
<pre><span class="VALconvert"><span class="keyword">val</span> convert</span> : <code class="type">?subst:(int -&gt; string) -&gt;
in_enc:<a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt;
out_enc:<a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; ?range_pos:int -&gt; ?range_len:int -&gt; string -&gt; string</code></pre><div class="info"><div class="info">Converts the string from <code class="code">in_enc</code> to <code class="code">out_enc</code>, and returns it.
 The string must consist of a whole number of characters. If it
 ends with an incomplete multi-byte character, however, this is
 detected, and the exception <code class="code">Malformed_code</code> will be raised.
 This exception is also raised for other encoding errors in the
 input string.<div class="parameters"><div class="param_info"><code class="code">subst</code> : This function is invoked for code points of <code class="code">in_enc</code> that
   cannot be represented in <code class="code">out_enc</code>, and the result of the function 
   invocation is substituted (directly, without any further conversion).
   Restriction: The string returned by <code class="code">subst</code> must not be longer than 50
   bytes.
   If <code class="code">subst</code> is missing, <code class="code">Cannot_represent</code> is raised in this case.</div><div class="param_info"><code class="code">range_pos</code> : Selects a substring for conversion. <code class="code">range_pos</code>
   is the byte position of the first character of the substring.
   (Default: 0)</div><div class="param_info"><code class="code">range_len</code> : Selects a substring for conversion. <code class="code">range_len</code>
   is the length of the substring in bytes (Default: Length
   of the input string minus <code class="code">range_pos</code>)</div></div></div></div>
<pre><span class="VALrecode_string"><span class="keyword">val</span> recode_string</span> : <code class="type">in_enc:<a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt;
out_enc:<a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; ?subst:(int -&gt; string) -&gt; string -&gt; string</code></pre><div class="info"><div class="info">Recodes a complete string from <code class="code">in_enc</code> to <code class="code">out_enc</code>, and returns it.
 The function <code class="code">subst</code> is invoked for code points of <code class="code">in_enc</code> that cannot
 be represented in <code class="code">out_enc</code>, and the result of the function invocation
 is substituted.
 Restriction: The string returned by <code class="code">subst</code> must not be longer than 50
 bytes.
 If <code class="code">subst</code> is missing, <code class="code">Not_found</code> is raised in this case.<span class="warning">Deprecated.</span> This function is obsolete since ocamlnet-0.96. Use
   <code class="code">convert</code> instead.<br/></div></div>
<pre><span class="VALrecode"><span class="keyword">val</span> recode</span> : <code class="type">in_enc:<a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt;
in_buf:string -&gt;
in_pos:int -&gt;
in_len:int -&gt;
out_enc:<a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt;
out_buf:string -&gt;
out_pos:int -&gt;
out_len:int -&gt; max_chars:int -&gt; subst:(int -&gt; string) -&gt; int * int * <a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a></code></pre><div class="info"><div class="info">Converts the character sequence contained in the at most <code class="code">in_len</code> bytes
 of <code class="code">in_buf</code> starting at byte position <code class="code">in_pos</code>, and writes the result 
 into at most <code class="code">out_len</code> bytes of <code class="code">out_buf</code> starting at byte position
 <code class="code">out_pos</code>. At most <code class="code">max_chars</code> characters are converted from 
 <code class="code">in_buf</code> to <code class="code">out_buf</code>.<br/> The characters in <code class="code">in_buf</code> are assumed to be encoded as <code class="code">in_enc</code>, and the 
 characters in <code class="code">out_buf</code> will be encoded as <code class="code">out_enc</code>. The case
 <code class="code">in_enc = out_enc</code> is not handled specially, and is carried out as
 fast as any other conversion.<br/> If there is a code point which cannot be represented in <code class="code">out_enc</code>,
 the function <code class="code">subst</code> is called with the code point as argument, and the
 resulting string (which must already be encoded as <code class="code">out_enc</code>) is
 inserted instead. 
 It is possible that <code class="code">subst</code> is called several times for the same
 character. Restriction: The string returned by subst must not be longer
 than 50 bytes.<br/> It is allowed that the input buffer ends with an incomplete
 multi-byte character. This character is not converted, i.e. the
 conversion ends just before this character. This special condition
 is not indicated to the caller. <b>Returns</b> The triple <code class="code">(in_n, out_n, in_enc')</code> is returned:<ul><li><code class="code">in_n</code> is the actual number of bytes that have been converted from
   <code class="code">in_buf</code>; <code class="code">in_n</code> may be smaller than <code class="code">in_len</code> because of incomplete
   multi-byte characters, or because the output buffer has less space
   for characters than the input buffer, or because of a change
   of the encoding variant.</li><li><code class="code">out_n</code> is the actual number of bytes written into <code class="code">out_buf</code>.</li><li><code class="code">in_enc'</code> is normally identical to <code class="code">in_enc</code>. However, there are cases
   where the encoding can be refined when looking at the byte
   sequence; for example whether a little endian or big endian variant
   of the encoding is used. <code class="code">in_enc'</code> is the variant of <code class="code">in_enc</code> that was
   used for the last converted character.</li></ul> If there is at least one complete character in <code class="code">in_buf</code>, and at least
 space for one complete character in <code class="code">out_buf</code>, and <code class="code">max_chars &gt;= 1</code>, it is 
 guaranteed that <code class="code">in_n &gt; 0 &amp;&amp; out_n &gt; 0</code>.</div></div>
<div class="ocaml_class ident" name="conversion_pipe" path="?package=ocamlnet&amp;module=Netchannels&amp;class=io_obj_channel"><pre><span class="TYPEconversion_pipe"><span class="keyword">class</span> <a href="?package=ocamlnet&amp;module=Netconversion&amp;class=conversion_pipe">conversion_pipe</a></span> : <code class="type">(int -&gt; string) option -&gt; <a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; <a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; unit -&gt; </code><a href="?package=ocamlnet&amp;module=Netchannels&amp;class=io_obj_channel">Netchannels.io_obj_channel</a></pre><div class="info"><div class="info">This pipeline class (see <code class="code">Netchannels</code> for more information) can be used
 to recode a netchannel while reading or writing. The argument <code class="code">in_enc</code>
 is the input encoding, and <code class="code">out_enc</code> is the output encoding.<br/> The channel must consist of a whole number of characters. If it
 ends with an incomplete multi-byte character, however, this is
 detected, and the exception <code class="code">Malformed_code</code> will be raised.
 This exception is also raised for other encoding errors in the
 channel data.<br/> <b>Example.</b> Convert ISO-8859-1 to UTF-8 while writing to the file
 <code class="code">&quot;output.txt&quot;</code>:<br/> <pre class="codepre"><code class="code">
    let ch = new output_channel (open_out &quot;output.txt&quot;) in
    let encoder = 
      new conversion_pipe ~in_enc:`Enc_iso88591 ~out_enc:`Enc_utf8 () in
    let ch' = new output_filter encoder ch in
    ... (* write to ch' *)
    ch' # close_out();
    ch  # close_out();  (* you must close both channels! *)
 </code></pre><br/> If you write as UTF-16, don't forget to output the byte order
 mark yourself, as the channel does not do this.<br/> <b>Example.</b> Convert UTF-16 to UTF-8 while reading from the file
 <code class="code">&quot;input.txt&quot;</code>:<br/> <pre class="codepre"><code class="code">
    let ch = new input_channel (open_in &quot;input.txt&quot;) in
    let encoder = 
      new conversion_pipe ~in_enc:`Enc_utf16 ~out_enc:`Enc_utf8 () in
    let ch' = new input_filter ch encoder in
    ... (* read from ch' *)
    ch' # close_in();
    ch  # close_in();  (* you must close both channels! *)
 </code></pre><div class="parameters"><div class="param_info"><code class="code">subst</code> : This function is invoked for code points of <code class="code">in_enc</code> that
   cannot be represented in <code class="code">out_enc</code>, and the result of the function 
   invocation is substituted (directly, without any further conversion).
   Restriction: The string returned by <code class="code">subst</code> must not be longer than 50
   bytes.
   If <code class="code">subst</code> is missing, <code class="code">Cannot_represent</code> is raised in this case.</div></div></div></div></div>
<div class="ocaml_class ident" name="recoding_pipe" path="?package=ocamlnet&amp;module=Netchannels&amp;class=io_obj_channel"><pre><span class="TYPErecoding_pipe"><span class="keyword">class</span> <a href="?package=ocamlnet&amp;module=Netconversion&amp;class=recoding_pipe">recoding_pipe</a></span> : <code class="type">(int -&gt; string) option -&gt; <a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; <a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; unit -&gt; </code><a href="?package=ocamlnet&amp;module=Netchannels&amp;class=io_obj_channel">Netchannels.io_obj_channel</a></pre><div class="info"><div class="info">Recodes a channel like <code class="code">conversion_pipe</code>. The difference is that
 <code class="code">subst</code> raises <code class="code">Not_found</code> by default, and not <code class="code">Cannot_represent</code>.<span class="warning">Deprecated.</span> This class is deprecated since ocamlnet-0.96. Use
   <code class="code">conversion_pipe</code> instead.<br/></div></div></div>
<div class="info"><div class="info"><h2 id="cursors">Reading Text Using Cursors</h2><br/> A cursor is a reference to a character in an encoded string. The
 properties of the current character can be obtained, and the cursor
 can be moved relative to its current position.<br/> For example, the following loop outputs the Unicode code points
 of all characters of the UTF-8 input string <code class="code">s</code>:<br/> <pre class="codepre"><code class="code">
 let cs = create_cursor `Enc_utf8 s in
 while not (cursor_at_end cs) do
   let n = cursor_char_count cs in
   let ch = uchar_at cs in
   printf &quot;At position %d: %d\n&quot; n ch;
   move cs;
 done
 </code></pre><br/> For a more exact definition, cursors are modeled as follows: The reference
 to the encoded string is contained in the cursor. This
 can be a complete string, or an arbitrary substring (denoted by a
 range of valid byte positions). The cursor
 position can be initially set to an arbitrary byte position of the
 encoded string.<br/> Cursor positions can be denoted by<ul><li>byte positions <code class="code">p</code> in the encoded string, or by</li><li>character counts <code class="code">n</code> relative to the initial position.</li></ul> Valid cursor positions are:<ul><li><code class="code">n=0</code>: This is always the initial cursor position</li><li><code class="code">n&gt;0</code>: Positive char counts refer to characters right to the initial
   character. The rightmost position is the position <code class="code">n_max</code> past the
   rightmost character. The rightmost position does not have a
   code point.</li><li><code class="code">n&lt;0</code>: Negative char counts refer to characters left to the initial
   character. The leftmost position is the position <code class="code">n_min</code> of the
   leftmost character.</li></ul> For the empty string we have <code class="code">n_min = n_max = 0</code>, complementing the
 above definition.<br/> Cursors are moved to the left or right of their current position
 by a whole number of characters. When it is tried to move them
 past the leftmost or rightmost position, the cursor is placed to the
 leftmost or rightmost position, respectively, and the exception
 <code class="code">Cursor_out_of_range</code> is raised.<br/> There are two cases of illegal encodings:<ul><li>When the last byte sequence of the encoded string is an incomplete
   multi-byte character, this is detected, and the special exception
   <code class="code">Partial_character</code> is raised when the code point of this character
   is read. Note that this can only happen at position <code class="code">n_max-1</code>. It
   is allowed to move beyond this character to <code class="code">n_max</code>.</li><li>When an illegal byte sequence occurs in the encoded string (including
   an incomplete multi-byte character at the beginning of the string),
   it is not possible to move the cursor to this character, or across
   this character. When it is tried to do so, the cursor stops just
   before the bad sequence, and the exception <code class="code">Malformed_code</code> is
   raised.</li></ul> It is undefined what happens when the encoded string is modified
 while a cursor is in use referring to it.</div></div>
<pre><span class="TYPEcursor"><span class="keyword">type</span> cursor</span> </pre><div class="info"><div class="info">A cursor denotes a character position in an encoded string</div></div>
<pre><span class="EXCEPTIONEnd_of_string"><span class="keyword">exception</span> End_of_string</span></pre><div class="info"><div class="info">Raised when it is tried to access the character after the end of the
 string (at position <code class="code">n_max</code>)</div></div>
<pre><span class="EXCEPTIONCursor_out_of_range"><span class="keyword">exception</span> Cursor_out_of_range</span></pre><div class="info"><div class="info">Raised when it is tried to move the cursor beyond the beginning of the
 string or beyond the end of the string. In the latter case, it is
 legal to move the cursor to the position following the last character,
 but it is not possible to move it further.</div></div>
<pre><span class="EXCEPTIONPartial_character"><span class="keyword">exception</span> Partial_character</span></pre><div class="info"><div class="info">Raised when the last character of the string is an incomplete
 multi-byte character, and it is tried to get the code point
 (using <code class="code">uchar_at</code>).</div></div>
<pre><span class="EXCEPTIONByte_order_mark"><span class="keyword">exception</span> Byte_order_mark</span></pre><div class="info"><div class="info">Raised when it is tried to get the code point of the BOM at the
 beginning of the string</div></div>
<pre><span class="VALcreate_cursor"><span class="keyword">val</span> create_cursor</span> : <code class="type">?range_pos:int -&gt;
?range_len:int -&gt; ?initial_rel_pos:int -&gt; <a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; string -&gt; <a href="?package=ocamlnet&amp;module=Netconversion&amp;type=cursor">cursor</a></code></pre><div class="info"><div class="info">Creates a new cursor for the passed string and the passed encoding.
 By default, the allowed range of the cursor is the whole string,
 and the cursor is intially positioned at the beginning of the string.
 The <b>range</b> is the part of the string the cursor can move within.<br/> <b>Special behaviour for <code class="code">`Enc_utf16</code>:</b> UTF-16 with unspecified
 endianess is handled specially. First, this encoding is only
 accepted when <code class="code">initial_rel_pos=0</code>. Second, the first two bytes
 must be a byte order mark (BOM) (if the string has a length of two
 bytes or more). The BOM counts as character without code point.
 The function <code class="code">uchar_at</code> raises the exception <code class="code">Byte_order_mark</code>
 when the BOM is accessed. Third, when the cursor is moved to the
 next character, the encoding as returned by <code class="code">cursor_encoding</code> is
 changed to either <code class="code">`Enc_utf16_le</code> or <code class="code">`Enc_utf16_be</code> according
 to the BOM. The encoding changes back to <code class="code">`Enc_utf16</code> when the
 cursor is moved back to the initial position.<div class="parameters"><div class="param_info"><code class="code">range_pos</code> : Restricts the range of the cursor to a substring.
   The argument <code class="code">range_pos</code> is the byte position of the beginning
   of the range. (Defaults to 0)</div><div class="param_info"><code class="code">range_len</code> : Restricts the range of the cursor to a substring.
   The argument <code class="code">range_len</code> is the length of the range.
   (Default: Length of the input string minus <code class="code">range_pos</code>)</div><div class="param_info"><code class="code">initial_rel_pos</code> : The initial position of the cursor, given
   as bytes relative to <code class="code">range_pos</code>. The character at this position
   is considered as the zeroth character of the string (as reported
   by <code class="code">cursor_char_count</code>)</div></div></div></div>
<pre><span class="VALreinit_cursor"><span class="keyword">val</span> reinit_cursor</span> : <code class="type">?range_pos:int -&gt;
?range_len:int -&gt;
?initial_rel_pos:int -&gt; ?enc:<a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; string -&gt; <a href="?package=ocamlnet&amp;module=Netconversion&amp;type=cursor">cursor</a> -&gt; unit</code></pre><div class="info"><div class="info">Reuses an existing cursor for a new purpose. The arguments are
 as in <code class="code">create_cursor</code>.</div></div>
<pre><span class="VALcopy_cursor"><span class="keyword">val</span> copy_cursor</span> : <code class="type">?enc:<a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; <a href="?package=ocamlnet&amp;module=Netconversion&amp;type=cursor">cursor</a> -&gt; <a href="?package=ocamlnet&amp;module=Netconversion&amp;type=cursor">cursor</a></code></pre><div class="info"><div class="info">Copies the cursor. The copy can be moved independently of the original
 cursor, but is applied to the same string. The copy starts at the
 byte position of the string where the original cursor is currently
 positioned.<div class="parameters"><div class="param_info"><code class="code">enc</code> : Optionally, the assumed
   encoding can be changed to a different one by passing <code class="code">enc</code>.</div></div></div></div>
<pre><span class="VALcursor_target"><span class="keyword">val</span> cursor_target</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=cursor">cursor</a> -&gt; string</code></pre><div class="info"><div class="info">Returns the string of the cursor<br/> Evaluation hints:<ul><li>INLINED
   </li></ul></div></div>
<pre><span class="VALcursor_range"><span class="keyword">val</span> cursor_range</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=cursor">cursor</a> -&gt; int * int</code></pre><div class="info"><div class="info">Returns the valid range of the cursor as pair <code class="code">(range_pos, range_len)</code> <br/> Evaluation hints:<ul><li>INLINED
   </li></ul></div></div>
<pre><span class="VALcursor_initial_rel_pos"><span class="keyword">val</span> cursor_initial_rel_pos</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=cursor">cursor</a> -&gt; int</code></pre><div class="info"><div class="info">Returns the initial relative byte position of the cursor <br/> Evaluation hints:<ul><li>INLINED
   </li></ul></div></div>
<pre><span class="VALcursor_char_count"><span class="keyword">val</span> cursor_char_count</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=cursor">cursor</a> -&gt; int</code></pre><div class="info"><div class="info">Returns the character count of the cursor. The initial position
 (when <code class="code">create_cursor</code> was called) has the number 0, positions to the
 right denote positive numbers, and positions to the left negative numbers.<br/> Evaluation hints:<ul><li>INLINED
   </li></ul></div></div>
<pre><span class="VALcursor_pos"><span class="keyword">val</span> cursor_pos</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=cursor">cursor</a> -&gt; int</code></pre><div class="info"><div class="info">Returns the byte position of the cursor, i.e. the byte index of
 the string that corresponds to the cursor position. The function
 returns the absolute position (i.e. NOT relative to <code class="code">cursor_range</code>).<br/> Evaluation hints:<ul><li>INLINED
   </li></ul></div></div>
<pre><span class="VALuchar_at"><span class="keyword">val</span> uchar_at</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=cursor">cursor</a> -&gt; int</code></pre><div class="info"><div class="info">Returns the Unicode code point of the character at the cursor.
 Raises <code class="code">End_of_string</code> if the cursor is positioned past the last
 character.
 Raises <code class="code">Partial_character</code> if the last character of the analysed 
 string range is an incomplete multi-byte character.
 Raises <code class="code">Byte_order_mark</code> if the first character of the string
 is a BOM (when the encoding has BOMs).<br/> Evaluation hints:<ul><li>INLINED
   </li></ul></div></div>
<pre><span class="VALcursor_byte_length"><span class="keyword">val</span> cursor_byte_length</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=cursor">cursor</a> -&gt; int</code></pre><div class="info"><div class="info">Returns the byte length of the representation of the character at the
 cursor. This works also for incomplete multi-byte characters and
 BOMs.
 Raises <code class="code">End_of_string</code> if the cursor is positioned past the last
 character. <br/> Evaluation hints:<ul><li>INLINED
   </li></ul></div></div>
<pre><span class="VALcursor_at_end"><span class="keyword">val</span> cursor_at_end</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=cursor">cursor</a> -&gt; bool</code></pre><div class="info"><div class="info">Returns whether the cursor is positioned past the last character.<br/> Evaluation hints:<ul><li>INLINED
   </li></ul></div></div>
<pre><span class="VALmove"><span class="keyword">val</span> move</span> : <code class="type">?num:int -&gt; <a href="?package=ocamlnet&amp;module=Netconversion&amp;type=cursor">cursor</a> -&gt; unit</code></pre><div class="info"><div class="info">Moves the cursor one character to the right, or if <code class="code">num</code> is passed,
 this number of characters to the right. <code class="code">num</code> can be negative in
 which case the cursor is moved to the left.<br/> If the cursor were placed outside the valid range, the cursor
 would go into an illegal state, and because of this, this is
 handled as follows: the cursor moves to the
 leftmost or rightmost position (depending on the direction),
 and the exception <code class="code">Cursor_out_of_range</code> is raised.</div></div>
<pre><span class="VALcursor_encoding"><span class="keyword">val</span> cursor_encoding</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=cursor">cursor</a> -&gt; <a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a></code></pre><div class="info"><div class="info">Returns the encoding of the cursor. For some encodings, the
 returned encoding depends on the position of the cursor (see
 the note about UTF-8 in <code class="code">create_cursor</code>)<br/> Evaluation hints:<ul><li>INLINED
   </li></ul></div></div>
<pre><span class="VALcursor_blit"><span class="keyword">val</span> cursor_blit</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=cursor">cursor</a> -&gt; int array -&gt; int -&gt; int -&gt; int</code></pre><div class="info"><div class="info"><code class="code">cursor_blit cs ua pos len</code>: Copies at most <code class="code">len</code> characters as code
 points from
 the cursor position and the following positions to the array <code class="code">ua</code>
 at index <code class="code">pos</code>. The number of copied characters is returned.
 If the cursor is already at the end of the string when this
 function is called, the exception <code class="code">End_of_string</code> will be raised instead,
 and no characters are copied. The cursor positions containing byte
 order marks and partial characters are never copied; this is ensured
 by stopping the copying procedure just before these positions. This
 may even make the function return the number 0.<br/> The function tries to copy as many characters as currently available
 in the already decoded part of the string the cursor is attached to.
 In the current implementation, this number is not higher than 250.
 You can call <code class="code">cursor_blit_maxlen</code> to get an upper limit.<br/> The function does not move the cursor.</div></div>
<pre><span class="VALcursor_blit_maxlen"><span class="keyword">val</span> cursor_blit_maxlen</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=cursor">cursor</a> -&gt; int</code></pre><div class="info"><div class="info">Returns the maximum number of characters <code class="code">cursor_blit</code> can copy
 at the current cursor position. This is the number of characters
 <code class="code">cursor_blit</code> would copy if the <code class="code">len</code> argument were arbitrarily
 large.<br/> Note that the value depends on the cursor position and on the
 contents of the cursor string.<br/> This function raises <code class="code">End_of_string</code> if the cursor is positioned
 at the end of the string.</div></div>
<pre><span class="VALcursor_blit_positions"><span class="keyword">val</span> cursor_blit_positions</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=cursor">cursor</a> -&gt; int array -&gt; int -&gt; int -&gt; int</code></pre><div class="info"><div class="info">Works like <code class="code">cursor_blit</code>, but copies the byte positions of the
 characters into <code class="code">ua</code> instead of the code points.<br/> When called directly after <code class="code">cursor_blit</code> for the same cursor and
 with the same value of <code class="code">len</code>, this function copies as many characters
 and thus returns the same number:<br/> <pre class="codepre"><code class="code">let n1 = cursor_blit     cs ua ua_pos len in
 let n2 = cursor_blit_pos cs pa pa_pos len in
 assert (n1 = n2)</code></pre></div></div>
<div class="info"><div class="info"><h3 id="bom">Byte Order Marks</h3><br/> Because UTF-16 allows both little and big endian, files and other
 permanent representations of UTF-16 text are usually prepended by
 a byte order mark (BOM). There is confusion about the BOM among
 Unicode users, so the following explanations may be helpful.<br/> Of course, the BOM is only used for external representations like
 files, as the endianess is always known for in-memory representations
 by the running program. This module has three encoding identifiers:<ul><li><code class="code">`Enc_utf16</code>: UTF-16 where the endianess is unknown</li><li><code class="code">`Enc_utf16_le</code>: UTF-16 little endian</li><li><code class="code">`Enc_utf16_be</code>: UTF-16 big endian</li></ul> When a file is read, the endianess is unknown at the beginning.
 This is expressed by <code class="code">`Enc_utf16</code>. When the BOM is read, the encoding
 is refined to either <code class="code">`Enc_utf16_le</code> or <code class="code">`Enc_utf16_be</code>, whatever
 the BOM says. This works as follows: The BOM is the representation
 of the code point 0xfeff as little or big endian, i.e. as byte sequences
 &quot;0xfe 0xff&quot; (big endian) or &quot;0xff 0xfe&quot; (little endian). As the &quot;wrong&quot;
 code point 0xfffe is intentionally unused, the reader can determine
 the endianess.<br/> There is one problem, though. Unfortunately, the code point 0xfeff
 is also used for the &quot;zero width non-breakable space&quot; character.
 When this code point occurs later in the text, it is interpreted as
 this character. Of course, this means that one must know whether
 there is a BOM at the beginning, and if not, one must know the
 endianess. One cannot program in the style &quot;well, let's see what is
 coming and guess&quot;.<br/> Furthermore, the BOM is only used for encodings where one can specify
 the endianess. It must not be used for UTF-8, for example, as the
 byte order is fixed for this encoding. When a UTF-8 text begins with
 the code point 0xfeff, it is always the &quot;zero width non-breakable space&quot;
 character.<br/> The functions of this module can all deal with BOMs when reading
 encoded text. In most cases, the BOM is hidden from the caller,
 and just handled automatically. Cursors, however, treat BOMs as special
 characters outside of the code set (exception <code class="code">Byte_order_mark</code> is
 raised). The writing functions of this module do not generate BOMs,
 however, as there is no way to tell them that a BOM is needed. The
 function <code class="code">byte_order_mark</code> can be used to output the BOM manually.<br/> <h3 id="3_TITLE">Examples for Cursors</h3><br/> Create the cursor:<br/> <code class="code"> let cs = create_cursor `Enc_utf8 &quot;B\195\164r&quot;;; </code><br/> The cursor is now positioned at the 'B':<br/> <code class="code"> uchar_at cs </code> <i>returns</i> <code class="code">66</code> (i.e. B)<br/> Move the cursor one character to the right. In UTF-8, this is a
 two-byte character consisting of the bytes 195 and 164:<br/> <code class="code"> move cs ;; </code><br/> <code class="code"> uchar_at cs </code> <i>returns</i> <code class="code">228</code> (i.e. a-Umlaut)<br/> One can easily move the cursor to the end of the string:<br/> <code class="code"> move ~num:max_int cs ;; </code><br/> This raises <code class="code">Cursor_out_of_range</code>, but places the cursor at the end.
 This is the position past the last letter 'r':<br/> <code class="code"> uchar_at cs </code> <i>raises</i> <code class="code">End_of_string</code><br/> Go one character to the left:<br/> <code class="code"> move ~num:(-1) cs ;; </code><br/> <code class="code"> uchar_at cs </code> <i>returns</i> <code class="code">114</code> (i.e. r)<br/> Cursors can only move relative to their current position. Of course,
 one can easily write a function that moves to an absolute position,
 like<br/> <pre class="codepre"><code class="code"> let move_abs n cs = 
    let delta = n - cursor_pos cs in
    move ~num:delta cs </code></pre><br/> However, this operation is expensive (O(string length)), and should
 be avoided for efficient algorithms. Cursors are not arrays, and an
 algorithm should only be based on cursors when it is possible to
 iterate over the characters of the string one after another.</div></div>
<div class="info"><div class="info"><h2 id="unicode_functions">Unicode String Functions</h2></div></div>
<pre><span class="VALustring_length"><span class="keyword">val</span> ustring_length</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; ?range_pos:int -&gt; ?range_len:int -&gt; string -&gt; int</code></pre><div class="info"><div class="info">Returns the length of the string in characters. The function fails
 when illegal byte sequences or incomplete characters are found in the
 string with <code class="code">Malformed_code</code>.<br/> Evaluation hints:<ul><li>PRE_EVAL(encoding)</li></ul><div class="parameters"><div class="param_info"><code class="code">range_pos</code> : The byte position of the substring to measure
   (default: 0)</div><div class="param_info"><code class="code">range_len</code> : The byte length of the substring to measure
   (default: byte length of the input string minus <code class="code">range_pos</code>)</div></div></div></div>
<pre><span class="VALustring_iter"><span class="keyword">val</span> ustring_iter</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt;
(int -&gt; unit) -&gt; ?range_pos:int -&gt; ?range_len:int -&gt; string -&gt; unit</code></pre><div class="info"><div class="info">Iterates over the characters of a string, and calls the passed function
 for every code point. The function raises <code class="code">Malformed_code</code> when
 illegal byte sequences or incomplete characters are found.<div class="parameters"><div class="param_info"><code class="code">encoding</code> : specifies the encoding</div><div class="param_info"><code class="code">range_pos</code> : The byte position of the substring to iterate over
   (default: 0)</div><div class="param_info"><code class="code">range_len</code> : The byte length of the substring to iterate over
   (default: byte length of the input string minus <code class="code">range_pos</code>)</div></div></div></div>
<pre><span class="VALustring_map"><span class="keyword">val</span> ustring_map</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt;
(int -&gt; int list) -&gt; ?range_pos:int -&gt; ?range_len:int -&gt; string -&gt; string</code></pre><div class="info"><div class="info">Maps every character of a string to a list of characters, and returns
 the concatenated string. 
 The <code class="code">encoding</code> argument determines the encoding of both the argument
 and the result string.
 The map function gets every character as its Unicode code point, and
 must return the list of code points to map to.<br/> The function raises <code class="code">Malformed_code</code> when
 illegal byte sequences or incomplete characters are found.<div class="parameters"><div class="param_info"><code class="code">range_pos</code> : The byte position of the substring to map
   (default: 0)</div><div class="param_info"><code class="code">range_len</code> : The byte length of the substring to map
   (default: byte length of the input string minus <code class="code">range_pos</code>)</div></div></div></div>
<pre><span class="VALustring_to_lower"><span class="keyword">val</span> ustring_to_lower</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; ?range_pos:int -&gt; ?range_len:int -&gt; string -&gt; string</code></pre><div class="info"><div class="info">Converts the input string to lowercase.<br/>      The <code class="code">encoding</code>, <code class="code">range_pos</code>, and <code class="code">range_len</code> arguments work
      as for <code class="code">ustring_map</code>. The exception <code class="code">Malformed_code</code> is raised
      when illegal byte sequences are found.</div></div>
<pre><span class="VALustring_to_upper"><span class="keyword">val</span> ustring_to_upper</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; ?range_pos:int -&gt; ?range_len:int -&gt; string -&gt; string</code></pre><div class="info"><div class="info">Converts the input string to uppercase.<br/>      The <code class="code">encoding</code>, <code class="code">range_pos</code>, and <code class="code">range_len</code> arguments work
      as for <code class="code">ustring_map</code>. The exception <code class="code">Malformed_code</code> is raised
      when illegal byte sequences are found.</div></div>
<pre><span class="VALustring_to_title"><span class="keyword">val</span> ustring_to_title</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; ?range_pos:int -&gt; ?range_len:int -&gt; string -&gt; string</code></pre><div class="info"><div class="info">Converts the input string to titlecase.<br/>      The <code class="code">encoding</code>, <code class="code">range_pos</code>, and <code class="code">range_len</code> arguments work
      as for <code class="code">ustring_map</code>. The exception <code class="code">Malformed_code</code> is raised
      when illegal byte sequences are found.</div></div>
<pre><span class="VALustring_sub"><span class="keyword">val</span> ustring_sub</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt;
int -&gt; int -&gt; ?range_pos:int -&gt; ?range_len:int -&gt; string -&gt; string</code></pre><div class="info"><div class="info"><code class="code">ustring_sub enc start length s</code>: Returns the substring of <code class="code">s</code> starting
 at character count <code class="code">start</code> and consisting of <code class="code">length</code> characters. Note
 that <code class="code">start</code> and <code class="code">length</code> select the substring by multiples of
 (usually multibyte) characters, not bytes.<br/> If the optional byte-based <code class="code">range_pos</code> and <code class="code">range_len</code> arguments are
 present, these arguments are taken to determine a first substring
 before <code class="code">start</code> and <code class="code">length</code> are applied to extract the final
 substring.<br/> The function raises <code class="code">Malformed_code</code> when
 illegal byte sequences or incomplete characters are found.<div class="parameters"><div class="param_info"><code class="code">range_pos</code> : The byte position of the substring to extract
   (default: 0)</div><div class="param_info"><code class="code">range_len</code> : The byte length of the substring to extract
   (default: byte length of the input string minus <code class="code">range_pos</code>)</div></div></div></div>
<pre><span class="VALustring_compare"><span class="keyword">val</span> ustring_compare</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt;
(int -&gt; int -&gt; int) -&gt;
?range_pos:int -&gt;
?range_len:int -&gt; string -&gt; ?range_pos:int -&gt; ?range_len:int -&gt; string -&gt; int</code></pre><div class="info"><div class="info">Compares two strings lexicographically. The first argument is the
 encoding of both strings (which must be the same). The second argument
 is the function that compares two Unicode code points. It must return
 0 if both characters are the same, a negative value if the first
 character is the smaller one, and a positive value if the second
 character is the smaller one.<br/> The function raises <code class="code">Malformed_code</code> when
 illegal byte sequences or incomplete characters are found.<div class="parameters"><div class="param_info"><code class="code">range_pos</code> : The byte position of the substring to compare
   (default: 0), referring to the following string argument</div><div class="param_info"><code class="code">range_len</code> : The byte length of the substring to compare
   (default: byte length of the input string minus <code class="code">range_pos</code>),
   referring to the following string argument</div></div></div></div>
<pre><span class="VALcode_cmp"><span class="keyword">val</span> code_cmp</span> : <code class="type">int -&gt; int -&gt; int</code></pre><div class="info"><div class="info">A compare function for <code class="code">ustring_compare</code>: Normal string comparison:
      This function compares by code point</div></div>
<pre><span class="VALci_code_cmp"><span class="keyword">val</span> ci_code_cmp</span> : <code class="type">int -&gt; int -&gt; int</code></pre><div class="info"><div class="info">A compare function for <code class="code">ustring_compare</code>: Case-insensitive comparison:
      This function compares by the lowercase code point if it exists, 
      and the untransformed code point otherwise.<br/>      NB. This bases on the lowercase transformation that maps one char
      to only one char, and not to many.</div></div>
<pre><span class="VALuarray_of_ustring"><span class="keyword">val</span> uarray_of_ustring</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; ?range_pos:int -&gt; ?range_len:int -&gt; string -&gt; int array</code></pre><div class="info"><div class="info">Returns the characters of the string as array of Unicode code points.<div class="parameters"><div class="param_info"><code class="code">range_pos</code> : The byte position of the substring to extract
   (default: 0)</div><div class="param_info"><code class="code">range_len</code> : The byte length of the substring to extract
   (default: byte length of the input string minus <code class="code">range_pos</code>)</div></div></div></div>
<pre><span class="VALustring_of_uarray"><span class="keyword">val</span> ustring_of_uarray</span> : <code class="type">?subst:(int -&gt; string) -&gt;
<a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; ?pos:int -&gt; ?len:int -&gt; int array -&gt; string</code></pre><div class="info"><div class="info">Returns the array of Unicode code points as encoded string.<div class="parameters"><div class="param_info"><code class="code">pos</code> : Selects a subarray: <code class="code">pos</code> is the first array position
   to encode (default: 0)</div><div class="param_info"><code class="code">len</code> : Selects a subarray: <code class="code">len</code> is the length of the subarray
   to encode (default: array length minus <code class="code">pos</code>)</div><div class="param_info"><code class="code">subst</code> : This function is called when a code point cannot be represented
   in the chosen character encoding. It must returns the (already encoded)
   string to substitute for this code point. By default (if ~subst is
   not passed), the exception <code class="code">Cannot_represent</code> will be raised in this
   case.</div></div></div></div>
<pre><span class="EXCEPTIONMalformed_code_at"><span class="keyword">exception</span> Malformed_code_at</span> <span class="keyword">of</span> <code class="type">int</code></pre><div class="info"><div class="info">An illegal byte sequence is found at this byte position</div></div>
<pre><span class="VALverify"><span class="keyword">val</span> verify</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt; ?range_pos:int -&gt; ?range_len:int -&gt; string -&gt; unit</code></pre><div class="info"><div class="info">Checks whether the string is properly encoded. If so, () is returned.
 If not, the exception <code class="code">Malformed_code_at</code> will be raised indicating 
 the byte position where the problem occurs.<div class="parameters"><div class="param_info"><code class="code">range_pos</code> : The byte position of the substring to verify
   (default: 0)</div><div class="param_info"><code class="code">range_len</code> : The byte length of the substring to verify
   (default: byte length of the input string minus <code class="code">range_pos</code>)</div></div></div></div>
<pre><span class="VALbig_slice"><span class="keyword">val</span> big_slice</span> : <code class="type">int</code></pre>
<pre><span class="VALread_iso88591_ref"><span class="keyword">val</span> read_iso88591_ref</span> : <code class="type">(int -&gt;
 <a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a> -&gt;
 int array -&gt; int array -&gt; string -&gt; int -&gt; int -&gt; int * int * <a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a>)
<a href="?package=ocaml&amp;module=Pervasives&amp;type=ref">Pervasives.ref</a></code></pre>
<pre><span class="VALread_utf8_ref"><span class="keyword">val</span> read_utf8_ref</span> : <code class="type">(bool -&gt;
 int array -&gt; int array -&gt; string -&gt; int -&gt; int -&gt; int * int * <a href="?package=ocamlnet&amp;module=Netconversion&amp;type=encoding">encoding</a>)
<a href="?package=ocaml&amp;module=Pervasives&amp;type=ref">Pervasives.ref</a></code></pre>
</div>