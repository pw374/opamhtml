<div class="ocaml_toplevel_module"><div class="info"><h1 id="1_TITLE">The protocol kernel of the HTTP daemon</h1><p> This module mainly defines the <code class="code">http_protocol</code> class which implements the
 exchange of messages with a HTTP client. The request messages are represented
 as sequence of <code class="code">req_token</code> values. The response is encapsulated in a separate
 <code class="code">http_response</code> class. The contents of the response are represented as sequence
 of <code class="code">resp_token</code> values.</p></div>
<pre><span class="TYPEfatal_error"><span class="keyword">type</span> fatal_error</span> = <code class="type">[ `Broken_pipe
| `Broken_pipe_ignore
| `Message_too_long
| `Server_error
| `Timeout
| `Unix_error of <a href="?package=ocaml&amp;module=Unix&amp;type=error">Unix.error</a> ]</code></pre><div class="info"><div class="info">These are the serious protocol violations after that the daemon stops
 any further processing.<p> Note that <code class="code">`Timeout</code> refers to a timeout in the middle of a request.
 <code class="code">`Broken_pipe_ignore</code> is the &quot;harmless&quot; version of <code class="code">`Broken_pipe</code>
 (see <code class="code">config_suppress_broken_pipe</code>).</p><p> Long messages are fatal because it is suspected that they are denial
 of service attacks. The kernel generates <code class="code">`Message_too_long</code> only for
 long headers, not for long bodies.</p><p> Fatal server errors can happen when exceptions are not properly handled.
 As last resort the HTTP daemon closes the connection without notifying
 the client.</p></div></div>
<pre><span class="VALstring_of_fatal_error"><span class="keyword">val</span> string_of_fatal_error</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=fatal_error">fatal_error</a> -&gt; string</code></pre><div class="info"><div class="info">Convert error to a string, for logging</div></div>
<pre><span class="TYPEbad_request_error"><span class="keyword">type</span> bad_request_error</span> = <code class="type">[ `Bad_header
| `Bad_header_field of string
| `Bad_request_line
| `Bad_trailer
| `Format_error of string
| `Protocol_not_supported
| `Request_line_too_long
| `Unexpected_eof ]</code></pre><div class="info"><div class="info">A bad request is a violation where the current request cannot be
 decoded, and it is not possible to accept further requests over the
 current connection.</div></div>
<pre><span class="VALstring_of_bad_request_error"><span class="keyword">val</span> string_of_bad_request_error</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=bad_request_error">bad_request_error</a> -&gt; string</code></pre><div class="info"><div class="info">Convert error to a string, for logging</div></div>
<pre><span class="VALstatus_of_bad_request_error"><span class="keyword">val</span> status_of_bad_request_error</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=bad_request_error">bad_request_error</a> -&gt; <a href="?package=ocamlnet&amp;module=Nethttp&amp;type=http_status">Nethttp.http_status</a></code></pre><div class="info"><div class="info">Returns the best response code for the error</div></div>
<pre><span class="TYPEdata_chunk"><span class="keyword">type</span> data_chunk</span> = <code class="type">string * int * int</code></pre><div class="info"><div class="info">A <code class="code">data_chunk</code> is a substring of a string. The substring is described by
 the triple <code class="code">(s, pos, len)</code> where <code class="code">s</code> is the container, <code class="code">pos</code> is the
 position where the substring begins, and <code class="code">len</code> its length.</div></div>
<pre><span class="TYPEstatus_line"><span class="keyword">type</span> status_line</span> = <code class="type">int * string</code></pre><div class="info"><div class="info">= (code, phrase)</div></div>
<pre><span class="TYPEtransfer_coding"><span class="keyword">type</span> transfer_coding</span> = <code class="type">[ `Chunked | `Identity ]</code></pre>
<pre><span class="TYPEresp_token"><span class="keyword">type</span> resp_token</span> = <code class="type">[ `Resp_action of unit -&gt; unit
| `Resp_body of <a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=data_chunk">data_chunk</a>
| `Resp_end
| `Resp_header of <a href="?package=ocamlnet&amp;module=Nethttp&amp;type=http_header">Nethttp.http_header</a>
| `Resp_info_line of <a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=status_line">status_line</a> * <a href="?package=ocamlnet&amp;module=Nethttp&amp;type=http_header">Nethttp.http_header</a>
| `Resp_status_line of <a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=status_line">status_line</a>
| `Resp_trailer of <a href="?package=ocamlnet&amp;module=Nethttp&amp;type=http_trailer">Nethttp.http_trailer</a> ]</code></pre><div class="info"><div class="info">The <code class="code">resp_token</code> represents a textual part of the response to send:<ul><li><code class="code">`Resp_info_line</code> is an informational status line (code=100..199). There can
   be several informational lines, and they can be accompanied with their own
   headers. Such lines are only sent to HTTP/1.1 clients.</li><li><code class="code">`Resp_status_line</code> is the final status line to send (code &gt;= 200)</li><li><code class="code">`Resp_header</code> is the whole response header to send</li><li><code class="code">`Resp_body</code> is the next part of the response body to send.</li><li><code class="code">`Resp_trailer</code> is the whole response trailer to send (currently ignored)</li><li><code class="code">`Resp_action</code> is special because it does not directly represent a token
   to send. The argument is a function which is called when the token is
   the next token on the active event queue. The function is also called when
   the event queue is dropped because of an error (the state of the
   response object indicates this). The function must not raise exceptions
   except <code class="code">Unix_error</code>, and it must not block.
     </li></ul></div></div>
<pre><span class="VALresp_100_continue"><span class="keyword">val</span> resp_100_continue</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=resp_token">resp_token</a></code></pre><div class="info"><div class="info">The predefined token for the &quot;100 Continue&quot; response</div></div>
<pre><span class="TYPEresp_state"><span class="keyword">type</span> resp_state</span> = <code class="type">[ `Active | `Dropped | `Error | `Inhibited | `Processed | `Queued ]</code></pre><div class="info"><div class="info">The response state:<ul><li><code class="code">`Inhibited</code> = it is not yet allowed to start the response</li><li><code class="code">`Queued</code> = the response waits on the queue for activation</li><li><code class="code">`Active</code> = the response is currently being transmitted</li><li><code class="code">`Processed</code> = the response has been completely sent</li><li><code class="code">`Error</code> = an error occurred during the transmission of this response</li><li><code class="code">`Dropped</code> = an earlier response forced to close the connection, and
   this response is dequeued
     </li></ul></div></div>
<pre><span class="TYPEfront_token"><span class="keyword">type</span> front_token</span> = <code class="type">[ `Resp_end | `Resp_wire_data of <a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=data_chunk">data_chunk</a> ]</code></pre><div class="info"><div class="info">Tokens generated by <code class="code">http_response</code>:<ul><li><code class="code">`Resp_wire_data</code> are data tokens.</li><li><code class="code">`Resp_end</code> indicates the end of the response.
    </li></ul></div></div>
<pre><span class="EXCEPTIONSend_queue_empty"><span class="keyword">exception</span> Send_queue_empty</span></pre>
<pre><span class="TYPEannouncement"><span class="keyword">type</span> announcement</span> = <code class="type">[ `As of string | `Ignore | `Ocamlnet | `Ocamlnet_and of string ]</code></pre><div class="info"><div class="info">See config</div></div>
<div class="ocaml_class sig" name="http_response"><pre><span class="TYPEhttp_response"><span class="keyword">class type</span> <a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;class=http_response">http_response</a></span> : <code class="code">object</code> .. <code class="code">end</code></pre><div class="info"><div class="info">Encapsultation of the HTTP response for a single request</div></div><div class="ocaml_class_content"><div class="info"><div class="info">Represents the action of sending the response<p> This class has an internal
 queue of response tokens that are not yet processed. One can easily add
 new tokens to the end of the queue (<code class="code">send</code>). </p><p> The class is responsible for determining the transfer encoding:</p><ul><li>When the HTTP version is 1.0, the encoding is always &quot;identity&quot;, and the
   connection will be closed after the response.</li><li>When the HTTP version is 1.1, and there is a Content-length header,
   the encoding will be selected as &quot;identity&quot;. It is checked whether the
   body has really this length. If too short, it is suggested to close
   the connection. If too long, the extra part of the message is silently
   dropped.</li><li>When the HTTP version is 1.1, and there is no Content-length header,
   the encoding will be selected as &quot;chunked&quot;.</li></ul> Currently, the <code class="code">TE</code> request header is not taken into account. The trailer
 is always empty.<p> The following headers are set (or removed) by this class:</p><ul><li><code class="code">Transfer-Encoding</code></li><li><code class="code">Trailer</code></li><li><code class="code">Date</code></li><li><code class="code">Connection</code></li><li><code class="code">Upgrade</code></li><li><code class="code">Server</code> (it is appended to this field)</li></ul> Responses for HEAD requests have the special behaviour that the body is silently
 dropped. The calculation of header fields is not affected by this. This means
 that HEAD can be easily implemented by doing the same as for GET.<p> Responses for other requests that must not include a body must set
 <code class="code">Content-Length</code> to 0.</p></div></div>
<div class="info"><div class="info">These methods can be called by the content provider:</div></div>
<pre><span class="METHODstate"><span class="keyword">method</span> state</span> : <code class="code"><a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=resp_state">resp_state</a></code></pre>
<div class="info"><div class="info">Reports the state. The initial state is <code class="code">`Inhibited</code></div></div>
<pre><span class="METHODbidirectional_phase"><span class="keyword">method</span> bidirectional_phase</span> : <code class="code">bool</code></pre>
<div class="info"><div class="info">The bidrectional phase starts after &quot;100 Continue&quot; has been sent to the
 client, and stops when the response body begins. The bidirectional phase
 is special for the calculation of timeout values (input determines the timeout
 although the response has started).</div></div>
<pre><span class="METHODsend"><span class="keyword">method</span> send</span> : <code class="code"><a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=resp_token">resp_token</a> -&gt; unit</code></pre>
<div class="info"><div class="info">Add token to the end of the send queue</div></div>
<pre><span class="METHODsend_queue_empty"><span class="keyword">method</span> send_queue_empty</span> : <code class="code">bool</code></pre>
<div class="info"><div class="info">Return whether the send queue is empty. When the state is <code class="code">`Inhibited</code>, this
 method fakes an empty queue.</div></div>
<pre><span class="METHODprotocol"><span class="keyword">method</span> protocol</span> : <code class="code"><a href="?package=ocamlnet&amp;module=Nethttp&amp;type=protocol">Nethttp.protocol</a></code></pre>
<div class="info"><div class="info">The HTTP version of the response. This is currently always HTTP/1.1, but maybe
 we need to fake lower versions for buggy clients. Let's see what comes.</div></div>
<pre><span class="METHODclose_connection"><span class="keyword">method</span> close_connection</span> : <code class="code">bool</code></pre>
<div class="info"><div class="info">Returns whether the connection should be closed after this response.
 This flag should be evaluated when the <code class="code">`Resp_end</code> front token has been
 reached.</div></div>
<pre><span class="METHODtransfer_encoding"><span class="keyword">method</span> transfer_encoding</span> : <code class="code"><a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=transfer_coding">transfer_coding</a></code></pre>
<div class="info"><div class="info">Returns the selected transfer encoding. This is valid after the header
 has been passed to this object with <code class="code">send</code>.</div></div>
<pre><span class="METHODfront_token"><span class="keyword">method</span> front_token</span> : <code class="code"><a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=front_token">front_token</a></code></pre>
<div class="info"><div class="info">The first token of the queue, represented as <code class="code">data_chunk</code>. Raises 
 <code class="code">Send_queue_empty</code> when there is currently no front token, or the state
 is <code class="code">`Inhibited</code>.
 If there is a front token, it will never have length 0.<p> Note that <code class="code">Unix_error</code> exceptions can be raised when <code class="code">`Resp_action</code>
 tokens are processed.</p></div></div>
<pre><span class="METHODset_callback"><span class="keyword">method</span> set_callback</span> : <code class="code">(unit -&gt; unit) -&gt; unit</code></pre>
<div class="info"><div class="info">The function will be called when either <code class="code">set_state</code> changes the state,
 or when the send queue becomes empty. Note that the callback must never
 fail, it is called in situations that make it hard to recover from errors.</div></div>
<pre><span class="METHODbody_size"><span class="keyword">method</span> body_size</span> : <code class="code">int64</code></pre>
<div class="info"><div class="info">Accumulated size of the response body</div></div>
<div class="info"><div class="info">These methods must only be called by the HTTP protocol processor:</div></div>
<pre><span class="METHODset_state"><span class="keyword">method</span> set_state</span> : <code class="code"><a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=resp_state">resp_state</a> -&gt; unit</code></pre>
<div class="info"><div class="info">Sets the state</div></div>
<pre><span class="METHODadvance"><span class="keyword">method</span> advance</span> : <code class="code">int -&gt; unit</code></pre>
<div class="info"><div class="info">Tell this object that <code class="code">n</code> bytes of the front token could be really
 sent using <code class="code">Unix.write</code>. If this means that the whole front token
 has been sent, the next token is pulled from the queue and is made
 the new front token. Otherwise, the data chunk representing the
 front token is modified such that the position is advanced by
 <code class="code">n</code>, and the length is reduced by <code class="code">n</code>.</div></div></div></div>
<div class="ocaml_class ident" name="http_response_impl" path="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;class=http_response"><pre><span class="TYPEhttp_response_impl"><span class="keyword">class</span> <a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;class=http_response_impl">http_response_impl</a></span> : <code class="type">bool option -&gt; bool option -&gt; int64 -&gt; <a href="?package=ocamlnet&amp;module=Nethttp&amp;type=protocol">Nethttp.protocol</a> -&gt; <a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=announcement">announcement</a> -&gt; </code><a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;class=http_response">http_response</a></pre><div class="info"><div class="info">Exported for debugging and testing only</div></div></div>
<pre><span class="VALsend_static_response"><span class="keyword">val</span> send_static_response</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=http_response">http_response</a> -&gt;
<a href="?package=ocamlnet&amp;module=Nethttp&amp;type=http_status">Nethttp.http_status</a> -&gt; <a href="?package=ocamlnet&amp;module=Nethttp&amp;type=http_header">Nethttp.http_header</a> option -&gt; string -&gt; unit</code></pre><div class="info"><div class="info">Sends the string argument as response body, together with the given status and
 the header (optional). Response header fields are set as follows:<ul><li>The <code class="code">Content-Length</code> is set to the length of the string.</li><li>The <code class="code">Content-Type</code> is set to &quot;text/html&quot; unless given by the header.
 If the header object is passed in, these modifications are done 
 directly in this object as side effect.
   </li></ul></div></div>
<pre><span class="VALsend_file_response"><span class="keyword">val</span> send_file_response</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=http_response">http_response</a> -&gt;
<a href="?package=ocamlnet&amp;module=Nethttp&amp;type=http_status">Nethttp.http_status</a> -&gt;
<a href="?package=ocamlnet&amp;module=Nethttp&amp;type=http_header">Nethttp.http_header</a> option -&gt; <a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; int64 -&gt; unit</code></pre><div class="info"><div class="info">Sends the contents of a file as response body, together with the given status and
 the header (optional). The descriptor must be a file descriptor (that cannot
 block). The int64 number is the length
 of the body.  Response header fields are set as follows:<ul><li>The <code class="code">Content-Length</code> is set to the length of the string.</li><li>The <code class="code">Content-Type</code> is set to &quot;text/html&quot; unless given by the header.</li></ul> Note that <code class="code">Content-Range</code> is not set automatically, even if the file is only
 partially transferred.<p> If the header object is passed in, these modifications are done 
 directly in this object as side effect.</p><p> The function does not send the file immediately, but rather sets the <code class="code">http_response</code>
 object up that the next chunk of the file is added when the send queue becomes
 empty. This file will be closed when the transfer is done.</p></div></div>
<pre><span class="TYPErequest_line"><span class="keyword">type</span> request_line</span> = <code class="type"><a href="?package=ocamlnet&amp;module=Nethttp&amp;type=http_method">Nethttp.http_method</a> * <a href="?package=ocamlnet&amp;module=Nethttp&amp;type=protocol">Nethttp.protocol</a></code></pre><div class="info"><div class="info">The method (including the URI), and the HTTP version</div></div>
<pre><span class="TYPEreq_token"><span class="keyword">type</span> req_token</span> = <code class="type">[ `Bad_request_error of <a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=bad_request_error">bad_request_error</a> * <a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=http_response">http_response</a>
| `Eof
| `Fatal_error of <a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=fatal_error">fatal_error</a>
| `Req_body of <a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=data_chunk">data_chunk</a>
| `Req_end
| `Req_expect_100_continue
| `Req_header of <a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=request_line">request_line</a> * <a href="?package=ocamlnet&amp;module=Nethttp&amp;type=http_header">Nethttp.http_header</a> * <a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=http_response">http_response</a>
| `Req_trailer of <a href="?package=ocamlnet&amp;module=Nethttp&amp;type=http_trailer">Nethttp.http_trailer</a>
| `Timeout ]</code></pre><div class="info"><div class="info">A <code class="code">req_token</code> represents a textual part of the received request:<ul><li><code class="code">`Req_header</code> is the full received header. Together with the header,
   the corresponding <code class="code">http_response</code> object is returned which must
   be used to transmit the response.</li><li><code class="code">`Req_expect_100_continue</code> is generated when the client expects that the
   server sends a &quot;100 Continue&quot; response (or a final status code) now.
   One should add <code class="code">`Resp_info_line resp_100_continue</code> to the send queue
   if the header is acceptable, or otherwise generate an error response. In any
   case, the rest of the request must be read until <code class="code">`Req_end</code>.</li><li><code class="code">`Req_body</code> is a part of the request body. The transfer-coding, if any,
   is already decoded.</li><li><code class="code">`Req_trailer</code> is the received trailer</li><li><code class="code">`Req_end</code> indicates the end of the request (the next request may begin
   immediately).</li><li><code class="code">`Eof</code> indicates the end of the stream</li><li><code class="code">`Bad_request_error</code> indicates that the request violated the HTTP protocol
   in a serious way and cannot be decoded. It is required to send a 
   &quot;400 Bad Request&quot; response. The following token will be <code class="code">`Eof</code>.</li><li><code class="code">`Fatal_error</code> indicates that the connection crashed. 
   The following token will be <code class="code">`Eof</code>.</li><li><code class="code">`Timeout</code> means that nothing has been received for a certain amount
   of time, and the protocol is in a state that the next request can begin.
   The following token will be <code class="code">`Eof</code>.</li></ul> Note that it is always allowed to <code class="code">send</code> tokens to the client. The protocol
 implementation takes care that the response is transmitted at the right point
 in time.</div></div>
<pre><span class="VALstring_of_req_token"><span class="keyword">val</span> string_of_req_token</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=req_token">req_token</a> -&gt; string</code></pre><div class="info"><div class="info">For debugging</div></div>
<pre><span class="EXCEPTIONRecv_queue_empty"><span class="keyword">exception</span> Recv_queue_empty</span></pre>
<div class="ocaml_class sig" name="http_protocol_config"><pre><span class="TYPEhttp_protocol_config"><span class="keyword">class type</span> <a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;class=http_protocol_config">http_protocol_config</a></span> : <code class="code">object</code> .. <code class="code">end</code></pre><div class="info"><div class="info">Configuration values for the HTTP kernel</div></div><div class="ocaml_class_content"><pre><span class="METHODconfig_max_reqline_length"><span class="keyword">method</span> config_max_reqline_length</span> : <code class="code">int</code></pre>
<div class="info"><div class="info">Maximum size of the request line. Longer lines are immediately replied with
 a &quot;Request URI too long&quot; response. Suggestion: 32768.</div></div>
<pre><span class="METHODconfig_max_header_length"><span class="keyword">method</span> config_max_header_length</span> : <code class="code">int</code></pre>
<div class="info"><div class="info">Maximum size of the header, <b>including</b> the request line. Longer headers
 are treated as attack, and cause the fatal error <code class="code">`Message_too_long</code>.
 Suggestion: 65536.</div></div>
<pre><span class="METHODconfig_max_trailer_length"><span class="keyword">method</span> config_max_trailer_length</span> : <code class="code">int</code></pre>
<div class="info"><div class="info">Maximum size of the trailer</div></div>
<pre><span class="METHODconfig_limit_pipeline_length"><span class="keyword">method</span> config_limit_pipeline_length</span> : <code class="code">int</code></pre>
<div class="info"><div class="info">Limits the length of the pipeline (= unreplied requests). A value of 0
 disables pipelining. A value of n allows that another request is
 received although there are already n unreplied requests.</div></div>
<pre><span class="METHODconfig_limit_pipeline_size"><span class="keyword">method</span> config_limit_pipeline_size</span> : <code class="code">int</code></pre>
<div class="info"><div class="info">Limits the size of the pipeline in bytes. If the buffered bytes in the
 input queue exceed this value, the receiver temporarily stops reading
 more data. The value 0 has the effect that even the read-ahead of
 data of the current request is disabled. The value (-1) disables the
 receiver completely (not recommended).</div></div>
<pre><span class="METHODconfig_announce_server"><span class="keyword">method</span> config_announce_server</span> : <code class="code"><a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=announcement">announcement</a></code></pre>
<div class="info"><div class="info">Whether to set the <code class="code">Server</code> header:<ul><li><code class="code">`Ignore</code>: The kernel does not touch the <code class="code">Server</code> header.</li><li><code class="code">`Ocamlnet</code>: Announce this web server as &quot;Ocamlnet/&lt;version&gt;&quot;</li><li><code class="code">`Ocamlnet_and s</code>: Announce this web server as <code class="code">s</code> and append
   the Ocamlnet string.</li><li><code class="code">`As s</code>: Announce this web server as <code class="code">s</code>
     </li></ul></div></div>
<pre><span class="METHODconfig_suppress_broken_pipe"><span class="keyword">method</span> config_suppress_broken_pipe</span> : <code class="code">bool</code></pre>
<div class="info"><div class="info">Whether to suppress <code class="code">`Broken_pipe</code> errors. Instead 
 <code class="code">`Broken_pipe_ignore</code> is reported.</div></div></div></div>
<pre><span class="VALdefault_http_protocol_config"><span class="keyword">val</span> default_http_protocol_config</span> : <code class="type"><a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=http_protocol_config">http_protocol_config</a></code></pre><div class="info"><div class="info">Default config:<ul><li><code class="code">config_max_reqline_length = 32768</code></li><li><code class="code">config_max_header_length = 65536</code></li><li><code class="code">config_max_trailer_length = 32768</code></li><li><code class="code">config_limit_pipeline_length = 5</code></li><li><code class="code">config_limit_pipeline_size = 65536</code></li><li><code class="code">config_announce_server = `Ocamlnet</code></li><li><code class="code">config_suppress_broken_pipe = false</code>
   </li></ul></div></div>
<div class="ocaml_class ident" name="modify_http_protocol_config" path="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;class=http_protocol_config"><pre><span class="TYPEmodify_http_protocol_config"><span class="keyword">class</span> <a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;class=modify_http_protocol_config">modify_http_protocol_config</a></span> : <code class="type">int option -&gt; int option -&gt; int option -&gt; int option -&gt; int option -&gt; <a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=announcement">announcement</a> option -&gt; bool option -&gt; <a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=http_protocol_config">http_protocol_config</a> -&gt; </code><a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;class=http_protocol_config">http_protocol_config</a></pre><div class="info"><div class="info">Modifies the passed config object as specified by the optional
      arguments</div></div></div>
<div class="ocaml_class sig" name="http_protocol"><pre><span class="TYPEhttp_protocol"><span class="keyword">class</span> <a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;class=http_protocol">http_protocol</a></span> : <code class="type"><a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; #<a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;class=http_protocol_config">http_protocol_config</a> -&gt; </code><code class="code">object</code> .. <code class="code">end</code></pre><div class="info"><div class="info">The core event loop of the HTTP daemon</div></div><div class="ocaml_class_content"><div class="info"><div class="info">Exchange of HTTP messages<p> In <code class="code">fd</code> one must pass the already connected socket. It must be in non-
 blocking mode.</p><p> How to use this class: Basically, one invokes <code class="code">cycle</code> until the whole
 message exchange on <code class="code">fd</code> is processed. <code class="code">cycle</code> receives data from the
 socket and sends data to the socket. There are two internal queues:</p><p> The receive queue stores parts of received requests as <code class="code">req_token</code>.
 One can take values from the front of this queue by calling <code class="code">receive</code>.</p><p> The response queue stores <code class="code">http_response</code> objects. Each of the objects
 corresponds to a request that was received before. This queue is handled
 fully automatically, but one can watch its length to see whether all responses
 are actually transmitted over the wire.</p><p> The basic algorithm to process messages is:</p><p> </p><code class="code">
 let rec next_token () =
   if proto # recv_queue_len = 0 then (
     proto # cycle ();
     next_token()
   )
   else
     proto # receive()

 let cur_token = ref (next_token()) in
 while !cur_token &lt;&gt; `Eof do
   (* Process first token of next request: *)
   match !cur_token with
    | `Req_header(req_line, header, resp) -&gt;
         (* Depending on [req_line], read further tokens until [`Req_end] *)
         ...
         (* Switch to the first token of the next message: *)
         cur_token := next_token()
    | `Timeout -&gt; ...
    | `Bad_request_error(e,resp) -&gt; 
          (* Generate 400 error, send it to [resp] *)
          ...
          (* Switch to the first token of the next message: *)
          cur_token := next_token()
    | `Fatal_error e -&gt; failwith &quot;Crash&quot;
    | _ -&gt; assert false
 done;
 while proto # resp_queue_len &gt; 0 do
   proto # cycle ();
 done;
 proto # shutdown()
 </code><p> See the file <code class="code">tests/easy_daemon.ml</code> for a complete implementation of this.</p><p> As one can see, it is essential to watch the lengths of the queues in order
 to figure out what has happened during <code class="code">cycle</code>.</p><p> When the body of the request is empty, <code class="code">`Req_body</code> tokens are omitted.
 Note that for requests like <code class="code">GET</code> that always have an empty body, it is
 still possible that an errorneous client sends a body, and that <code class="code">`Req_body</code>
 tokens arrive. One must accept and ignore these tokens.</p><p> Error handling: For serious errors, the connection is immediately aborted.
 In this case, <code class="code">receive</code> returns a <code class="code">`Fatal_error</code> token. Note that the
 queued responses cannot be sent! An example of this is <code class="code">`Broken_pipe</code>.</p><p> There is a large class of non-serious errors, esp. format errors
 in the header and body. It is typical of these errors that one cannot determine
 the end of the request properly. For this reason, the daemon stops reading
 further data from the request, but the response queue is still delivered.
 For these errors, <code class="code">receive</code> returns a <code class="code">`Bad_request_error</code> token.
 This token contains a <code class="code">http_response</code> object that must be filled with a
 400 error response.</p></div></div>
<pre><span class="METHODcycle"><span class="keyword">method</span> cycle</span> : <code class="code">?block:float -&gt; unit -&gt; unit</code></pre>
<div class="info"><div class="info">Looks at the file descriptor. If there is data to read from the descriptor,
 and there is free space in the input buffer, additional data is read into
 the buffer. It is also tried to interpret the new data as <code class="code">req_token</code>s,
 and if possible, new <code class="code">req_token</code>s are appended to the receive queue.<p> If the response queue has objects, and there is really data one can send,
 and if the socket allows one to send data, it is tried to send as much
 data as possible.</p><p> The option <code class="code">block</code> (default: 0) can be set to wait until data
 can be exchanged with the socket. This avoids busy waiting. The number
 is the duration in seconds to wait until the connection times out
 (0 means not to wait at all, -1 means to wait infinitely). When a timeout
 happens, and there is nothing to send, and the last request was fully
 processed, <code class="code">receive</code> will simply return <code class="code">`Timeout</code> (i.e. when 
 <code class="code">waiting_for_next_message</code> is <code class="code">true</code>). Otherwise, the
 fatal error <code class="code">`Timeout</code> is generated.</p></div></div>
<pre><span class="METHODreceive"><span class="keyword">method</span> receive</span> : <code class="code">unit -&gt; <a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=req_token">req_token</a></code></pre>
<div class="info"><div class="info">Returns the first <code class="code">req_token</code> from the receive queue. Raises
 <code class="code">Recv_queue_empty</code> when the queue is empty (= has no new data)</div></div>
<pre><span class="METHODpeek_recv"><span class="keyword">method</span> peek_recv</span> : <code class="code">unit -&gt; <a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=req_token">req_token</a></code></pre>
<div class="info"><div class="info">Peeks the first token, but leaves it in the queue.
 Raises <code class="code">Recv_queue_empty</code> when the queue is empty.</div></div>
<pre><span class="METHODrecv_queue_len"><span class="keyword">method</span> recv_queue_len</span> : <code class="code">int</code></pre>
<div class="info"><div class="info">Returns the length of the receive queue (number of tokens)</div></div>
<pre><span class="METHODresp_queue_len"><span class="keyword">method</span> resp_queue_len</span> : <code class="code">int</code></pre>
<div class="info"><div class="info">Returns the length of the internal response queue (number of <code class="code">http_response</code>
 objects that have not yet fully processed)</div></div>
<pre><span class="METHODpipeline_len"><span class="keyword">method</span> pipeline_len</span> : <code class="code">int</code></pre>
<div class="info"><div class="info">Returns the number of unanswered requests = Number of received <code class="code">`Req_end</code> tokens
 minus number of responses in state <code class="code">`Processed</code>. Note that <code class="code">pipeline_len</code>
 can become <code class="code">-1</code> when bad requests are responded.</div></div>
<pre><span class="METHODrecv_queue_byte_size"><span class="keyword">method</span> recv_queue_byte_size</span> : <code class="code">int</code></pre>
<div class="info"><div class="info">Returns the (estimated) size of the input queue in bytes</div></div>
<pre><span class="METHODwaiting_for_next_message"><span class="keyword">method</span> waiting_for_next_message</span> : <code class="code">bool</code></pre>
<div class="info"><div class="info">Whether the kernel is currently waiting for the beginning of a new
 arriving HTTP request. This is <code class="code">false</code> while the request is being
 received.</div></div>
<pre><span class="METHODinput_timeout_class"><span class="keyword">method</span> input_timeout_class</span> : <code class="code">[ `Next_message | `None | `Normal ]</code></pre>
<div class="info"><div class="info">Suggests the calculation of a timeout value for input:<ul><li><code class="code">`Normal</code>: The normal timeout value applies</li><li><code class="code">`Next_message</code>: The timeout value applies while waiting for the next message</li><li><code class="code">`None</code>: The connection is output-driven, no input timeout value
     </li></ul></div></div>
<pre><span class="METHODshutdown"><span class="keyword">method</span> shutdown</span> : <code class="code">unit -&gt; unit</code></pre>
<div class="info"><div class="info">Shuts the socket down. Note: the descriptor is not closed.</div></div>
<pre><span class="METHODtimeout"><span class="keyword">method</span> timeout</span> : <code class="code">unit -&gt; unit</code></pre>
<div class="info"><div class="info">Process a timeout condition as <code class="code">cycle</code> does</div></div>
<pre><span class="METHODabort"><span class="keyword">method</span> abort</span> : <code class="code"><a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=fatal_error">fatal_error</a> -&gt; unit</code></pre>
<div class="info"><div class="info">Stops the transmission of data. The receive queue is cleared and filled
 with the two tokens <code class="code">`Fatal_error</code> and <code class="code">`Eof</code>. 
 The response queue is cleared. The <code class="code">cycle</code>
 method will return immediately without doing anything.</div></div>
<pre><span class="METHODfd"><span class="keyword">method</span> fd</span> : <code class="code"><a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a></code></pre>
<div class="info"><div class="info">Just returns the socket</div></div>
<pre><span class="METHODdo_input"><span class="keyword">method</span> do_input</span> : <code class="code">bool</code></pre>
<div class="info"><div class="info">Returns <code class="code">true</code> iff the protocol engine is interested in new data from the
 socket. Returns <code class="code">false</code> after EOF and after errors.</div></div>
<pre><span class="METHODdo_output"><span class="keyword">method</span> do_output</span> : <code class="code">bool</code></pre>
<div class="info"><div class="info">Returns <code class="code">true</code> iff the protocol engine has data to output to the socket</div></div>
<pre><span class="METHODneed_linger"><span class="keyword">method</span> need_linger</span> : <code class="code">bool</code></pre>
<div class="info"><div class="info">Returns <code class="code">true</code> when a lingering close operation is needed to reliably shut
 down the socket. In many cases, this expensive operation is not necessary.
 See the class <code class="code">lingering_close</code> below.</div></div>
<pre><span class="METHODconfig"><span class="keyword">method</span> config</span> : <code class="code"><a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;type=http_protocol_config">http_protocol_config</a></code></pre>
<div class="info"><div class="info">Just returns the configuration</div></div>
<pre><span class="METHODtest_coverage"><span class="keyword">method</span> test_coverage</span> : <code class="code">string list</code></pre>
<div class="info"><div class="info">For testing: returns a list of tokens indicating into which cases the program
 ran.</div></div></div></div>
<div class="ocaml_class sig" name="lingering_close"><pre><span class="TYPElingering_close"><span class="keyword">class</span> <a href="?package=ocamlnet&amp;module=Nethttpd_kernel&amp;class=lingering_close">lingering_close</a></span> : <code class="type"><a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; (unit -&gt; unit) option -&gt; </code><code class="code">object</code> .. <code class="code">end</code></pre><div class="info"><div class="info">Closes a file descriptor using the &quot;lingering close&quot; algorithm.
    The optional <code class="code">preclose</code> function is called just before <code class="code">Unix.close</code>.</div></div><div class="ocaml_class_content"><div class="info"><div class="info">Closes a file descriptor using the &quot;lingering close&quot; algorithm<p> Usage:
 </p><code class="code"> while lc # lingering do lc # cycle ~block:true () done </code></div></div>
<pre><span class="METHODcycle"><span class="keyword">method</span> cycle</span> : <code class="code">?block:bool -&gt; unit -&gt; unit</code></pre>
<div class="info"><div class="info">Reads data from the file descriptor until EOF or until a fixed timeout
 is over. Finally, the descriptor is closed. If <code class="code">block</code> is set, the method
 blocks until data is available. (Default: <code class="code">false</code>)</div></div>
<pre><span class="METHODlingering"><span class="keyword">method</span> lingering</span> : <code class="code">bool</code></pre>
<div class="info"><div class="info">Whether the socket is still lingering</div></div>
<pre><span class="METHODfd"><span class="keyword">method</span> fd</span> : <code class="code"><a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a></code></pre>
<div class="info"><div class="info">The file descriptor</div></div></div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Debugging</h1></div></div>
<div class="ocaml_module sig" name="Debug"><pre><span class="keyword">module</span> <a href="?package=ocamlnet&amp;module=Nethttpd_kernel.Debug">Debug</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="VALenable"><span class="keyword">val</span> enable</span> : <code class="type">bool <a href="?package=ocaml&amp;module=Pervasives&amp;type=ref">Pervasives.ref</a></code></pre><div class="info"><div class="info">Enables  <a href="#Netlog">Netlog</a>-style debugging of this module</div></div></div></div>
</div>