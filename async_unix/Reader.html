<div class="ocaml_toplevel_module"><div class="info"><code class="code">Reader</code> is Async's main API for buffered input from a file descriptor.  It is the
    analog of <code class="code">Core.Std.In_channel</code>.<p>    Each reader has an internal buffer, which is filled via <code class="code">read()</code> system calls when
    data is needed to satisfy a <code class="code">Reader.read*</code> call.</p><p>    Each of the read functions returns a deferred that will become determined when the
    read completes.  It is an error to have two simultaneous reads.  That is, if one calls
    a read function, one should not call another read function until the first one
    completes.</p><p>    If the file descriptor underlying a reader is closed, the reader will return EOF
    (after all the buffered bytes have been read).</p><p>    Any <code class="code">Reader.read*</code> call could, rather than determine its result, send an exception to
    the monitor in effect when <code class="code">read</code> was called.  Such exceptions can be handled in the
    usual way by using <code class="code">try_with</code>, e.g.:</p><p>    </p><code class="code">
      try_with (fun () -&gt; Reader.read reader ...)
    </code></div>
<div class="ocaml_module sig" name="Read_result"><pre><span class="keyword">module</span> <a href="?package=async_unix&amp;module=Reader.Read_result">Read_result</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEt"><span class="keyword">type</span> <code class="type">'a </code>t</span> = <code class="type">[ `Eof | `Ok of 'a ]</code></pre>
<div class="ocaml_include ident" path="?package=core&amp;module=Std.Monad.S" items="[&quot;Monad_infix&quot;]"><pre><span class="keyword">include</span> <code class="type"><code class="code"><a href="?package=core&amp;module=Std.Monad.S">Core.Std.Monad.S</a></code> with type t := 'a <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">t</a></code></pre></div>
<pre><span class="VALt_of_sexp"><span class="keyword">val</span> t_of_sexp</span> : <code class="type">(<a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a> -&gt; 'a) -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a> -&gt; 'a <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">t</a></code></pre>
<pre><span class="VAL__t_of_sexp__"><span class="keyword">val</span> __t_of_sexp__</span> : <code class="type">(<a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a> -&gt; 'a) -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a> -&gt; 'a <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">t</a></code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type">('a -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a>) -&gt; 'a <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre>
<pre><span class="VALbin_t"><span class="keyword">val</span> bin_t</span> : <code class="type">'a <a href="?package=core&amp;module=Std.Bin_prot.Type_class&amp;type=t">Core.Std.Bin_prot.Type_class.t</a> -&gt; 'a <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">t</a> <a href="?package=core&amp;module=Std.Bin_prot.Type_class&amp;type=t">Core.Std.Bin_prot.Type_class.t</a></code></pre>
<pre><span class="VALbin_read_t"><span class="keyword">val</span> bin_read_t</span> : <code class="type">'a <a href="?package=core&amp;module=Std.Bin_prot.Unsafe_read_c&amp;type=reader">Core.Std.Bin_prot.Unsafe_read_c.reader</a> -&gt;
'a <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">t</a> <a href="?package=core&amp;module=Std.Bin_prot.Read_ml&amp;type=reader">Core.Std.Bin_prot.Read_ml.reader</a></code></pre>
<pre><span class="VALbin_read_t_"><span class="keyword">val</span> bin_read_t_</span> : <code class="type">'a <a href="?package=core&amp;module=Std.Bin_prot.Unsafe_read_c&amp;type=reader">Core.Std.Bin_prot.Unsafe_read_c.reader</a> -&gt;
'a <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">t</a> <a href="?package=core&amp;module=Std.Bin_prot.Unsafe_read_c&amp;type=reader">Core.Std.Bin_prot.Unsafe_read_c.reader</a></code></pre>
<pre><span class="VALbin_read_t__"><span class="keyword">val</span> bin_read_t__</span> : <code class="type">'a <a href="?package=core&amp;module=Std.Bin_prot.Unsafe_read_c&amp;type=reader">Core.Std.Bin_prot.Unsafe_read_c.reader</a> -&gt;
(int -&gt; 'a <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">t</a>) <a href="?package=core&amp;module=Std.Bin_prot.Unsafe_read_c&amp;type=reader">Core.Std.Bin_prot.Unsafe_read_c.reader</a></code></pre>
<pre><span class="VALbin_reader_t"><span class="keyword">val</span> bin_reader_t</span> : <code class="type">'a <a href="?package=core&amp;module=Std.Bin_prot.Type_class&amp;type=reader">Core.Std.Bin_prot.Type_class.reader</a> -&gt;
'a <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">t</a> <a href="?package=core&amp;module=Std.Bin_prot.Type_class&amp;type=reader">Core.Std.Bin_prot.Type_class.reader</a></code></pre>
<pre><span class="VALbin_size_t"><span class="keyword">val</span> bin_size_t</span> : <code class="type">'a <a href="?package=core&amp;module=Std.Bin_prot.Size&amp;type=sizer">Core.Std.Bin_prot.Size.sizer</a> -&gt; 'a <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">t</a> <a href="?package=core&amp;module=Std.Bin_prot.Size&amp;type=sizer">Core.Std.Bin_prot.Size.sizer</a></code></pre>
<pre><span class="VALbin_write_t"><span class="keyword">val</span> bin_write_t</span> : <code class="type">'a <a href="?package=core&amp;module=Std.Bin_prot.Unsafe_write_c&amp;type=writer">Core.Std.Bin_prot.Unsafe_write_c.writer</a> -&gt;
'a <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">t</a> <a href="?package=core&amp;module=Std.Bin_prot.Write_ml&amp;type=writer">Core.Std.Bin_prot.Write_ml.writer</a></code></pre>
<pre><span class="VALbin_write_t_"><span class="keyword">val</span> bin_write_t_</span> : <code class="type">'a <a href="?package=core&amp;module=Std.Bin_prot.Unsafe_write_c&amp;type=writer">Core.Std.Bin_prot.Unsafe_write_c.writer</a> -&gt;
'a <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">t</a> <a href="?package=core&amp;module=Std.Bin_prot.Unsafe_write_c&amp;type=writer">Core.Std.Bin_prot.Unsafe_write_c.writer</a></code></pre>
<pre><span class="VALbin_writer_t"><span class="keyword">val</span> bin_writer_t</span> : <code class="type">'a <a href="?package=core&amp;module=Std.Bin_prot.Type_class&amp;type=writer">Core.Std.Bin_prot.Type_class.writer</a> -&gt;
'a <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">t</a> <a href="?package=core&amp;module=Std.Bin_prot.Type_class&amp;type=writer">Core.Std.Bin_prot.Type_class.writer</a></code></pre></div></div>
<div class="ocaml_module ident" name="Id" path="?package=core&amp;module=Std.Unique_id"><pre><span class="keyword">module</span> <a href="?package=async_unix&amp;module=Reader.Id">Id</a> : <code class="type"><code class="code"><a href="?package=core&amp;module=Std.Unique_id">Core.Std.Unique_id</a></code></code></pre></div>
<pre><span class="TYPEt"><span class="keyword">type</span> t</span> </pre>
<div class="ocaml_include ident" path="?package=core&amp;module=Std.Invariant.S" items="[]"><pre><span class="keyword">include</span> <code class="type"><code class="code"><a href="?package=core&amp;module=Std.Invariant.S">Core.Std.Invariant.S</a></code> with type t := <a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a></code></pre></div>
<pre><span class="VALio_stats"><span class="keyword">val</span> io_stats</span> : <code class="type"><a href="?package=async_unix&amp;module=Io_stats&amp;type=t">Io_stats.t</a></code></pre><div class="info"><div class="info"><code class="code">io_stats</code> Overall IO statistics for all readers</div></div>
<pre><span class="VALlast_read_time"><span class="keyword">val</span> last_read_time</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Std.Time&amp;type=t">Core.Std.Time.t</a></code></pre><div class="info"><div class="info"><code class="code">last_read_time t</code> returns time of the most recent <code class="code">read</code> system call that
    returned data.</div></div>
<pre><span class="VALstdin"><span class="keyword">val</span> stdin</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> <a href="?package=core&amp;module=Std.Lazy&amp;type=t">Core.Std.Lazy.t</a></code></pre><div class="info"><div class="info"><code class="code">stdin</code> is a reader for file descriptor 0.  It is lazy because we don't want
   to create it in all programs that happen to link with async.</div></div>
<pre><span class="VALopen_file"><span class="keyword">val</span> open_file</span> : <code class="type">?close_on_exec:bool -&gt; ?buf_len:int -&gt; string -&gt; <a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">open_file file</code> opens <code class="code">file</code> for reading and returns a reader reading from it.</div></div>
<pre><span class="VALtransfer"><span class="keyword">val</span> transfer</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; string <a href="?package=async_unix&amp;module=Import.Pipe.Writer&amp;type=t">Import.Pipe.Writer.t</a> -&gt; unit <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">transfer t pipe_w</code> transfers data from <code class="code">t</code> into <code class="code">pipe_w</code> one chunk at a time
    (whatever is read from the underlying file descriptor without post-processing).  The
    result becomes determined after reaching EOF on <code class="code">t</code> and the final bytes have been
    transferred, or if <code class="code">pipe_w</code> is closed.<p>    This function will normally not be needed (see <code class="code">pipe</code>).</p></div></div>
<pre><span class="VALpipe"><span class="keyword">val</span> pipe</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; string <a href="?package=async_unix&amp;module=Import.Pipe.Reader&amp;type=t">Import.Pipe.Reader.t</a></code></pre><div class="info"><div class="info"><code class="code">pipe t</code> returns the reader end of a pipe that will continually be filled with chunks
    of data from the underlying Reader.t.  When the reader reaches EOF or the pipe is
    closed, <code class="code">pipe</code> closes the the reader, and then after the reader close is finished,
    closes the pipe.</div></div>
<pre><span class="VALof_pipe"><span class="keyword">val</span> of_pipe</span> : <code class="type"><a href="?package=core&amp;module=Std.Info&amp;type=t">Core.Std.Info.t</a> -&gt; string <a href="?package=async_unix&amp;module=Import.Pipe.Reader&amp;type=t">Import.Pipe.Reader.t</a> -&gt; <a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">of_pipe info pipe_r</code> returns a reader <code class="code">t</code> that receives all the data from <code class="code">pipe_r</code>.
    If <code class="code">pipe_r</code> is closed, <code class="code">t</code> will see an EOF (but will not be automatically closed).  If
    <code class="code">t</code> is closed, then <code class="code">pipe_r</code> will stop being drained.<p>    <code class="code">of_pipe</code> is implemented by shuttling bytes from <code class="code">pipe_r</code> to the write-end of a Unix
    pipe, with <code class="code">t</code> being attached to the read end of the Unix pipe.</p></div></div>
<pre><span class="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">?buf_len:int -&gt; <a href="?package=async_unix&amp;module=Fd&amp;type=t">Fd.t</a> -&gt; <a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">create ~buf_len fd</code> creates a new reader that is reading from <code class="code">fd</code>.<div class="parameters"><div class="param_info"><code class="code">access_raw_data</code> : default = None if specified this function will
    be given access to the raw bits as they are read by the reader. No
    guarantee of granularity is made.</div></div></div></div>
<pre><span class="VALof_in_channel"><span class="keyword">val</span> of_in_channel</span> : <code class="type"><a href="?package=ocaml&amp;module=Pervasives&amp;type=in_channel">Pervasives.in_channel</a> -&gt; <a href="?package=async_unix&amp;module=Fd.Kind&amp;type=t">Fd.Kind.t</a> -&gt; <a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a></code></pre>
<pre><span class="VALwith_file"><span class="keyword">val</span> with_file</span> : <code class="type">?buf_len:int -&gt;
?exclusive:bool -&gt;
string -&gt; f:(<a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; 'a <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a>) -&gt; 'a <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">with_file file f</code> opens <code class="code">files</code>, creates a reader with it, and passes the reader to
    <code class="code">f</code>.  It closes the reader when the result of <code class="code">f</code> becomes determined, and returns
    <code class="code">f</code>'s result.<p>    NOTE, you need to be careful that all your IO is done when the deferred you return
    becomes determined. If for example, you use <code class="code">with_file</code>, and call <code class="code">lines</code>, make sure
    you return a deferred that becomes determined when the EOF is reached on the pipe,
    not when you get the pipe (because you get it straight away).</p></div></div>
<pre><span class="VALclose"><span class="keyword">val</span> close</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; unit <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">close t</code> prevents further use of <code class="code">t</code> and closes <code class="code">t</code>'s underlying file descriptor.
    The result of <code class="code">close</code> becomes determined once the underlying file descriptor has been
    closed.  It is an error to call other operations on <code class="code">t</code> after <code class="code">close t</code> has been
    called, except that calls of <code class="code">close</code> subsequent to the original call to <code class="code">close</code> will
    return the same deferred as the original call.<p>    <code class="code">close_finished t</code> becomes determined after <code class="code">t</code>'s underlying file descriptor has been
    closed, i.e. it is the same as the result of <code class="code">close</code>.  <code class="code">close_finished</code> differs from
    <code class="code">close</code> in that it does not have the side effect of initiating a close.</p><p>    <code class="code">is_closed t</code> returns <code class="code">true</code> iff <code class="code">close t</code> has been called.</p><p>    <code class="code">with_close t ~f</code> runs <code class="code">f ()</code>, and closes <code class="code">t</code> after <code class="code">f</code> finishes or raises.</p></div></div>
<pre><span class="VALclose_finished"><span class="keyword">val</span> close_finished</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; unit <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre>
<pre><span class="VALis_closed"><span class="keyword">val</span> is_closed</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; bool</code></pre>
<pre><span class="VALwith_close"><span class="keyword">val</span> with_close</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; f:(unit -&gt; 'a <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a>) -&gt; 'a <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre>
<pre><span class="VALid"><span class="keyword">val</span> id</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; <a href="?package=async_unix&amp;module=Reader.Id&amp;type=t">Id.t</a></code></pre><div class="info"><div class="info"><code class="code">id t</code> <b>Returns</b> a name for this reader that is unique across all
    instances of the reader module.</div></div>
<pre><span class="VALfd"><span class="keyword">val</span> fd</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; <a href="?package=async_unix&amp;module=Fd&amp;type=t">Fd.t</a></code></pre><div class="info"><div class="info"><code class="code">fd t</code> <b>Returns</b> the Fd.t used to create this reader</div></div>
<pre><span class="VALread"><span class="keyword">val</span> read</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; ?pos:int -&gt; ?len:int -&gt; string -&gt; int <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">Read_result.t</a> <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">read t ?pos ?len buf</code> reads up to <code class="code">len</code> bytes into buf, blocking
    until some data is available or end-of-input is reached.  The resulting
    <code class="code">i</code> satisfies <code class="code">0 &lt; i &lt;= len</code>.</div></div>
<pre><span class="TYPEread_one_chunk_at_a_time_result"><span class="keyword">type</span> <code class="type">'a </code>read_one_chunk_at_a_time_result</span> = <code class="type">[ `Eof | `Eof_with_unconsumed_data of string | `Stopped of 'a ]</code></pre><div class="info"><div class="info"><code class="code">read_one_chunk_at_a_time t ~handle_chunk</code> reads into <code class="code">t</code>'s internal buffer,
    and whenever bytes are available, applies <code class="code">handle_chunk</code> to them.  It waits to read
    again until the deferred returned by <code class="code">handle_chunk</code> becomes determined.
    <code class="code">read_one_chunk_at_a_time</code> continues reading until it reaches <code class="code">`Eof</code> or <code class="code">handle_chunk</code>
    returns <code class="code">`Stop</code> or <code class="code">`Stop_consumed</code>.  In the case of <code class="code">`Stop</code> and <code class="code">`Stop_consumed</code>,
    one may read from <code class="code">t</code> after <code class="code">read_one_chunk_at_a_time</code> returns.</div></div>
<pre><span class="VALread_one_chunk_at_a_time"><span class="keyword">val</span> read_one_chunk_at_a_time</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt;
handle_chunk:(<a href="?package=core&amp;module=Std.Bigstring&amp;type=t">Core.Std.Bigstring.t</a> -&gt;
              pos:int -&gt;
              len:int -&gt;
              [ `Consumed of int * [ `Need of int | `Need_unknown ]
              | `Continue
              | `Stop of 'a
              | `Stop_consumed of 'a * int ] <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a>) -&gt;
'a <a href="?package=async_unix&amp;module=Reader&amp;type=read_one_chunk_at_a_time_result">read_one_chunk_at_a_time_result</a> <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre>
<pre><span class="VALread_substring"><span class="keyword">val</span> read_substring</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Std.Substring&amp;type=t">Core.Std.Substring.t</a> -&gt; int <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">Read_result.t</a> <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">read_substring t ss</code> reads up to <code class="code">Substring.length ss</code> bytes into <code class="code">ss</code>,
    blocking until some data is available or Eof is reched.  The resulting <code class="code">i</code>
    satisfies <code class="code">0 &lt; i &lt;= Substring.length ss</code>.</div></div>
<pre><span class="VALread_bigsubstring"><span class="keyword">val</span> read_bigsubstring</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Std.Bigsubstring&amp;type=t">Core.Std.Bigsubstring.t</a> -&gt; int <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">Read_result.t</a> <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre>
<pre><span class="VALread_char"><span class="keyword">val</span> read_char</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; char <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">Read_result.t</a> <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre>
<pre><span class="VALreally_read"><span class="keyword">val</span> really_read</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt;
?pos:int -&gt; ?len:int -&gt; string -&gt; [ `Eof of int | `Ok ] <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">really_read t buf ?pos ?len</code> reads until it fills <code class="code">len</code> bytes of <code class="code">buf</code>
    starting at <code class="code">pos</code> or runs out of input.  In the former case it returns `Ok.
    In the latter, it returns <code class="code">`Eof n</code> where <code class="code">n</code> is the number of bytes that
    were read before end of input, and <code class="code">0 &lt;= n &lt; String.length ss</code>.</div></div>
<pre><span class="VALreally_read_substring"><span class="keyword">val</span> really_read_substring</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Std.Substring&amp;type=t">Core.Std.Substring.t</a> -&gt; [ `Eof of int | `Ok ] <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre>
<pre><span class="VALreally_read_bigsubstring"><span class="keyword">val</span> really_read_bigsubstring</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Std.Bigsubstring&amp;type=t">Core.Std.Bigsubstring.t</a> -&gt; [ `Eof of int | `Ok ] <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre>
<pre><span class="VALread_until"><span class="keyword">val</span> read_until</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt;
[ `Char of char | `Pred of char -&gt; bool ] -&gt;
keep_delim:bool -&gt;
[ `Eof | `Eof_without_delim of string | `Ok of string ] <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">read_until t pred ~keep_delim</code> reads until it hits a delimiter <code class="code">c</code> such that:<p>    - if <code class="code">pred = `Char c'</code> then <code class="code">c = c'</code></p><ul><li>if <code class="code">pred = `Pred p</code> then <code class="code">p c</code></li></ul>    <code class="code">`Char c'</code> is equivalent to <code class="code">`Pred (fun c -&gt; c = c')</code> but the underlying
    implementation is more efficient, in particular it will not call a function on every
    input character.<p>    <code class="code">read_until</code> returns a freshly-allocated string consisting of all the characters read
    and optionally including the delimiter as per <code class="code">keep_delim</code>.</p></div></div>
<pre><span class="VALread_until_max"><span class="keyword">val</span> read_until_max</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt;
[ `Char of char | `Pred of char -&gt; bool ] -&gt;
keep_delim:bool -&gt;
max:int -&gt;
[ `Eof
| `Eof_without_delim of string
| `Max_exceeded of string
| `Ok of string ] <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre><div class="info"><div class="info">just like <code class="code">read_until</code>, except you have the option of specifiying a maximum number of
    chars to read.</div></div>
<pre><span class="VALread_line"><span class="keyword">val</span> read_line</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; string <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">Read_result.t</a> <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">read_line t</code> reads up to, and including the next newline (\n) character (or \r\n) and
    returns a freshly-allocated string containing everything up to but not including the
    newline character.  If <code class="code">read_line</code> encounters EOF before the newline char then
    everything read up to but not including EOF will be returned as a line.</div></div>
<pre><span class="VALreally_read_line"><span class="keyword">val</span> really_read_line</span> : <code class="type">wait_time:<a href="?package=core&amp;module=Std.Time.Span&amp;type=t">Core.Std.Time.Span.t</a> -&gt; <a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; string option <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">really_read_line ~wait_time t</code> reads up to, and including the next newline (\n)
    character and returns an optional, freshly-allocated string containing everything up
    to but not including the newline character.  If <code class="code">really_read_line</code> encounters EOF
    before the newline char, then a time span of <code class="code">wait_time</code> will be used before the input
    operation is retried.  If the descriptor is closed, <code class="code">None</code> will be returned.</div></div>
<pre><span class="TYPEread"><span class="keyword">type</span> <code class="type">'a </code>read</span> = <code class="type">?parse_pos:<a href="?package=core&amp;module=Std.Sexp.Parse_pos&amp;type=t">Core.Std.Sexp.Parse_pos.t</a> -&gt; 'a</code></pre>
<pre><span class="VALread_sexp"><span class="keyword">val</span> read_sexp</span> : <code class="type">(<a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Std.Sexp&amp;type=t">Core.Std.Sexp.t</a> <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">Read_result.t</a> <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a>) <a href="?package=async_unix&amp;module=Reader&amp;type=read">read</a></code></pre><div class="info"><div class="info"><code class="code">read_sexp t</code> reads the next sexp.</div></div>
<pre><span class="VALread_sexps"><span class="keyword">val</span> read_sexps</span> : <code class="type">(<a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; <a href="?package=core&amp;module=Std.Sexp&amp;type=t">Core.Std.Sexp.t</a> <a href="?package=async_unix&amp;module=Import.Pipe.Reader&amp;type=t">Import.Pipe.Reader.t</a>) <a href="?package=async_unix&amp;module=Reader&amp;type=read">read</a></code></pre><div class="info"><div class="info"><code class="code">read_sexps t</code> reads all the sexps and returns them as a pipe.  When the reader
    reaches EOF or the pipe is closed, <code class="code">read_sexps</code> closes the the reader, and then
    after the reader close is finished, closes the pipe.</div></div>
<pre><span class="VALread_bin_prot"><span class="keyword">val</span> read_bin_prot</span> : <code class="type">?max_len:int -&gt;
<a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt;
'a <a href="?package=core&amp;module=Std.Bin_prot.Type_class&amp;type=reader">Core.Std.Bin_prot.Type_class.reader</a> -&gt; 'a <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">Read_result.t</a> <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">read_bin_prot ?max_len t bp_reader</code> reads the next binary protocol message using
    binary protocol reader <code class="code">bp_reader</code>.  The format is the &quot;size-prefixed binary
    protocol&quot;, in which the length of the data is prefixed as a 64-bit integer to the
    data.  This is the format that Writer.write_bin_prot writes.</div></div>
<pre><span class="VALread_marshal_raw"><span class="keyword">val</span> read_marshal_raw</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; string <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">Read_result.t</a> <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre><div class="info"><div class="info">Read and return a buffer containing one marshaled value, but don't unmarshal it. You
    can just call Marshal.from_string on the string, and cast it to the desired type
    (preferrably the actual type). similar to Marshal.from_channel, but suffers from the
    String-length limitation (16MB) on 32bit platforms.</div></div>
<pre><span class="VALread_marshal"><span class="keyword">val</span> read_marshal</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; 'a <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">Read_result.t</a> <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre><div class="info"><div class="info">Like read_marshal_raw, but unmarshal the value after reading it</div></div>
<pre><span class="VALrecv"><span class="keyword">val</span> recv</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; string <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">Read_result.t</a> <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">recv t</code> returns a string that was written with Writer.send</div></div>
<pre><span class="VALread_all"><span class="keyword">val</span> read_all</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; (<a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; 'a <a href="?package=async_unix&amp;module=Reader.Read_result&amp;type=t">Read_result.t</a> <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a>) -&gt; 'a <a href="?package=async_unix&amp;module=Import.Pipe.Reader&amp;type=t">Import.Pipe.Reader.t</a></code></pre><div class="info"><div class="info"><code class="code">read_all t read_one</code> returns a pipe that receives all values read from <code class="code">t</code> by
    repeatedly using <code class="code">read_one t</code>.  When the reader reaches EOF, it closes the reader,
    and then after the reader close is finished, closes the pipe.</div></div>
<pre><span class="VALlseek"><span class="keyword">val</span> lseek</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; int64 -&gt; mode:[&lt; `End | `Set ] -&gt; int64 <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">lseek t offset ~mode</code> clears <code class="code">t</code>'s buffer and calls <code class="code">Unix.lseek</code> on <code class="code">t</code>'s file
    descriptor.  The <code class="code">`Cur</code> mode is not exposed because seeking relative to the current
    position of the file descriptor is not the same as seeking to relative to the current
    position of the reader.</div></div>
<pre><span class="VALlines"><span class="keyword">val</span> lines</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; string <a href="?package=async_unix&amp;module=Import.Pipe.Reader&amp;type=t">Import.Pipe.Reader.t</a></code></pre><div class="info"><div class="info"><code class="code">lines t</code> reads all the lines from <code class="code">t</code> and puts them in the pipe, one line per pipe
    element.  The lines do not contain the trailing newline.  When the reader reaches EOF
    or the pipe is closed, <code class="code">lines</code> closes the the reader, and then after the reader close
    is finished, closes the pipe.</div></div>
<pre><span class="VALcontents"><span class="keyword">val</span> contents</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; string <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">contents t</code> returns the string corresponding to the full contents (up to EOF) of the
    reader.  <code class="code">contents</code> closes <code class="code">t</code> before returning the string.</div></div>
<pre><span class="VALfile_contents"><span class="keyword">val</span> file_contents</span> : <code class="type">string -&gt; string <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">file_contents file</code> returns the string with the full contents of the file</div></div>
<pre><span class="VALfile_lines"><span class="keyword">val</span> file_lines</span> : <code class="type">string -&gt; string list <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">file_lines file</code> returns a list of the lines in the file.  The lines do not contain
    the trailing newline.</div></div>
<pre><span class="VALload_sexp"><span class="keyword">val</span> load_sexp</span> : <code class="type">?exclusive:bool -&gt;
string -&gt; (<a href="?package=core&amp;module=Std.Sexp&amp;type=t">Core.Std.Sexp.t</a> -&gt; 'a) -&gt; 'a <a href="?package=core&amp;module=Std.Or_error&amp;type=t">Core.Std.Or_error.t</a> <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">load_sexp ?exclusive file ~f</code> loads and convert the S-expression in a given <code class="code">file</code>
    using <code class="code">f</code>, and returns the deferred conversion result as a variant of either <code class="code">Ok res</code>
    or <code class="code">Error exn</code> otherwise.  This function provides accurate error locations for failed
    conversions.</div></div>
<pre><span class="VALload_sexp_exn"><span class="keyword">val</span> load_sexp_exn</span> : <code class="type">?exclusive:bool -&gt; string -&gt; (<a href="?package=core&amp;module=Std.Sexp&amp;type=t">Core.Std.Sexp.t</a> -&gt; 'a) -&gt; 'a <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre>
<pre><span class="VALload_sexps"><span class="keyword">val</span> load_sexps</span> : <code class="type">?exclusive:bool -&gt;
string -&gt;
(<a href="?package=core&amp;module=Std.Sexp&amp;type=t">Core.Std.Sexp.t</a> -&gt; 'a) -&gt; 'a list <a href="?package=core&amp;module=Std.Or_error&amp;type=t">Core.Std.Or_error.t</a> <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">load_sexps file ~f</code> load and convert the S-expressions in a given <code class="code">file</code> using <code class="code">f</code>,
    and return the deferred list of conversion results as variants of either <code class="code">Ok res</code> or
    <code class="code">Error exn</code> otherwise.  This function is as efficient as <code class="code">load_sexps</code> followed by
    conversion if there are no errors, but provides accurate error locations for failed
    conversions.</div></div>
<pre><span class="VALload_sexps_exn"><span class="keyword">val</span> load_sexps_exn</span> : <code class="type">?exclusive:bool -&gt;
string -&gt; (<a href="?package=core&amp;module=Std.Sexp&amp;type=t">Core.Std.Sexp.t</a> -&gt; 'a) -&gt; 'a list <a href="?package=async_unix&amp;module=Import.Deferred&amp;type=t">Import.Deferred.t</a></code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type"><a href="?package=async_unix&amp;module=Reader&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre>
<div class="info"><div class="info"><code class="code">io_stats</code> Overall IO statistics for all readers</div></div>
<div class="info"><div class="info"><code class="code">last_read_time t</code> returns time of the most recent <code class="code">read</code> system call that
    returned data.</div></div>
<div class="info"><div class="info"><code class="code">stdin</code> is a reader for file descriptor 0.  It is lazy because we don't want
   to create it in all programs that happen to link with async.</div></div>
<div class="info"><div class="info"><code class="code">open_file file</code> opens <code class="code">file</code> for reading and returns a reader reading from it.</div></div>
<div class="info"><div class="info">default is <code class="code">true</code></div></div>
<div class="info"><div class="info"><code class="code">transfer t pipe_w</code> transfers data from <code class="code">t</code> into <code class="code">pipe_w</code> one chunk at a time
    (whatever is read from the underlying file descriptor without post-processing).  The
    result becomes determined after reaching EOF on <code class="code">t</code> and the final bytes have been
    transferred, or if <code class="code">pipe_w</code> is closed.<p>    This function will normally not be needed (see <code class="code">pipe</code>).</p></div></div>
<div class="info"><div class="info"><code class="code">pipe t</code> returns the reader end of a pipe that will continually be filled with chunks
    of data from the underlying Reader.t.  When the reader reaches EOF or the pipe is
    closed, <code class="code">pipe</code> closes the the reader, and then after the reader close is finished,
    closes the pipe.</div></div>
<div class="info"><div class="info"><code class="code">of_pipe info pipe_r</code> returns a reader <code class="code">t</code> that receives all the data from <code class="code">pipe_r</code>.
    If <code class="code">pipe_r</code> is closed, <code class="code">t</code> will see an EOF (but will not be automatically closed).  If
    <code class="code">t</code> is closed, then <code class="code">pipe_r</code> will stop being drained.<p>    <code class="code">of_pipe</code> is implemented by shuttling bytes from <code class="code">pipe_r</code> to the write-end of a Unix
    pipe, with <code class="code">t</code> being attached to the read end of the Unix pipe.</p></div></div>
<div class="info"><div class="info"><code class="code">create ~buf_len fd</code> creates a new reader that is reading from <code class="code">fd</code>.<div class="parameters"><div class="param_info"><code class="code">access_raw_data</code> : default = None if specified this function will
    be given access to the raw bits as they are read by the reader. No
    guarantee of granularity is made.</div></div></div></div>
<div class="info"><div class="info"><code class="code">with_file file f</code> opens <code class="code">files</code>, creates a reader with it, and passes the reader to
    <code class="code">f</code>.  It closes the reader when the result of <code class="code">f</code> becomes determined, and returns
    <code class="code">f</code>'s result.<p>    NOTE, you need to be careful that all your IO is done when the deferred you return
    becomes determined. If for example, you use <code class="code">with_file</code>, and call <code class="code">lines</code>, make sure
    you return a deferred that becomes determined when the EOF is reached on the pipe,
    not when you get the pipe (because you get it straight away).</p></div></div>
<div class="info"><div class="info">default is <code class="code">false</code></div></div>
<div class="info"><div class="info"><code class="code">close t</code> prevents further use of <code class="code">t</code> and closes <code class="code">t</code>'s underlying file descriptor.
    The result of <code class="code">close</code> becomes determined once the underlying file descriptor has been
    closed.  It is an error to call other operations on <code class="code">t</code> after <code class="code">close t</code> has been
    called, except that calls of <code class="code">close</code> subsequent to the original call to <code class="code">close</code> will
    return the same deferred as the original call.<p>    <code class="code">close_finished t</code> becomes determined after <code class="code">t</code>'s underlying file descriptor has been
    closed, i.e. it is the same as the result of <code class="code">close</code>.  <code class="code">close_finished</code> differs from
    <code class="code">close</code> in that it does not have the side effect of initiating a close.</p><p>    <code class="code">is_closed t</code> returns <code class="code">true</code> iff <code class="code">close t</code> has been called.</p><p>    <code class="code">with_close t ~f</code> runs <code class="code">f ()</code>, and closes <code class="code">t</code> after <code class="code">f</code> finishes or raises.</p></div></div>
<div class="info"><div class="info"><code class="code">id t</code> <b>Returns</b> a name for this reader that is unique across all
    instances of the reader module.</div></div>
<div class="info"><div class="info"><code class="code">fd t</code> <b>Returns</b> the Fd.t used to create this reader</div></div>
<div class="info"><div class="info"><code class="code">read t ?pos ?len buf</code> reads up to <code class="code">len</code> bytes into buf, blocking
    until some data is available or end-of-input is reached.  The resulting
    <code class="code">i</code> satisfies <code class="code">0 &lt; i &lt;= len</code>.</div></div>
<pre><span class="VALsexp_of_read_one_chunk_at_a_time_result"><span class="keyword">val</span> sexp_of_read_one_chunk_at_a_time_result</span> : <code class="type">('a -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a>) -&gt;
'a <a href="?package=async_unix&amp;module=Reader&amp;type=read_one_chunk_at_a_time_result">read_one_chunk_at_a_time_result</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre><div class="info"><div class="info"><code class="code">read_one_chunk_at_a_time t ~handle_chunk</code> reads into <code class="code">t</code>'s internal buffer,
    and whenever bytes are available, applies <code class="code">handle_chunk</code> to them.  It waits to read
    again until the deferred returned by <code class="code">handle_chunk</code> becomes determined.
    <code class="code">read_one_chunk_at_a_time</code> continues reading until it reaches <code class="code">`Eof</code> or <code class="code">handle_chunk</code>
    returns <code class="code">`Stop</code> or <code class="code">`Stop_consumed</code>.  In the case of <code class="code">`Stop</code> and <code class="code">`Stop_consumed</code>,
    one may read from <code class="code">t</code> after <code class="code">read_one_chunk_at_a_time</code> returns.</div></div>
<div class="info"><div class="info"><code class="code">`Stop a</code> means that <code class="code">handle_chunk</code> consumed all <code class="code">len</code> bytes,
                         and that <code class="code">read_one_chunk_at_a_time</code> should stop reading and
                         return <code class="code">`Stopped a</code>.</div></div>
<div class="info"><div class="info"><code class="code">`Stop_consumed (a, n)</code> means that <code class="code">handle_chunk</code> consumed <code class="code">n</code>
                         bytes, and that <code class="code">read_one_chunk_at_a_time</code> should stop reading
                         and return <code class="code">`Stopped a</code>.</div></div>
<div class="info"><div class="info"><code class="code">`Continue</code> means that <code class="code">handle_chunk</code> has consumed all <code class="code">len</code>
                         bytes.</div></div>
<div class="info"><div class="info"><code class="code">`Consumed (c, need)</code> means that <code class="code">c</code> bytes were consumed and
                         <code class="code">need</code> says how many bytes are needed (including the data
                         remaining in the buffer after the <code class="code">c</code> were already consumed).
                         It is an error if <code class="code">c &lt; 0 || c &gt; len</code>.  For <code class="code">`Need n</code>, it is an
                         error if <code class="code">n &lt; 0 || c + n &lt;= len</code>.</div></div>
<div class="info"><div class="info"><code class="code">read_substring t ss</code> reads up to <code class="code">Substring.length ss</code> bytes into <code class="code">ss</code>,
    blocking until some data is available or Eof is reched.  The resulting <code class="code">i</code>
    satisfies <code class="code">0 &lt; i &lt;= Substring.length ss</code>.</div></div>
<div class="info"><div class="info"><code class="code">really_read t buf ?pos ?len</code> reads until it fills <code class="code">len</code> bytes of <code class="code">buf</code>
    starting at <code class="code">pos</code> or runs out of input.  In the former case it returns `Ok.
    In the latter, it returns <code class="code">`Eof n</code> where <code class="code">n</code> is the number of bytes that
    were read before end of input, and <code class="code">0 &lt;= n &lt; String.length ss</code>.</div></div>
<div class="info"><div class="info"><code class="code">read_until t pred ~keep_delim</code> reads until it hits a delimiter <code class="code">c</code> such that:<p>    - if <code class="code">pred = `Char c'</code> then <code class="code">c = c'</code></p><ul><li>if <code class="code">pred = `Pred p</code> then <code class="code">p c</code></li></ul>    <code class="code">`Char c'</code> is equivalent to <code class="code">`Pred (fun c -&gt; c = c')</code> but the underlying
    implementation is more efficient, in particular it will not call a function on every
    input character.<p>    <code class="code">read_until</code> returns a freshly-allocated string consisting of all the characters read
    and optionally including the delimiter as per <code class="code">keep_delim</code>.</p></div></div>
<div class="info"><div class="info">just like <code class="code">read_until</code>, except you have the option of specifiying a maximum number of
    chars to read.</div></div>
<div class="info"><div class="info"><code class="code">read_line t</code> reads up to, and including the next newline (\n) character (or \r\n) and
    returns a freshly-allocated string containing everything up to but not including the
    newline character.  If <code class="code">read_line</code> encounters EOF before the newline char then
    everything read up to but not including EOF will be returned as a line.</div></div>
<div class="info"><div class="info"><code class="code">really_read_line ~wait_time t</code> reads up to, and including the next newline (\n)
    character and returns an optional, freshly-allocated string containing everything up
    to but not including the newline character.  If <code class="code">really_read_line</code> encounters EOF
    before the newline char, then a time span of <code class="code">wait_time</code> will be used before the input
    operation is retried.  If the descriptor is closed, <code class="code">None</code> will be returned.</div></div>
<div class="info"><div class="info"><code class="code">read_sexp t</code> reads the next sexp.</div></div>
<div class="info"><div class="info"><code class="code">read_sexps t</code> reads all the sexps and returns them as a pipe.  When the reader
    reaches EOF or the pipe is closed, <code class="code">read_sexps</code> closes the the reader, and then
    after the reader close is finished, closes the pipe.</div></div>
<div class="info"><div class="info"><code class="code">read_bin_prot ?max_len t bp_reader</code> reads the next binary protocol message using
    binary protocol reader <code class="code">bp_reader</code>.  The format is the &quot;size-prefixed binary
    protocol&quot;, in which the length of the data is prefixed as a 64-bit integer to the
    data.  This is the format that Writer.write_bin_prot writes.</div></div>
<div class="info"><div class="info">Read and return a buffer containing one marshaled value, but don't unmarshal it. You
    can just call Marshal.from_string on the string, and cast it to the desired type
    (preferrably the actual type). similar to Marshal.from_channel, but suffers from the
    String-length limitation (16MB) on 32bit platforms.</div></div>
<div class="info"><div class="info">Like read_marshal_raw, but unmarshal the value after reading it</div></div>
<div class="info"><div class="info"><code class="code">recv t</code> returns a string that was written with Writer.send</div></div>
<div class="info"><div class="info"><code class="code">read_all t read_one</code> returns a pipe that receives all values read from <code class="code">t</code> by
    repeatedly using <code class="code">read_one t</code>.  When the reader reaches EOF, it closes the reader,
    and then after the reader close is finished, closes the pipe.</div></div>
<div class="info"><div class="info"><code class="code">lseek t offset ~mode</code> clears <code class="code">t</code>'s buffer and calls <code class="code">Unix.lseek</code> on <code class="code">t</code>'s file
    descriptor.  The <code class="code">`Cur</code> mode is not exposed because seeking relative to the current
    position of the file descriptor is not the same as seeking to relative to the current
    position of the reader.</div></div>
<div class="info"><div class="info"><code class="code">lines t</code> reads all the lines from <code class="code">t</code> and puts them in the pipe, one line per pipe
    element.  The lines do not contain the trailing newline.  When the reader reaches EOF
    or the pipe is closed, <code class="code">lines</code> closes the the reader, and then after the reader close
    is finished, closes the pipe.</div></div>
<div class="info"><div class="info"><code class="code">contents t</code> returns the string corresponding to the full contents (up to EOF) of the
    reader.  <code class="code">contents</code> closes <code class="code">t</code> before returning the string.</div></div>
<div class="info"><div class="info"><code class="code">file_contents file</code> returns the string with the full contents of the file</div></div>
<div class="info"><div class="info"><code class="code">file_lines file</code> returns a list of the lines in the file.  The lines do not contain
    the trailing newline.</div></div>
<div class="info"><div class="info"><code class="code">load_sexp ?exclusive file ~f</code> loads and convert the S-expression in a given <code class="code">file</code>
    using <code class="code">f</code>, and returns the deferred conversion result as a variant of either <code class="code">Ok res</code>
    or <code class="code">Error exn</code> otherwise.  This function provides accurate error locations for failed
    conversions.</div></div>
<div class="info"><div class="info">default is <code class="code">false</code></div></div>
<div class="info"><div class="info">default is <code class="code">false</code></div></div>
<div class="info"><div class="info"><code class="code">load_sexps file ~f</code> load and convert the S-expressions in a given <code class="code">file</code> using <code class="code">f</code>,
    and return the deferred list of conversion results as variants of either <code class="code">Ok res</code> or
    <code class="code">Error exn</code> otherwise.  This function is as efficient as <code class="code">load_sexps</code> followed by
    conversion if there are no errors, but provides accurate error locations for failed
    conversions.</div></div>
<div class="info"><div class="info">default is <code class="code">false</code></div></div>
<div class="info"><div class="info">default is <code class="code">false</code></div></div>
</div>