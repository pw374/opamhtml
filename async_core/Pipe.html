<div class="ocaml_toplevel_module"><div class="info">A pipe is a buffered FIFO communication channel.<br/>    A pipe has a &quot;writer&quot; end and a &quot;reader&quot; end.  The intent is that a writer feeds
    values into the pipe and then waits until it is notified that it should put more data
    in (referred to as &quot;pushback&quot;).<br/>    Each pipe contains a buffer that is a queue of values that have been written to the
    pipe but not yet read from the pipe.  The length of the queue is not bounded; whenever
    the pipe is written to, values are immediately enqueued.  However, writers are
    supposed to respect pushback from readers, either via the <code class="code">unit Deferred.t</code> returned
    by <code class="code">write</code> calls or by explicitly calling <code class="code">pushback</code>.<br/>    If a pipe is empty, then readers queue up, waiting for values to be written.  As soon
    as values are written, if a reader is available to consume them, the values will be
    handed to the reader.<br/>    One can use <code class="code">downstream_flushed</code> to get notified by a pipe when all prior writes have
    been consumed by a reader.<br/>    There are distinct <code class="code">Reader</code> and <code class="code">Writer</code> modules and types, but all of the operations
    on readers and writers are available directly from the <code class="code">Pipe</code> module.</div>
<pre><span class="TYPEt"><span class="keyword">type</span> <code class="type">('a, 'phantom) </code>t</span> </pre>
<pre><span class="TYPEpipe"><span class="keyword">type</span> <code class="type">('a, 'phantom) </code>pipe</span> = <code class="type">('a, 'phantom) <a href="?package=async_core&amp;module=Pipe&amp;type=t">t</a></code></pre>
<div class="info"><div class="info"><h1 id="1_TITLE">Reader and Writer modules</h1></div></div>
<div class="info"><div class="info">These provide reader- and writer-specific types for the base pipe type.</div></div>
<div class="ocaml_module sig" name="Writer"><pre><span class="keyword">module</span> <a href="?package=async_core&amp;module=Pipe.Writer">Writer</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEphantom"><span class="keyword">type</span> phantom</span> </pre>
<pre><span class="TYPEt"><span class="keyword">type</span> <code class="type">'a </code>t</span> = <code class="type">('a, <a href="?package=async_core&amp;module=Pipe.Writer&amp;type=phantom">phantom</a>) <a href="?package=async_core&amp;module=Pipe&amp;type=pipe">pipe</a></code></pre>
<pre><span class="VALinvariant"><span class="keyword">val</span> invariant</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Writer&amp;type=t">t</a> -&gt; unit</code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type">('a -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a>) -&gt; 'a <a href="?package=async_core&amp;module=Pipe.Writer&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre></div></div>
<div class="ocaml_module sig" name="Reader"><pre><span class="keyword">module</span> <a href="?package=async_core&amp;module=Pipe.Reader">Reader</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEphantom"><span class="keyword">type</span> phantom</span> </pre>
<pre><span class="TYPEt"><span class="keyword">type</span> <code class="type">'a </code>t</span> = <code class="type">('a, <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=phantom">phantom</a>) <a href="?package=async_core&amp;module=Pipe&amp;type=pipe">pipe</a></code></pre>
<pre><span class="VALinvariant"><span class="keyword">val</span> invariant</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">t</a> -&gt; unit</code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type">('a -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a>) -&gt; 'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre></div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Creation</h1></div></div>
<pre><span class="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">unit -&gt; 'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> * 'a <a href="?package=async_core&amp;module=Pipe.Writer&amp;type=t">Writer.t</a></code></pre><div class="info"><div class="info"><code class="code">create ()</code> creates a new pipe.</div></div>
<pre><span class="VALinit"><span class="keyword">val</span> init</span> : <code class="type">('a <a href="?package=async_core&amp;module=Pipe.Writer&amp;type=t">Writer.t</a> -&gt; unit <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a>) -&gt; 'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a></code></pre><div class="info"><div class="info"><code class="code">init f</code> creates a new pipe, applies <code class="code">f</code> to its writer end, and returns its reader
    end.  <code class="code">init</code> closes the writer end when the result of <code class="code">f</code> becomes determined.  If <code class="code">f</code>
    raises, the writer end is closed and the exception is raised to the caller of
    <code class="code">init</code>.</div></div>
<pre><span class="VALof_list"><span class="keyword">val</span> of_list</span> : <code class="type">'a list -&gt; 'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a></code></pre><div class="info"><div class="info"><code class="code">of_list l</code> returns a closed pipe reader filled with the contents of <code class="code">l</code>.</div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Closing</h1></div></div>
<pre><span class="VALclose"><span class="keyword">val</span> close</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Writer&amp;type=t">Writer.t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">close t</code> closes the write end of the pipe:<br/>    - Future write attempts will fail, raising an exception.<br/>    - If, at the time of the close, there are reads blocked waiting for data, these reads
    will unblock, producing <code class="code">`Eof</code>.<br/>    - Future read attempts will drain the data that was in the pipe at the time of the
    close, until the pipe's buffer has been exhausted; subsequent reads will immediately
    get <code class="code">`Eof</code>.<br/>    Thus, after a pipe has been closed, reads never block.<br/>    Close is idempotent.<br/>    <code class="code">close_read t</code> closes both the read and write ends of the pipe.  It does everything
    <code class="code">close</code> does, and in addition:<br/>    - all pending flushes become determined with <code class="code">`Reader_closed</code>.<ul><li>the pipe buffer is cleared.</li><li>all subsequent reads will get <code class="code">`Eof</code> </li></ul></div></div>
<pre><span class="VALclose_read"><span class="keyword">val</span> close_read</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt; unit</code></pre>
<pre><span class="VALis_closed"><span class="keyword">val</span> is_closed</span> : <code class="type">('a, 'b) <a href="?package=async_core&amp;module=Pipe&amp;type=t">t</a> -&gt; bool</code></pre><div class="info"><div class="info"><code class="code">is_closed t</code> returns <code class="code">true</code> iff <code class="code">close t</code> or <code class="code">close_read t</code> has been called.</div></div>
<pre><span class="VALclosed"><span class="keyword">val</span> closed</span> : <code class="type">('a, 'b) <a href="?package=async_core&amp;module=Pipe&amp;type=t">t</a> -&gt; unit <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">closed t</code> returns a deferred that becomes determined when <code class="code">close t</code> or <code class="code">close_read t</code>
    is called.</div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Flushing</h1></div></div>
<div class="ocaml_module sig" name="Flushed_result"><pre><span class="keyword">module</span> <a href="?package=async_core&amp;module=Pipe.Flushed_result">Flushed_result</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEt"><span class="keyword">type</span> t</span> = <code class="type">[ `Ok | `Reader_closed ]</code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type"><a href="?package=async_core&amp;module=Pipe.Flushed_result&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre></div></div>
<pre><span class="VALupstream_flushed"><span class="keyword">val</span> upstream_flushed</span> : <code class="type">('a, 'b) <a href="?package=async_core&amp;module=Pipe&amp;type=t">t</a> -&gt; <a href="?package=async_core&amp;module=Pipe.Flushed_result&amp;type=t">Flushed_result.t</a> <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a></code></pre><div class="info"><div class="info">Deferreds returned by <code class="code">upstream_flushed</code> and <code class="code">downstream_flushed</code> become determined
    when all values written prior to the call have been consumed, or if the reader end of
    the pipe is closed.  The difference between &quot;upstream&quot; and &quot;downstream&quot; comes if one
    has a chain of pipes that are linked (e.g. by <code class="code">Pipe.map</code>):<br/>    <span class="verbatim">      P1 --&gt; P2 --&gt; P3
    </span><br/>    Calling <code class="code">downstream_flushed P2</code> ensures that everything in P2 has made it out of P3.
    Calling <code class="code">upstream_flushed P2</code> ensures that everything in P1 has made it out of P3.
    More generally, <code class="code">downstream_flushed</code> starts at the current pipe and follows the chain
    to the final downstream consumer(s).  <code class="code">upstream_flushed</code> follows the chain to the
    initial upstream pipe(s), and then calls <code class="code">downstream_flushed</code>.<br/>    For a pipe in isolation, &quot;consumed&quot; means &quot;read from the pipe&quot;.  However, for pipes
    linked together with <code class="code">transfer</code> or any function built from <code class="code">transfer</code>, &quot;consumed&quot;
    means &quot;propagated all the way downstream through the chain and read from the final
    pipe in the chain&quot;.  Furthermore, for a pipe ultimately connected to an
    <code class="code">Async.Writer</code>, &quot;consumed&quot; means the OS write() system call has completed on the bytes
    read from the final pipe in the chain.<br/>    The following <code class="code">Pipe</code> functions automatically link their input and output pipes
    together so that <code class="code">*_flushed</code> on upstream pipes will propagate to downstream pipes:
    <code class="code">transfer*</code>, <code class="code">map*</code>, <code class="code">filter_map*</code>, <code class="code">filter</code>, <code class="code">interleave</code>, <code class="code">concat</code>.  There is *not*
    automatic linking with <code class="code">iter*</code>; however, user code can customize the behavior of
    flush functions using <code class="code">Consumer</code>, see below.</div></div>
<pre><span class="VALdownstream_flushed"><span class="keyword">val</span> downstream_flushed</span> : <code class="type">('a, 'b) <a href="?package=async_core&amp;module=Pipe&amp;type=t">t</a> -&gt; <a href="?package=async_core&amp;module=Pipe.Flushed_result&amp;type=t">Flushed_result.t</a> <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a></code></pre>
<div class="ocaml_module sig" name="Consumer"><pre><span class="keyword">module</span> <a href="?package=async_core&amp;module=Pipe.Consumer">Consumer</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEt"><span class="keyword">type</span> t</span> </pre><div class="info"><div class="info">A <code class="code">Consumer</code> is used to augment our notion of flushing (<code class="code">Pipe.upstream_flushed</code> and
      <code class="code">Pipe.downstream_flushed</code>) to include the time spent processing an element once it
      has been removed from the pipe.  It can be thought of as sitting at the end of a
      pipe, or between two pipes, and it provides more detailed feedback on the time an
      element spends outside of the pipe proper.  So we have the following two cases:<br/>      <span class="verbatim">        Pipe --&gt; Consumer
        Pipe --&gt; Consumer --&gt; Pipe --&gt; ...
      </span><br/>      The time outside of the pipe can be broken down into two parts: a part (probably
      short lived) during which the consumer processes the elements in some way, and a
      downstream portion where the consumer acts as a sentinel to report when the element
      has been fully processed.<br/>      For instance, consider the simple case of a pipe attached to an <code class="code">Async.Std.Writer</code>
      that is writing elements to disk.  Part one would be whatever transform the consumer
      applies to the elements in the pipe before it hands them off to the writer, and part
      two would be waiting for the writer to finish writing the transformed element to
      disk.  A more complex case is chaining two pipes together (maybe with a transform
      like <code class="code">map</code>).  Part one in this case is the transform and the write to the downstream
      pipe, and part two is waiting for that pipe (and any further pipes in the chain) to
      flush.<br/>      In each case the consumer is responsible for indicating when:<br/>      - it has finished any local work (by attaching itself to elements via the ~consumer
      argument to <code class="code">read</code> and <code class="code">read'</code>) and calling <code class="code">values_sent_downstream</code> when it has
      sent the values downstream.<br/>      - when any further processing has been completed (by providing an appropriate
      function to <code class="code">~downstream_flushed</code> when <code class="code">add_consumer</code> is called).<br/>      If a reader does not use a consumer to do the reading then an element is considered
      flushed the moment it leaves the pipe.  This may lead to odd results as entire
      queues of elements are removed by a call to <code class="code">read'</code> but are processed over a long
      period.</div></div>
<pre><span class="VALvalues_sent_downstream"><span class="keyword">val</span> values_sent_downstream</span> : <code class="type"><a href="?package=async_core&amp;module=Pipe.Consumer&amp;type=t">t</a> -&gt; unit</code></pre></div></div>
<pre><span class="VALadd_consumer"><span class="keyword">val</span> add_consumer</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt;
downstream_flushed:(unit -&gt; <a href="?package=async_core&amp;module=Pipe.Flushed_result&amp;type=t">Flushed_result.t</a> <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a>) -&gt; <a href="?package=async_core&amp;module=Pipe.Consumer&amp;type=t">Consumer.t</a></code></pre><div class="info"><div class="info"><code class="code">add_consumer reader ~downstream_flushed</code> creates a new consumer of <code class="code">reader</code>, and
    causes future calls to <code class="code">flushed_downstream reader</code> to take this consumer into account.
    Thereafter, <code class="code">Pipe.flushed_downstream reader</code> will first ensure that values previously
    written to <code class="code">reader</code> have been read, then that they have been sent downstream by the
    consumer that read them, and finally that they have been flushed downstream.<br/>    One should only supply the resulting consumer to read operations on <code class="code">reader</code>.  Using
    a consumer created from one reader with another reader will raise an exception.</div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Generic pipe operations</h1></div></div>
<div class="info"><div class="info">These operations apply to all values of type <code class="code">(_, _) t</code>, that is, both readers and
    writers.</div></div>
<pre><span class="VALlength"><span class="keyword">val</span> length</span> : <code class="type">('a, 'b) <a href="?package=async_core&amp;module=Pipe&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">length t</code> returns the number of elements currently queued in <code class="code">t</code></div></div>
<pre><span class="VALis_empty"><span class="keyword">val</span> is_empty</span> : <code class="type">('a, 'b) <a href="?package=async_core&amp;module=Pipe&amp;type=t">t</a> -&gt; bool</code></pre><div class="info"><div class="info"><code class="code">is_empty t</code> is true iff there are no values in the pipe.</div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Writing</h1></div></div>
<div class="info"><div class="info">The write operations return a deferred value that is determined when either (1) it is
    OK to write again to the pipe or (2) the pipe has been closed.  This deferred is the
    data-producer's interface to the pipe pushback mechanism: it tells the producer when
    it should proceed after doing a write -- either to produce and write more data to the
    pipe, or to abandon production entirely.  The pushback mechansim is just advisory: a
    producer task can, but typically should not, dump arbitrary amounts of data into a
    pipe even if there is no consumer draining the pipe.<br/>    Producers that write a sequence of values to a pipe should be aware that the consumers
    who read from the pipe can close the pipe early -- that is, before the producer has
    finished doing all of its writes.  If this happens, further writes will raise an
    exception.  To avoid these errors, all writes must be atomically guarded by
    <code class="code">is_closed</code> tests.  Thus, a typical writer loop should look like this:<br/>    <pre class="codepre"><code class="code">
    fun countup hi w = (* Send the ints in range [0,hi) to writer W. *)
      let rec loop i =
        if i &lt; hi and not (is_closed w) then (* Guard write w/closed test. *)
          write i w &gt;&gt;&gt;            (* Do the write then block until datum     *)
          fun () -&gt; loop (i+1)     (*   fits or the pipe is closed.           *)
        else close w (* No harm done if reader has already closed the pipe.*)
      in
      loop 0
    </code></pre><br/>    If the pipe's consumer stops reading early and closes the pipe, <code class="code">countup</code> won't error
    out trying to write further values down the pipe: it will immediately wake up and
    exit.</div></div>
<pre><span class="VALpushback"><span class="keyword">val</span> pushback</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Writer&amp;type=t">Writer.t</a> -&gt; unit <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">pushback writer</code> becomes determined when either <code class="code">writer</code> has been closed or
    the pipe is empty.</div></div>
<pre><span class="VALwrite'"><span class="keyword">val</span> write'</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Writer&amp;type=t">Writer.t</a> -&gt; 'a <a href="?package=core&amp;module=Std.Queue&amp;type=t">Core.Std.Queue.t</a> -&gt; unit <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">write' writer q</code> transfers the elements from <code class="code">q</code> into the pipe, leaving <code class="code">q</code> empty.
    <code class="code">write'</code> returns a pushback deferred, as described above.  Writing to a closed pipe
    raises.<br/>    <code class="code">write writer v</code> is equivalent to <code class="code">write' writer (Queue.singleton v)</code>.</div></div>
<pre><span class="VALwrite"><span class="keyword">val</span> write</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Writer&amp;type=t">Writer.t</a> -&gt; 'a -&gt; unit <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a></code></pre>
<pre><span class="VALwrite_without_pushback'"><span class="keyword">val</span> write_without_pushback'</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Writer&amp;type=t">Writer.t</a> -&gt; 'a <a href="?package=core&amp;module=Std.Queue&amp;type=t">Core.Std.Queue.t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">write_without_pushback'</code> and <code class="code">write_without_pushback</code> are alternatives to <code class="code">write'</code>
    and <code class="code">write</code> that can be used when you don't care about the resultant deferred. The
    data is added to the pipe and then we return immediately.<br/>    <code class="code">write' t values</code> is equivalent to <code class="code">write_without_pushback' t values; pushback t</code> (and
    similarly for <code class="code">write</code>).</div></div>
<pre><span class="VALwrite_without_pushback"><span class="keyword">val</span> write_without_pushback</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Writer&amp;type=t">Writer.t</a> -&gt; 'a -&gt; unit</code></pre>
<pre><span class="VALwrite_when_ready"><span class="keyword">val</span> write_when_ready</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Writer&amp;type=t">Writer.t</a> -&gt; f:(('a -&gt; unit) -&gt; 'b) -&gt; [ `Closed | `Ok of 'b ] <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">write_when_ready writer ~f</code> waits until there is space available in the pipe, and
    then calls <code class="code">f write</code>, where <code class="code">write</code> can be used by <code class="code">f</code> to write a single value into
    the pipe at a time.  <code class="code">write_when_ready</code> guarantees that the pipe is open when it calls
    <code class="code">f</code>, and hence that the writes will succeed, unless <code class="code">f</code> itself closes the pipe.</div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Reading</h1></div></div>
<div class="info"><div class="info">With two special exceptions, all read procedures have a best-effort/forward-progress
    semantics:<br/>    - Best effort: When you do a read, you get what's available <em>right now</em>, which might
    be less than you requested.<br/>    - Forward progress: However, if <em>nothing is available</em>, you block until some data
    comes in (unless you're at EOF, in which case there's obviously no point in waiting).
    So the only time you ever get an empty, 0-item read is when you're at EOF.<br/>    The best-effort semantics allows you to program in a style that processes data in big
    slabs, yet also moves data through your processing in as timely a way as possible.<br/>    The forward-progress semantics means that every call produces <em>some</em> data, so you
    can process an n-element input with at most n reads; you cannot burn an unbounded
    number of cycles &quot;spinning&quot; doing an unbounded number of empty-result &quot;polling&quot; calls
    (which, in a non-preemptive system like Async could lock up the process).<br/>    The two exceptions to best-effort/forward-progress semantics are <code class="code">read_now</code>, which
    polls for data, thus abandoning the forward-progress guarantee, and <code class="code">read_exactly</code>,
    which loops until it has read the entire amount requested (or encountered EOF), thus
    abandoning the best-effort guarantee of timeliness.</div></div>
<pre><span class="VALread'"><span class="keyword">val</span> read'</span> : <code class="type">?consumer:<a href="?package=async_core&amp;module=Pipe.Consumer&amp;type=t">Consumer.t</a> -&gt;
'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt; [ `Eof | `Ok of 'a <a href="?package=core&amp;module=Std.Queue&amp;type=t">Core.Std.Queue.t</a> ] <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">read' pipe</code> reads all of the values available in the pipe, as soon as any value
    becomes available.  The resulting queue will satisfy <code class="code">Q.length q &gt; 0</code>.  The <code class="code">consumer</code>
    is used to extend the meaning of values being flushed (see the <code class="code">Consumer</code> module
    above).</div></div>
<pre><span class="VALread"><span class="keyword">val</span> read</span> : <code class="type">?consumer:<a href="?package=async_core&amp;module=Pipe.Consumer&amp;type=t">Consumer.t</a> -&gt; 'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt; [ `Eof | `Ok of 'a ] <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">read pipe</code> reads a single value from the pipe.  The <code class="code">consumer</code> is used to extend the
    meaning of values being flushed (see the <code class="code">Consumer</code> module above).</div></div>
<pre><span class="VALread_at_most"><span class="keyword">val</span> read_at_most</span> : <code class="type">?consumer:<a href="?package=async_core&amp;module=Pipe.Consumer&amp;type=t">Consumer.t</a> -&gt;
'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt;
num_values:int -&gt; [ `Eof | `Ok of 'a <a href="?package=core&amp;module=Std.Queue&amp;type=t">Core.Std.Queue.t</a> ] <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">read_at_most r ~num_values</code> reads up to <code class="code">num_values</code> values from the pipe's currently
    available data, blocking if the pipe is empty.  The resulting queue will satisfy <code class="code">0 &lt;
    Queue.length q &lt;= num_values</code>.  <code class="code">read_at_most</code> raises if <code class="code">num_values &lt;= 0</code>.  The
    <code class="code">consumer</code> is used to extend the meaning of values being flushed (see the <code class="code">Consumer</code>
    module above).</div></div>
<pre><span class="VALread_exactly"><span class="keyword">val</span> read_exactly</span> : <code class="type">?consumer:<a href="?package=async_core&amp;module=Pipe.Consumer&amp;type=t">Consumer.t</a> -&gt;
'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt;
num_values:int -&gt;
[ `Eof | `Exactly of 'a <a href="?package=core&amp;module=Std.Queue&amp;type=t">Core.Std.Queue.t</a> | `Fewer of 'a <a href="?package=core&amp;module=Std.Queue&amp;type=t">Core.Std.Queue.t</a> ]
<a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">read_exactly r ~num_values</code> reads exactly <code class="code">num_values</code> items, unless EOF is
    encountered.  <code class="code">read_exactly</code> performs a sequence of <code class="code">read_at_most</code> operations, so
    there is no guarantee that the queue of values it returns comprise a contiguous
    segment of the written stream of values -- other readers might pick off elements
    in-between <code class="code">read_exactly</code>'s atomic reads.  <code class="code">read_exactly</code> raises if <code class="code">num_values &lt;= 0</code>.
    The <code class="code">consumer</code> is used to extend the meaning of values being flushed (see the
    <code class="code">Consumer</code> module above).</div></div>
<pre><span class="VALread_now'"><span class="keyword">val</span> read_now'</span> : <code class="type">?consumer:<a href="?package=async_core&amp;module=Pipe.Consumer&amp;type=t">Consumer.t</a> -&gt;
'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt; [ `Eof | `Nothing_available | `Ok of 'a <a href="?package=core&amp;module=Std.Queue&amp;type=t">Core.Std.Queue.t</a> ]</code></pre><div class="info"><div class="info"><code class="code">read_now' reader</code> reads all of the values from <code class="code">reader</code> that are immediately
    available.  The resulting queue will satisfy <code class="code">Q.length q &gt; 0</code>.  If <code class="code">reader</code> is closed,
    <code class="code">read_now'</code> returns <code class="code">`Eof</code>.  If <code class="code">reader</code> is empty, <code class="code">read_now'</code> returns
    <code class="code">`Nothing_available</code>.  <code class="code">read_now'</code> has the danger of permitting the computation to
    &quot;spin&quot; doing empty reads; it is only useful in exotic circumstances.  The <code class="code">consumer</code>
    is used to extend the meaning of values being flushed (see the <code class="code">Consumer</code> module
    above).<br/>    <code class="code">read_now</code> is like <code class="code">read_now'</code>, except that it reads a single value rather than
    everything that is available.</div></div>
<pre><span class="VALread_now"><span class="keyword">val</span> read_now</span> : <code class="type">?consumer:<a href="?package=async_core&amp;module=Pipe.Consumer&amp;type=t">Consumer.t</a> -&gt;
'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt; [ `Eof | `Nothing_available | `Ok of 'a ]</code></pre>
<pre><span class="VALpeek"><span class="keyword">val</span> peek</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt; 'a option</code></pre>
<pre><span class="VALclear"><span class="keyword">val</span> clear</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">clear reader</code> consumes all of the values currently in <code class="code">reader</code>, and all blocked
    flushes become determined with <code class="code">`Ok</code>.</div></div>
<pre><span class="VALread_all"><span class="keyword">val</span> read_all</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt; 'a <a href="?package=core&amp;module=Std.Queue&amp;type=t">Core.Std.Queue.t</a> <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">read_all reader</code> reads all the values from the pipe until it is closed.  An
    alternative name might be <code class="code">Reader.to_queue</code>.</div></div>
<pre><span class="VALvalues_available"><span class="keyword">val</span> values_available</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt; [ `Eof | `Ok ] <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">values_available reader</code> returns a deferred that becomes determined when there are
    values in the pipe.  If there are multiple readers (a rare situation), there is no
    guarantee that some other reader hasn't become active because of ordinary async
    scheduling and removed some or all of the values between the time the result of
    <code class="code">values_available</code> becomes determined and the time something waiting <code class="code">upon</code> that
    result runs.<br/>    <code class="code">values_available</code> is useful when one wants to <code class="code">choose</code> on values being available in a
    pipe, so that one can be sure and not remove values and drop them on the floor.<br/>    <code class="code">values_available</code> is roughly equivalent to <code class="code">read_at_most ~num_values:0</code>.</div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Sequence functions</h1></div></div>
<div class="info"><div class="info">Issues: <ul><li>Early-close and functions that copy between pipes<br/>    Some functions (<code class="code">transfer</code>, <code class="code">map</code>, <code class="code">filter_map</code>, <code class="code">filter</code>, <code class="code">interleave</code>, <code class="code">concat</code>, and
    their primed, batch-processing variants) spawn a background task that copies data from
    some upstream pipe to some downstream pipe, perhaps with some processing inserted
    in-between.  These copying tasks finish under two circumstances.  The standard,
    &quot;normal&quot; case is when the copying task gets EOF from the upstream pipe -- there is no
    more data to copy.  In this case, the copying task closes the downstream pipe and
    exits.<br/>    Somewhat less common is when the downstream consumer decides to stop reading early,
    while the upstream producer is still sending data to the copy task.  (E.g., perhaps
    the consumer was searching its incoming stream for some value, and it found that
    value, so there's no need to search further.)  In this case, the consumer closes its
    pipe to indicate it's done reading values.  When the copy task discovers that its
    downstream pipe is closed, it propagates the close to the upstream producer by closing
    its pipe and stops processing. </li><li>Scalar &amp; batch sequence processing<br/>    Each of the sequence functions (fold, iter, transfer, map) comes in two versions:
    &quot;scalar&quot; and &quot;batch&quot; processing.  The scalar version has the ordinary type for <code class="code">f</code>,
    which handles an element at a time in a non-deferred way.  In the batch version, <code class="code">f</code>
    deals with a queue of elements from the pipe at a time, and can block, which will
    cause pushback on writers due to elements not being consumed. </li></ul></div></div>
<pre><span class="TYPEfold"><span class="keyword">type</span> <code class="type">('a, 'b, 'c, 'accum) </code>fold</span> = <code class="type">?consumer:<a href="?package=async_core&amp;module=Pipe.Consumer&amp;type=t">Consumer.t</a> -&gt;
'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt; init:'accum -&gt; f:('accum -&gt; 'b -&gt; 'c) -&gt; 'accum <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">fold' reader ~init ~f</code> reads a batch of elements from <code class="code">reader</code>, supplies them to <code class="code">f</code>,
    waits for <code class="code">f</code> to finish, and then repeats.  <code class="code">fold'</code> finishes when the call to <code class="code">f</code> on
    the final batch of elements from <code class="code">reader</code> finishes.<br/>    <code class="code">fold reader ~init ~f</code> folds over the elements of <code class="code">reader</code>, consuming them as they
    come in.  <code class="code">fold</code> finishes when the final call to <code class="code">f</code> returns.<br/>    The <code class="code">consumer</code> is used to extend the meaning of values being flushed (see the
    <code class="code">Consumer</code> module above).</div></div>
<pre><span class="VALfold'"><span class="keyword">val</span> fold'</span> : <code class="type">('a, 'a <a href="?package=core&amp;module=Std.Queue&amp;type=t">Core.Std.Queue.t</a>, 'accum <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a>, 'accum) <a href="?package=async_core&amp;module=Pipe&amp;type=fold">fold</a></code></pre>
<pre><span class="VALfold"><span class="keyword">val</span> fold</span> : <code class="type">('a, 'a, 'accum <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a>, 'accum) <a href="?package=async_core&amp;module=Pipe&amp;type=fold">fold</a></code></pre>
<pre><span class="VALfold_without_pushback"><span class="keyword">val</span> fold_without_pushback</span> : <code class="type">('a, 'a, 'accum, 'accum) <a href="?package=async_core&amp;module=Pipe&amp;type=fold">fold</a></code></pre>
<pre><span class="TYPEiter"><span class="keyword">type</span> <code class="type">('a, 'b, 'c) </code>iter</span> = <code class="type">?consumer:<a href="?package=async_core&amp;module=Pipe.Consumer&amp;type=t">Consumer.t</a> -&gt;
?continue_on_error:bool -&gt; 'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt; f:('b -&gt; 'c) -&gt; unit <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">iter' reader ~f</code> repeatedly applies <code class="code">f</code> to batches of elements of <code class="code">reader</code>, waiting
    for each call to <code class="code">f</code> to finish before continuing.  The deferred returned by <code class="code">iter'</code>
    becomes determined when the call to <code class="code">f</code> on the final batch of elements finishes.<br/>    <code class="code">iter</code> is a specialization of <code class="code">iter'</code> that applies the supplied <code class="code">f</code> to each element in
    the batch, waiting for one call to <code class="code">f</code> to finish before making the next call to <code class="code">f</code>.<br/>    <code class="code">iter_without_pushback</code> is a specialized version that applies <code class="code">f</code> to each element
    that arrives on the pipe, without giving <code class="code">f</code> a chance to pushback on the iteration
    continuing.<br/>    Supplying <code class="code">~continue_on_error:true</code> causes the iteration to continue even if <code class="code">f</code>
    raises.<br/>    The <code class="code">consumer</code> is used to extend the meaning of values being flushed (see the
    <code class="code">Consumer</code> module above).</div></div>
<pre><span class="VALiter'"><span class="keyword">val</span> iter'</span> : <code class="type">('a, 'a <a href="?package=core&amp;module=Std.Queue&amp;type=t">Core.Std.Queue.t</a>, unit <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a>) <a href="?package=async_core&amp;module=Pipe&amp;type=iter">iter</a></code></pre>
<pre><span class="VALiter"><span class="keyword">val</span> iter</span> : <code class="type">('a, 'a, unit <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a>) <a href="?package=async_core&amp;module=Pipe&amp;type=iter">iter</a></code></pre>
<pre><span class="VALiter_without_pushback"><span class="keyword">val</span> iter_without_pushback</span> : <code class="type">('a, 'a, unit) <a href="?package=async_core&amp;module=Pipe&amp;type=iter">iter</a></code></pre>
<pre><span class="VALtransfer'"><span class="keyword">val</span> transfer'</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt;
'b <a href="?package=async_core&amp;module=Pipe.Writer&amp;type=t">Writer.t</a> -&gt;
f:('a <a href="?package=core&amp;module=Std.Queue&amp;type=t">Core.Std.Queue.t</a> -&gt; 'b <a href="?package=core&amp;module=Std.Queue&amp;type=t">Core.Std.Queue.t</a> <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a>) -&gt; unit <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">transfer' input output ~f ?stop</code> repeatedly reads a batch of elements from <code class="code">input</code>,
    applies <code class="code">f</code> to the batch, writes the result as a batch to <code class="code">output</code>, and then waits on
    <code class="code">pushback</code> in <code class="code">output</code> before continuing.  <code class="code">transfer'</code> finishes if <code class="code">input</code> is closed,
    or <code class="code">output</code> is closed, or <code class="code">stop</code> is determined.  If <code class="code">output</code> is closed, then
    <code class="code">transfer'</code> closes <code class="code">input</code>.<br/>    <code class="code">transfer</code> is a specialization of <code class="code">transfer'</code> that uses <code class="code">Queue.map ~f</code>.<br/>    <code class="code">transfer_id</code> is a specialization of <code class="code">transfer'</code> wifh <code class="code">f = Fn.id</code>.</div></div>
<pre><span class="VALtransfer"><span class="keyword">val</span> transfer</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt; 'b <a href="?package=async_core&amp;module=Pipe.Writer&amp;type=t">Writer.t</a> -&gt; f:('a -&gt; 'b) -&gt; unit <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a></code></pre>
<pre><span class="VALtransfer_id"><span class="keyword">val</span> transfer_id</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt; 'a <a href="?package=async_core&amp;module=Pipe.Writer&amp;type=t">Writer.t</a> -&gt; unit <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a></code></pre>
<pre><span class="VALmap'"><span class="keyword">val</span> map'</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt;
f:('a <a href="?package=core&amp;module=Std.Queue&amp;type=t">Core.Std.Queue.t</a> -&gt; 'b <a href="?package=core&amp;module=Std.Queue&amp;type=t">Core.Std.Queue.t</a> <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a>) -&gt; 'b <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a></code></pre><div class="info"><div class="info"><code class="code">map' input ~f</code> returns a reader, <code class="code">output</code>, and repeatedly applies <code class="code">f</code> to batches of
    elements from <code class="code">input</code>, with the results appearing in <code class="code">output</code>.  If values are not
    being consumed from <code class="code">output</code>, <code class="code">map'</code> will pushback and stop consuming values from
    <code class="code">input</code>.<br/>    If <code class="code">output</code> is closed, then <code class="code">map'</code> will close <code class="code">input</code>.<br/>    <code class="code">map</code> is a specialization of <code class="code">map'</code> that uses <code class="code">Queue.map ~f</code>.</div></div>
<pre><span class="VALmap"><span class="keyword">val</span> map</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt; f:('a -&gt; 'b) -&gt; 'b <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a></code></pre>
<pre><span class="VALfilter_map'"><span class="keyword">val</span> filter_map'</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt; f:('a -&gt; 'b option <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a>) -&gt; 'b <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a></code></pre><div class="info"><div class="info"><code class="code">filter_map' input ~f</code> returns a reader, <code class="code">output</code>, and repeatedly applies <code class="code">f</code> to
    elements from <code class="code">input</code>, with the results that aren't <code class="code">None</code> appearing in <code class="code">output</code>.  If
    values are not being consumed from <code class="code">output</code>, <code class="code">filter_map'</code> will pushback and stop
    consuming values from <code class="code">input</code>.<br/>    If <code class="code">output</code> is closed, then <code class="code">filter_map'</code> will close <code class="code">input</code>.<br/>    <code class="code">filter_map</code> is a specialized version of <code class="code">filter_map'</code>.</div></div>
<pre><span class="VALfilter_map"><span class="keyword">val</span> filter_map</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt; f:('a -&gt; 'b option) -&gt; 'b <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a></code></pre>
<pre><span class="VALfilter"><span class="keyword">val</span> filter</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt; f:('a -&gt; bool) -&gt; 'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a></code></pre><div class="info"><div class="info"><code class="code">filter input ~f</code> returns a reader, <code class="code">output</code>, and copies to <code class="code">output</code> each element from
    <code class="code">input</code> that satisfies the predicate <code class="code">f</code>.  If <code class="code">output</code> is closed, then <code class="code">filter</code> closes
    <code class="code">input</code>.</div></div>
<pre><span class="VALinterleave"><span class="keyword">val</span> interleave</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> list -&gt; 'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a></code></pre><div class="info"><div class="info"><code class="code">interleave inputs</code> returns a reader <code class="code">output</code>, and, for each input, transfers batches
    of values from that input to <code class="code">output</code>, using <code class="code">transfer_id</code>.  Each input is transferred
    to <code class="code">output</code> independently.  So, batches of values from different inputs can be in
    flight to <code class="code">output</code> simultaneously, but at most one batch at a time from any particular
    input.  The operation is complete when either all the <code class="code">inputs</code> produce EOF, or when
    <code class="code">output</code> is closed by the downstream consumer (in which case <code class="code">interleave</code> closes all
    the <code class="code">inputs</code>).</div></div>
<pre><span class="VALmerge"><span class="keyword">val</span> merge</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> list -&gt; cmp:('a -&gt; 'a -&gt; int) -&gt; 'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a></code></pre><div class="info"><div class="info"><code class="code">merge inputs ~cmp</code> returns a reader, <code class="code">output</code>, that merges all the inputs.  Assuming
    that for each input, values are sorted according to the comparison function <code class="code">cmp</code>,
    values for each input will be transfered to <code class="code">output</code> and the values returned by
    <code class="code">output</code> will be sorted according to <code class="code">cmp</code>.</div></div>
<pre><span class="VALconcat"><span class="keyword">val</span> concat</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> list -&gt; 'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a></code></pre><div class="info"><div class="info"><code class="code">concat inputs</code> return a reader, <code class="code">output</code>, with the values from each pipe in <code class="code">inputs</code>
    in sequence.  <code class="code">concat</code> closes <code class="code">output</code> once it reaches EOF on the final input.
    If <code class="code">output</code> is closed, then <code class="code">concat</code> closes all its inputs.</div></div>
<pre><span class="VALto_stream_deprecated"><span class="keyword">val</span> to_stream_deprecated</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt; 'a <a href="?package=async_core&amp;module=Async_stream&amp;type=t">Async_stream.t</a></code></pre><div class="info"><div class="info"><code class="code">to_stream_deprecated reader</code> returns a stream that reads everything from the pipe.
    This function is deprecated because one should change the code that is consuming
    a stream to instead consume from a pipe reader.</div></div>
<pre><span class="VALof_stream_deprecated"><span class="keyword">val</span> of_stream_deprecated</span> : <code class="type">'a <a href="?package=async_core&amp;module=Async_stream&amp;type=t">Async_stream.t</a> -&gt; 'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a></code></pre><div class="info"><div class="info"><code class="code">of_stream_deprecated reader</code> return a pipe that has one element for every element on
    the stream.  This function is deprecated because one should change the code that is
    producing a stream to instead produce a pipe reader.</div></div>
<pre><span class="VALdrain"><span class="keyword">val</span> drain</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt; unit <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">drain reader</code> repeatedly reads values from <code class="code">reader</code> and throws them away.<br/>    <code class="code">drain_and_count</code> is like <code class="code">drain</code>, except it also counts the number of values it
    has read.</div></div>
<pre><span class="VALdrain_and_count"><span class="keyword">val</span> drain_and_count</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt; int <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a></code></pre>
<pre><span class="VALto_list"><span class="keyword">val</span> to_list</span> : <code class="type">'a <a href="?package=async_core&amp;module=Pipe.Reader&amp;type=t">Reader.t</a> -&gt; 'a list <a href="?package=async_core&amp;module=Deferred&amp;type=t">Deferred.t</a></code></pre><div class="info"><div class="info"><code class="code">to_list input</code> reads everything from <code class="code">input</code>; on EOF, it produces the accumulated
    list of these values.</div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Miscellaneous</h1></div></div>
<pre><span class="VALhash"><span class="keyword">val</span> hash</span> : <code class="type">('a, 'b) <a href="?package=async_core&amp;module=Pipe&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">hash</code> a hash function suitable for pipes</div></div>
<pre><span class="VALequal"><span class="keyword">val</span> equal</span> : <code class="type">('a, 'b) <a href="?package=async_core&amp;module=Pipe&amp;type=t">t</a> -&gt; ('a, 'b) <a href="?package=async_core&amp;module=Pipe&amp;type=t">t</a> -&gt; bool</code></pre><div class="info"><div class="info"><code class="code">equal</code> on pipes is physical equality.</div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Size budget</h1></div></div>
<pre><span class="VALsize_budget"><span class="keyword">val</span> size_budget</span> : <code class="type">('a, 'b) <a href="?package=async_core&amp;module=Pipe&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info">Every pipe has a &quot;size budget&quot;, which governs the pushback that is used to discourage
    writers from enqueueing arbitrarily large amounts of data.  As long as the length of
    the pipe exceeds the size budget, writers will not be notified to do further writing.
    Whenver the length is less than or equal to the size budget, writers will be notified
    to continue.<br/>    Every pipe's initial size budget is zero.</div></div>
<pre><span class="VALset_size_budget"><span class="keyword">val</span> set_size_budget</span> : <code class="type">('a, 'b) <a href="?package=async_core&amp;module=Pipe&amp;type=t">t</a> -&gt; int -&gt; unit</code></pre><div class="info"><div class="info"><code class="code">set_size_budget t i</code> changes the size budget of <code class="code">t</code> to <code class="code">i</code>.  Any nonnegative value is
    allowed.</div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Debugging</h1></div></div>
<pre><span class="VALshow_debug_messages"><span class="keyword">val</span> show_debug_messages</span> : <code class="type">bool <a href="?package=ocaml&amp;module=Pervasives&amp;type=ref">Pervasives.ref</a></code></pre><div class="info"><div class="info"><code class="code">show_debug_messages</code>, if true will cause a message to be printed at the start of each
    operation, showing the pipe and other arguments.</div></div>
<pre><span class="VALcheck_invariant"><span class="keyword">val</span> check_invariant</span> : <code class="type">bool <a href="?package=ocaml&amp;module=Pervasives&amp;type=ref">Pervasives.ref</a></code></pre><div class="info"><div class="info"><code class="code">check_invariant</code>, if true, will cause pipes' invariants to be checked at the start of
    each operation.</div></div>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type">('a -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a>) -&gt;
('phantom -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a>) -&gt; ('a, 'phantom) <a href="?package=async_core&amp;module=Pipe&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre>
<pre><span class="VALsexp_of_pipe"><span class="keyword">val</span> sexp_of_pipe</span> : <code class="type">('a -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a>) -&gt;
('phantom -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a>) -&gt; ('a, 'phantom) <a href="?package=async_core&amp;module=Pipe&amp;type=pipe">pipe</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre>
<div class="info"><div class="info"><h1 id="1_TITLE">Reader and Writer modules</h1></div></div>
<div class="info"><div class="info">These provide reader- and writer-specific types for the base pipe type.</div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Creation</h1></div></div>
<div class="info"><div class="info"><code class="code">create ()</code> creates a new pipe.</div></div>
<div class="info"><div class="info"><code class="code">init f</code> creates a new pipe, applies <code class="code">f</code> to its writer end, and returns its reader
    end.  <code class="code">init</code> closes the writer end when the result of <code class="code">f</code> becomes determined.  If <code class="code">f</code>
    raises, the writer end is closed and the exception is raised to the caller of
    <code class="code">init</code>.</div></div>
<div class="info"><div class="info"><code class="code">of_list l</code> returns a closed pipe reader filled with the contents of <code class="code">l</code>.</div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Closing</h1></div></div>
<div class="info"><div class="info"><code class="code">close t</code> closes the write end of the pipe:<br/>    - Future write attempts will fail, raising an exception.<br/>    - If, at the time of the close, there are reads blocked waiting for data, these reads
    will unblock, producing <code class="code">`Eof</code>.<br/>    - Future read attempts will drain the data that was in the pipe at the time of the
    close, until the pipe's buffer has been exhausted; subsequent reads will immediately
    get <code class="code">`Eof</code>.<br/>    Thus, after a pipe has been closed, reads never block.<br/>    Close is idempotent.<br/>    <code class="code">close_read t</code> closes both the read and write ends of the pipe.  It does everything
    <code class="code">close</code> does, and in addition:<br/>    - all pending flushes become determined with <code class="code">`Reader_closed</code>.<ul><li>the pipe buffer is cleared.</li><li>all subsequent reads will get <code class="code">`Eof</code> </li></ul></div></div>
<div class="info"><div class="info"><code class="code">is_closed t</code> returns <code class="code">true</code> iff <code class="code">close t</code> or <code class="code">close_read t</code> has been called.</div></div>
<div class="info"><div class="info"><code class="code">closed t</code> returns a deferred that becomes determined when <code class="code">close t</code> or <code class="code">close_read t</code>
    is called.</div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Flushing</h1></div></div>
<div class="info"><div class="info">Deferreds returned by <code class="code">upstream_flushed</code> and <code class="code">downstream_flushed</code> become determined
    when all values written prior to the call have been consumed, or if the reader end of
    the pipe is closed.  The difference between &quot;upstream&quot; and &quot;downstream&quot; comes if one
    has a chain of pipes that are linked (e.g. by <code class="code">Pipe.map</code>):<br/>    <span class="verbatim">      P1 --&gt; P2 --&gt; P3
    </span><br/>    Calling <code class="code">downstream_flushed P2</code> ensures that everything in P2 has made it out of P3.
    Calling <code class="code">upstream_flushed P2</code> ensures that everything in P1 has made it out of P3.
    More generally, <code class="code">downstream_flushed</code> starts at the current pipe and follows the chain
    to the final downstream consumer(s).  <code class="code">upstream_flushed</code> follows the chain to the
    initial upstream pipe(s), and then calls <code class="code">downstream_flushed</code>.<br/>    For a pipe in isolation, &quot;consumed&quot; means &quot;read from the pipe&quot;.  However, for pipes
    linked together with <code class="code">transfer</code> or any function built from <code class="code">transfer</code>, &quot;consumed&quot;
    means &quot;propagated all the way downstream through the chain and read from the final
    pipe in the chain&quot;.  Furthermore, for a pipe ultimately connected to an
    <code class="code">Async.Writer</code>, &quot;consumed&quot; means the OS write() system call has completed on the bytes
    read from the final pipe in the chain.<br/>    The following <code class="code">Pipe</code> functions automatically link their input and output pipes
    together so that <code class="code">*_flushed</code> on upstream pipes will propagate to downstream pipes:
    <code class="code">transfer*</code>, <code class="code">map*</code>, <code class="code">filter_map*</code>, <code class="code">filter</code>, <code class="code">interleave</code>, <code class="code">concat</code>.  There is *not*
    automatic linking with <code class="code">iter*</code>; however, user code can customize the behavior of
    flush functions using <code class="code">Consumer</code>, see below.</div></div>
<div class="info"><div class="info">A <code class="code">Consumer</code> is used to augment our notion of flushing (<code class="code">Pipe.upstream_flushed</code> and
      <code class="code">Pipe.downstream_flushed</code>) to include the time spent processing an element once it
      has been removed from the pipe.  It can be thought of as sitting at the end of a
      pipe, or between two pipes, and it provides more detailed feedback on the time an
      element spends outside of the pipe proper.  So we have the following two cases:<br/>      <span class="verbatim">        Pipe --&gt; Consumer
        Pipe --&gt; Consumer --&gt; Pipe --&gt; ...
      </span><br/>      The time outside of the pipe can be broken down into two parts: a part (probably
      short lived) during which the consumer processes the elements in some way, and a
      downstream portion where the consumer acts as a sentinel to report when the element
      has been fully processed.<br/>      For instance, consider the simple case of a pipe attached to an <code class="code">Async.Std.Writer</code>
      that is writing elements to disk.  Part one would be whatever transform the consumer
      applies to the elements in the pipe before it hands them off to the writer, and part
      two would be waiting for the writer to finish writing the transformed element to
      disk.  A more complex case is chaining two pipes together (maybe with a transform
      like <code class="code">map</code>).  Part one in this case is the transform and the write to the downstream
      pipe, and part two is waiting for that pipe (and any further pipes in the chain) to
      flush.<br/>      In each case the consumer is responsible for indicating when:<br/>      - it has finished any local work (by attaching itself to elements via the ~consumer
      argument to <code class="code">read</code> and <code class="code">read'</code>) and calling <code class="code">values_sent_downstream</code> when it has
      sent the values downstream.<br/>      - when any further processing has been completed (by providing an appropriate
      function to <code class="code">~downstream_flushed</code> when <code class="code">add_consumer</code> is called).<br/>      If a reader does not use a consumer to do the reading then an element is considered
      flushed the moment it leaves the pipe.  This may lead to odd results as entire
      queues of elements are removed by a call to <code class="code">read'</code> but are processed over a long
      period.</div></div>
<div class="info"><div class="info"><code class="code">add_consumer reader ~downstream_flushed</code> creates a new consumer of <code class="code">reader</code>, and
    causes future calls to <code class="code">flushed_downstream reader</code> to take this consumer into account.
    Thereafter, <code class="code">Pipe.flushed_downstream reader</code> will first ensure that values previously
    written to <code class="code">reader</code> have been read, then that they have been sent downstream by the
    consumer that read them, and finally that they have been flushed downstream.<br/>    One should only supply the resulting consumer to read operations on <code class="code">reader</code>.  Using
    a consumer created from one reader with another reader will raise an exception.</div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Generic pipe operations</h1></div></div>
<div class="info"><div class="info">These operations apply to all values of type <code class="code">(_, _) t</code>, that is, both readers and
    writers.</div></div>
<div class="info"><div class="info"><code class="code">length t</code> returns the number of elements currently queued in <code class="code">t</code></div></div>
<div class="info"><div class="info"><code class="code">is_empty t</code> is true iff there are no values in the pipe.</div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Writing</h1></div></div>
<div class="info"><div class="info">The write operations return a deferred value that is determined when either (1) it is
    OK to write again to the pipe or (2) the pipe has been closed.  This deferred is the
    data-producer's interface to the pipe pushback mechanism: it tells the producer when
    it should proceed after doing a write -- either to produce and write more data to the
    pipe, or to abandon production entirely.  The pushback mechansim is just advisory: a
    producer task can, but typically should not, dump arbitrary amounts of data into a
    pipe even if there is no consumer draining the pipe.<br/>    Producers that write a sequence of values to a pipe should be aware that the consumers
    who read from the pipe can close the pipe early -- that is, before the producer has
    finished doing all of its writes.  If this happens, further writes will raise an
    exception.  To avoid these errors, all writes must be atomically guarded by
    <code class="code">is_closed</code> tests.  Thus, a typical writer loop should look like this:<br/>    <pre class="codepre"><code class="code">
    fun countup hi w = (* Send the ints in range [0,hi) to writer W. *)
      let rec loop i =
        if i &lt; hi and not (is_closed w) then (* Guard write w/closed test. *)
          write i w &gt;&gt;&gt;            (* Do the write then block until datum     *)
          fun () -&gt; loop (i+1)     (*   fits or the pipe is closed.           *)
        else close w (* No harm done if reader has already closed the pipe.*)
      in
      loop 0
    </code></pre><br/>    If the pipe's consumer stops reading early and closes the pipe, <code class="code">countup</code> won't error
    out trying to write further values down the pipe: it will immediately wake up and
    exit.</div></div>
<div class="info"><div class="info"><code class="code">pushback writer</code> becomes determined when either <code class="code">writer</code> has been closed or
    the pipe is empty.</div></div>
<div class="info"><div class="info"><code class="code">write' writer q</code> transfers the elements from <code class="code">q</code> into the pipe, leaving <code class="code">q</code> empty.
    <code class="code">write'</code> returns a pushback deferred, as described above.  Writing to a closed pipe
    raises.<br/>    <code class="code">write writer v</code> is equivalent to <code class="code">write' writer (Queue.singleton v)</code>.</div></div>
<div class="info"><div class="info"><code class="code">write_without_pushback'</code> and <code class="code">write_without_pushback</code> are alternatives to <code class="code">write'</code>
    and <code class="code">write</code> that can be used when you don't care about the resultant deferred. The
    data is added to the pipe and then we return immediately.<br/>    <code class="code">write' t values</code> is equivalent to <code class="code">write_without_pushback' t values; pushback t</code> (and
    similarly for <code class="code">write</code>).</div></div>
<div class="info"><div class="info"><code class="code">write_when_ready writer ~f</code> waits until there is space available in the pipe, and
    then calls <code class="code">f write</code>, where <code class="code">write</code> can be used by <code class="code">f</code> to write a single value into
    the pipe at a time.  <code class="code">write_when_ready</code> guarantees that the pipe is open when it calls
    <code class="code">f</code>, and hence that the writes will succeed, unless <code class="code">f</code> itself closes the pipe.</div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Reading</h1></div></div>
<div class="info"><div class="info">With two special exceptions, all read procedures have a best-effort/forward-progress
    semantics:<br/>    - Best effort: When you do a read, you get what's available <em>right now</em>, which might
    be less than you requested.<br/>    - Forward progress: However, if <em>nothing is available</em>, you block until some data
    comes in (unless you're at EOF, in which case there's obviously no point in waiting).
    So the only time you ever get an empty, 0-item read is when you're at EOF.<br/>    The best-effort semantics allows you to program in a style that processes data in big
    slabs, yet also moves data through your processing in as timely a way as possible.<br/>    The forward-progress semantics means that every call produces <em>some</em> data, so you
    can process an n-element input with at most n reads; you cannot burn an unbounded
    number of cycles &quot;spinning&quot; doing an unbounded number of empty-result &quot;polling&quot; calls
    (which, in a non-preemptive system like Async could lock up the process).<br/>    The two exceptions to best-effort/forward-progress semantics are <code class="code">read_now</code>, which
    polls for data, thus abandoning the forward-progress guarantee, and <code class="code">read_exactly</code>,
    which loops until it has read the entire amount requested (or encountered EOF), thus
    abandoning the best-effort guarantee of timeliness.</div></div>
<div class="info"><div class="info"><code class="code">read' pipe</code> reads all of the values available in the pipe, as soon as any value
    becomes available.  The resulting queue will satisfy <code class="code">Q.length q &gt; 0</code>.  The <code class="code">consumer</code>
    is used to extend the meaning of values being flushed (see the <code class="code">Consumer</code> module
    above).</div></div>
<div class="info"><div class="info"><code class="code">read pipe</code> reads a single value from the pipe.  The <code class="code">consumer</code> is used to extend the
    meaning of values being flushed (see the <code class="code">Consumer</code> module above).</div></div>
<div class="info"><div class="info"><code class="code">read_at_most r ~num_values</code> reads up to <code class="code">num_values</code> values from the pipe's currently
    available data, blocking if the pipe is empty.  The resulting queue will satisfy <code class="code">0 &lt;
    Queue.length q &lt;= num_values</code>.  <code class="code">read_at_most</code> raises if <code class="code">num_values &lt;= 0</code>.  The
    <code class="code">consumer</code> is used to extend the meaning of values being flushed (see the <code class="code">Consumer</code>
    module above).</div></div>
<div class="info"><div class="info"><code class="code">read_exactly r ~num_values</code> reads exactly <code class="code">num_values</code> items, unless EOF is
    encountered.  <code class="code">read_exactly</code> performs a sequence of <code class="code">read_at_most</code> operations, so
    there is no guarantee that the queue of values it returns comprise a contiguous
    segment of the written stream of values -- other readers might pick off elements
    in-between <code class="code">read_exactly</code>'s atomic reads.  <code class="code">read_exactly</code> raises if <code class="code">num_values &lt;= 0</code>.
    The <code class="code">consumer</code> is used to extend the meaning of values being flushed (see the
    <code class="code">Consumer</code> module above).</div></div>
<div class="info"><div class="info"><code class="code">read_now' reader</code> reads all of the values from <code class="code">reader</code> that are immediately
    available.  The resulting queue will satisfy <code class="code">Q.length q &gt; 0</code>.  If <code class="code">reader</code> is closed,
    <code class="code">read_now'</code> returns <code class="code">`Eof</code>.  If <code class="code">reader</code> is empty, <code class="code">read_now'</code> returns
    <code class="code">`Nothing_available</code>.  <code class="code">read_now'</code> has the danger of permitting the computation to
    &quot;spin&quot; doing empty reads; it is only useful in exotic circumstances.  The <code class="code">consumer</code>
    is used to extend the meaning of values being flushed (see the <code class="code">Consumer</code> module
    above).<br/>    <code class="code">read_now</code> is like <code class="code">read_now'</code>, except that it reads a single value rather than
    everything that is available.</div></div>
<div class="info"><div class="info"><code class="code">clear reader</code> consumes all of the values currently in <code class="code">reader</code>, and all blocked
    flushes become determined with <code class="code">`Ok</code>.</div></div>
<div class="info"><div class="info"><code class="code">read_all reader</code> reads all the values from the pipe until it is closed.  An
    alternative name might be <code class="code">Reader.to_queue</code>.</div></div>
<div class="info"><div class="info"><code class="code">values_available reader</code> returns a deferred that becomes determined when there are
    values in the pipe.  If there are multiple readers (a rare situation), there is no
    guarantee that some other reader hasn't become active because of ordinary async
    scheduling and removed some or all of the values between the time the result of
    <code class="code">values_available</code> becomes determined and the time something waiting <code class="code">upon</code> that
    result runs.<br/>    <code class="code">values_available</code> is useful when one wants to <code class="code">choose</code> on values being available in a
    pipe, so that one can be sure and not remove values and drop them on the floor.<br/>    <code class="code">values_available</code> is roughly equivalent to <code class="code">read_at_most ~num_values:0</code>.</div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Sequence functions</h1></div></div>
<div class="info"><div class="info">Issues: <ul><li>Early-close and functions that copy between pipes<br/>    Some functions (<code class="code">transfer</code>, <code class="code">map</code>, <code class="code">filter_map</code>, <code class="code">filter</code>, <code class="code">interleave</code>, <code class="code">concat</code>, and
    their primed, batch-processing variants) spawn a background task that copies data from
    some upstream pipe to some downstream pipe, perhaps with some processing inserted
    in-between.  These copying tasks finish under two circumstances.  The standard,
    &quot;normal&quot; case is when the copying task gets EOF from the upstream pipe -- there is no
    more data to copy.  In this case, the copying task closes the downstream pipe and
    exits.<br/>    Somewhat less common is when the downstream consumer decides to stop reading early,
    while the upstream producer is still sending data to the copy task.  (E.g., perhaps
    the consumer was searching its incoming stream for some value, and it found that
    value, so there's no need to search further.)  In this case, the consumer closes its
    pipe to indicate it's done reading values.  When the copy task discovers that its
    downstream pipe is closed, it propagates the close to the upstream producer by closing
    its pipe and stops processing. </li><li>Scalar &amp; batch sequence processing<br/>    Each of the sequence functions (fold, iter, transfer, map) comes in two versions:
    &quot;scalar&quot; and &quot;batch&quot; processing.  The scalar version has the ordinary type for <code class="code">f</code>,
    which handles an element at a time in a non-deferred way.  In the batch version, <code class="code">f</code>
    deals with a queue of elements from the pipe at a time, and can block, which will
    cause pushback on writers due to elements not being consumed. </li></ul></div></div>
<div class="info"><div class="info"><code class="code">fold' reader ~init ~f</code> reads a batch of elements from <code class="code">reader</code>, supplies them to <code class="code">f</code>,
    waits for <code class="code">f</code> to finish, and then repeats.  <code class="code">fold'</code> finishes when the call to <code class="code">f</code> on
    the final batch of elements from <code class="code">reader</code> finishes.<br/>    <code class="code">fold reader ~init ~f</code> folds over the elements of <code class="code">reader</code>, consuming them as they
    come in.  <code class="code">fold</code> finishes when the final call to <code class="code">f</code> returns.<br/>    The <code class="code">consumer</code> is used to extend the meaning of values being flushed (see the
    <code class="code">Consumer</code> module above).</div></div>
<div class="info"><div class="info"><code class="code">iter' reader ~f</code> repeatedly applies <code class="code">f</code> to batches of elements of <code class="code">reader</code>, waiting
    for each call to <code class="code">f</code> to finish before continuing.  The deferred returned by <code class="code">iter'</code>
    becomes determined when the call to <code class="code">f</code> on the final batch of elements finishes.<br/>    <code class="code">iter</code> is a specialization of <code class="code">iter'</code> that applies the supplied <code class="code">f</code> to each element in
    the batch, waiting for one call to <code class="code">f</code> to finish before making the next call to <code class="code">f</code>.<br/>    <code class="code">iter_without_pushback</code> is a specialized version that applies <code class="code">f</code> to each element
    that arrives on the pipe, without giving <code class="code">f</code> a chance to pushback on the iteration
    continuing.<br/>    Supplying <code class="code">~continue_on_error:true</code> causes the iteration to continue even if <code class="code">f</code>
    raises.<br/>    The <code class="code">consumer</code> is used to extend the meaning of values being flushed (see the
    <code class="code">Consumer</code> module above).</div></div>
<div class="info"><div class="info">default is <code class="code">false</code></div></div>
<div class="info"><div class="info"><code class="code">transfer' input output ~f ?stop</code> repeatedly reads a batch of elements from <code class="code">input</code>,
    applies <code class="code">f</code> to the batch, writes the result as a batch to <code class="code">output</code>, and then waits on
    <code class="code">pushback</code> in <code class="code">output</code> before continuing.  <code class="code">transfer'</code> finishes if <code class="code">input</code> is closed,
    or <code class="code">output</code> is closed, or <code class="code">stop</code> is determined.  If <code class="code">output</code> is closed, then
    <code class="code">transfer'</code> closes <code class="code">input</code>.<br/>    <code class="code">transfer</code> is a specialization of <code class="code">transfer'</code> that uses <code class="code">Queue.map ~f</code>.<br/>    <code class="code">transfer_id</code> is a specialization of <code class="code">transfer'</code> wifh <code class="code">f = Fn.id</code>.</div></div>
<div class="info"><div class="info"><code class="code">map' input ~f</code> returns a reader, <code class="code">output</code>, and repeatedly applies <code class="code">f</code> to batches of
    elements from <code class="code">input</code>, with the results appearing in <code class="code">output</code>.  If values are not
    being consumed from <code class="code">output</code>, <code class="code">map'</code> will pushback and stop consuming values from
    <code class="code">input</code>.<br/>    If <code class="code">output</code> is closed, then <code class="code">map'</code> will close <code class="code">input</code>.<br/>    <code class="code">map</code> is a specialization of <code class="code">map'</code> that uses <code class="code">Queue.map ~f</code>.</div></div>
<div class="info"><div class="info"><code class="code">filter_map' input ~f</code> returns a reader, <code class="code">output</code>, and repeatedly applies <code class="code">f</code> to
    elements from <code class="code">input</code>, with the results that aren't <code class="code">None</code> appearing in <code class="code">output</code>.  If
    values are not being consumed from <code class="code">output</code>, <code class="code">filter_map'</code> will pushback and stop
    consuming values from <code class="code">input</code>.<br/>    If <code class="code">output</code> is closed, then <code class="code">filter_map'</code> will close <code class="code">input</code>.<br/>    <code class="code">filter_map</code> is a specialized version of <code class="code">filter_map'</code>.</div></div>
<div class="info"><div class="info"><code class="code">filter input ~f</code> returns a reader, <code class="code">output</code>, and copies to <code class="code">output</code> each element from
    <code class="code">input</code> that satisfies the predicate <code class="code">f</code>.  If <code class="code">output</code> is closed, then <code class="code">filter</code> closes
    <code class="code">input</code>.</div></div>
<div class="info"><div class="info"><code class="code">interleave inputs</code> returns a reader <code class="code">output</code>, and, for each input, transfers batches
    of values from that input to <code class="code">output</code>, using <code class="code">transfer_id</code>.  Each input is transferred
    to <code class="code">output</code> independently.  So, batches of values from different inputs can be in
    flight to <code class="code">output</code> simultaneously, but at most one batch at a time from any particular
    input.  The operation is complete when either all the <code class="code">inputs</code> produce EOF, or when
    <code class="code">output</code> is closed by the downstream consumer (in which case <code class="code">interleave</code> closes all
    the <code class="code">inputs</code>).</div></div>
<div class="info"><div class="info"><code class="code">merge inputs ~cmp</code> returns a reader, <code class="code">output</code>, that merges all the inputs.  Assuming
    that for each input, values are sorted according to the comparison function <code class="code">cmp</code>,
    values for each input will be transfered to <code class="code">output</code> and the values returned by
    <code class="code">output</code> will be sorted according to <code class="code">cmp</code>.</div></div>
<div class="info"><div class="info"><code class="code">concat inputs</code> return a reader, <code class="code">output</code>, with the values from each pipe in <code class="code">inputs</code>
    in sequence.  <code class="code">concat</code> closes <code class="code">output</code> once it reaches EOF on the final input.
    If <code class="code">output</code> is closed, then <code class="code">concat</code> closes all its inputs.</div></div>
<div class="info"><div class="info"><code class="code">to_stream_deprecated reader</code> returns a stream that reads everything from the pipe.
    This function is deprecated because one should change the code that is consuming
    a stream to instead consume from a pipe reader.</div></div>
<div class="info"><div class="info"><code class="code">of_stream_deprecated reader</code> return a pipe that has one element for every element on
    the stream.  This function is deprecated because one should change the code that is
    producing a stream to instead produce a pipe reader.</div></div>
<div class="info"><div class="info"><code class="code">drain reader</code> repeatedly reads values from <code class="code">reader</code> and throws them away.<br/>    <code class="code">drain_and_count</code> is like <code class="code">drain</code>, except it also counts the number of values it
    has read.</div></div>
<div class="info"><div class="info"><code class="code">to_list input</code> reads everything from <code class="code">input</code>; on EOF, it produces the accumulated
    list of these values.</div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Miscellaneous</h1></div></div>
<div class="info"><div class="info"><code class="code">hash</code> a hash function suitable for pipes</div></div>
<div class="info"><div class="info"><code class="code">equal</code> on pipes is physical equality.</div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Size budget</h1></div></div>
<div class="info"><div class="info">Every pipe has a &quot;size budget&quot;, which governs the pushback that is used to discourage
    writers from enqueueing arbitrarily large amounts of data.  As long as the length of
    the pipe exceeds the size budget, writers will not be notified to do further writing.
    Whenver the length is less than or equal to the size budget, writers will be notified
    to continue.<br/>    Every pipe's initial size budget is zero.</div></div>
<div class="info"><div class="info"><code class="code">set_size_budget t i</code> changes the size budget of <code class="code">t</code> to <code class="code">i</code>.  Any nonnegative value is
    allowed.</div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Debugging</h1></div></div>
<div class="info"><div class="info"><code class="code">show_debug_messages</code>, if true will cause a message to be printed at the start of each
    operation, showing the pipe and other arguments.</div></div>
<div class="info"><div class="info"><code class="code">check_invariant</code>, if true, will cause pipes' invariants to be checked at the start of
    each operation.</div></div>
</div>