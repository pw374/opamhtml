<div class="ocaml_toplevel_module"><div class="info">The Yojson library provides runtime functions for reading and writing JSON
   data from OCaml. It addresses a few shortcomings of its predecessor
   json-wheel and is about twice as fast (2.7x reading, 1.3x writing; results
   may vary).
   The design goals of Yojson are the following:<ul><li>Reducing inter-package dependencies by the use of polymorphic
   variants for the JSON tree type.</li><li>Allowing type-aware serializers/deserializers 
   to read and write directly without going through a generic JSON tree,
   for efficiency purposes.
   Readers and writers of all JSON syntaxic elements are provided
   but are undocumented and meant to be used by generated OCaml code.</li><li>Distinguishing between ints and floats.</li><li>Providing optional extensions of the JSON syntax.
   These extensions include comments, arbitrary strings,
   optional quotes around field names, tuples and variants.</li></ul><div class="authors"><b>Author(s): </b><span class="author">Martin Jambon</span></div><div class="see"><b>See also</b> <ul>  <li> <a href="http://json.org">JSON specification</a></li></ul></div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Shared types and functions</h1></div></div>
<pre><span class="VALversion"><span class="keyword">val</span> version</span> : <code class="type">string</code></pre>
<pre><span class="EXCEPTIONJson_error"><span class="keyword">exception</span> Json_error</span> <span class="keyword">of</span> <code class="type">string</code></pre>
<pre><span class="VALjson_error"><span class="keyword">val</span> json_error</span> : <code class="type">string -&gt; 'a</code></pre>
<pre><code><span class="TYPElexer_state"><span class="keyword">type</span> lexer_state</span> = {</code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTlexer_state.buf">buf</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a></code>;</code></td><td class="typefieldcomment" align="left"><div class="info">Buffer used to accumulate substrings</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTlexer_state.lnum">lnum</span> : <code class="type">int</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">Current line number (counting from 1)</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTlexer_state.bol">bol</span> : <code class="type">int</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">Absolute position of the first character of the current line
        (counting from 0)</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTlexer_state.fname">fname</span> : <code class="type">string option</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">Name referencing the input file in error messages</div></td></tr><tr><td>}</td></tr></table>
<div class="ocaml_module sig" name="Lexer_state"><pre><span class="keyword">module</span> <a href="?package=yojson&amp;module=Yojson.Lexer_state">Lexer_state</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEt"><span class="keyword">type</span> t</span> = {<code class="type"><a href="?package=yojson&amp;module=Yojson&amp;type=lexer_state">lexer_state</a></code>}</pre><table class="typetable">
		    <tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTt.buf">buf</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a></code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTt.lnum">lnum</span> : <code class="type">int</code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTt.bol">bol</span> : <code class="type">int</code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTt.fname">fname</span> : <code class="type">string option</code>;</code></td></tr><tr><td>}</td></tr></table></div></div>
<pre><span class="VALinit_lexer"><span class="keyword">val</span> init_lexer</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?fname:string -&gt; ?lnum:int -&gt; unit -&gt; <a href="?package=yojson&amp;module=Yojson&amp;type=lexer_state">lexer_state</a></code></pre><div class="info"><div class="info">Create a fresh lexer_state record.</div></div>
<pre><span class="EXCEPTIONEnd_of_array"><span class="keyword">exception</span> End_of_array</span></pre>
<pre><span class="EXCEPTIONEnd_of_object"><span class="keyword">exception</span> End_of_object</span></pre>
<pre><span class="EXCEPTIONEnd_of_tuple"><span class="keyword">exception</span> End_of_tuple</span></pre>
<pre><span class="EXCEPTIONEnd_of_input"><span class="keyword">exception</span> End_of_input</span></pre>
<div class="info"><div class="info"><h1 id="1_TITLE">Basic JSON tree type</h1></div></div>
<div class="ocaml_module sig" name="Basic"><pre><span class="keyword">module</span> <a href="?package=yojson&amp;module=Yojson.Basic">Basic</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<div class="info"><div class="info">This module supports standard JSON nodes only, i.e. no special syntax
   for variants or tuples as supported by  <a href="#Yojson.Safe">Yojson.Safe</a>.
   Arbitrary integers are not supported as they must all fit within the
   standard OCaml int type (31 or 63 bits depending on the platform).<br/>   The main advantage of this module is its simplicity.</div></div>
<div class="info"><div class="info"><h3 id="3_TITLE">Type of the JSON tree</h3></div></div>
<pre><span class="TYPEjson"><span class="keyword">type</span> json</span> = <code class="type">[ `Assoc of (string * <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a>) list
| `Bool of bool
| `Float of float
| `Int of int
| `List of <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> list
| `Null
| `String of string ]</code></pre><div class="info"><div class="info">All possible cases defined in Yojson:<ul><li>`Null: JSON null</li><li>`Bool of bool: JSON boolean</li><li>`Int of int: JSON number without decimal point or exponent.</li><li>`Intlit of string: JSON number without decimal point or exponent,
	    preserved as a string.</li><li>`Float of float: JSON number, Infinity, -Infinity or NaN.</li><li>`Floatlit of string: JSON number, Infinity, -Infinity or NaN,
	    preserved as a string.</li><li>`String of string: JSON string. Bytes in the range 128-255 are preserved
	    as-is without encoding validation for both reading
	    and writing.</li><li>`Stringlit of string: JSON string literal including the double quotes.</li><li>`Assoc of (string * json) list: JSON object.</li><li>`List of json list: JSON array.</li><li>`Tuple of json list: Tuple (non-standard extension of JSON).
	    Syntax: <code class="code">(&quot;abc&quot;, 123)</code>.</li><li>`Variant of (string * json option): Variant (non-standard extension of JSON).
	    Syntax: <code class="code">&lt;&quot;Foo&quot;&gt;</code> or <code class="code">&lt;&quot;Bar&quot;:123&gt;</code>.
</li></ul></div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">JSON writers</h2></div></div>
<pre><span class="VALto_string"><span class="keyword">val</span> to_string</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?len:int -&gt; ?std:bool -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; string</code></pre><div class="info"><div class="info">Write a compact JSON value to a string.<div class="parameters"><div class="param_info"><code class="code">buf</code> : allows to reuse an existing buffer created with 
      <code class="code">Bi_outbuf.create</code>. The buffer is cleared of all contents
      before starting and right before returning.</div><div class="param_info"><code class="code">len</code> : initial length of the output buffer.</div><div class="param_info"><code class="code">std</code> : use only standard JSON syntax,
      i.e. convert tuples and variants into standard JSON (if applicable),
      refuse to print NaN and infinities,
      require the root node to be either an object or an array.
      Default is <code class="code">false</code>.</div></div></div></div>
<pre><span class="VALto_channel"><span class="keyword">val</span> to_channel</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?len:int -&gt; ?std:bool -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=out_channel">Pervasives.out_channel</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a compact JSON value to a channel.<div class="parameters"><div class="param_info"><code class="code">buf</code> : allows to reuse an existing buffer created with 
      <code class="code">Bi_outbuf.create_channel_writer</code> on the same channel.
      <code class="code">buf</code> is flushed right
      before <code class="code">to_channel</code> returns but the <code class="code">out_channel</code> is
      not flushed automatically.<br/>      See <code class="code">to_string</code> for the role of the other optional arguments.</div></div></div></div>
<pre><span class="VALto_output"><span class="keyword">val</span> to_output</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?len:int -&gt;
?std:bool -&gt; &lt; output : string -&gt; int -&gt; int -&gt; int; .. &gt; -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a compact JSON value to an OO channel.<div class="parameters"><div class="param_info"><code class="code">buf</code> : allows to reuse an existing buffer created with 
      <code class="code">Bi_outbuf.create_output_writer</code> on the same channel.
      <code class="code">buf</code> is flushed right
      before <code class="code">to_output</code> returns but the channel itself is
      not flushed automatically.<br/>      See <code class="code">to_string</code> for the role of the other optional arguments.</div></div></div></div>
<pre><span class="VALto_file"><span class="keyword">val</span> to_file</span> : <code class="type">?len:int -&gt; ?std:bool -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a compact JSON value to a file.
      See <code class="code">to_string</code> for the role of the optional arguments.</div></div>
<pre><span class="VALto_outbuf"><span class="keyword">val</span> to_outbuf</span> : <code class="type">?std:bool -&gt; <a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a compact JSON value to an existing buffer.
      See <code class="code">to_string</code> for the role of the optional argument.</div></div>
<pre><span class="VALstream_to_string"><span class="keyword">val</span> stream_to_string</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?len:int -&gt; ?std:bool -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a> -&gt; string</code></pre><div class="info"><div class="info">Write a newline-separated sequence of compact one-line JSON values to
      a string.
      See <code class="code">to_string</code> for the role of the optional arguments.</div></div>
<pre><span class="VALstream_to_channel"><span class="keyword">val</span> stream_to_channel</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?len:int -&gt; ?std:bool -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=out_channel">Pervasives.out_channel</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a newline-separated sequence of compact one-line JSON values to
      a channel.
      See <code class="code">to_channel</code> for the role of the optional arguments.</div></div>
<pre><span class="VALstream_to_file"><span class="keyword">val</span> stream_to_file</span> : <code class="type">?len:int -&gt; ?std:bool -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a newline-separated sequence of compact one-line JSON values to
      a file.
      See <code class="code">to_string</code> for the role of the optional arguments.</div></div>
<pre><span class="VALstream_to_outbuf"><span class="keyword">val</span> stream_to_outbuf</span> : <code class="type">?std:bool -&gt; <a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a newline-separated sequence of compact one-line JSON values to
      an existing buffer.
      See <code class="code">to_string</code> for the role of the optional arguments.</div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">Miscellaneous</h2></div></div>
<pre><span class="VALsort"><span class="keyword">val</span> sort</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a></code></pre><div class="info"><div class="info">Sort object fields (stable sort, comparing field names
      and treating them as byte sequences)</div></div>
<pre><span class="VALwrite_null"><span class="keyword">val</span> write_null</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; unit -&gt; unit</code></pre>
<pre><span class="VALwrite_bool"><span class="keyword">val</span> write_bool</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; bool -&gt; unit</code></pre>
<pre><span class="VALwrite_int"><span class="keyword">val</span> write_int</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; int -&gt; unit</code></pre>
<pre><span class="VALwrite_float"><span class="keyword">val</span> write_float</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; float -&gt; unit</code></pre>
<pre><span class="VALwrite_std_float"><span class="keyword">val</span> write_std_float</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; float -&gt; unit</code></pre>
<pre><span class="VALwrite_float_fast"><span class="keyword">val</span> write_float_fast</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; float -&gt; unit</code></pre>
<pre><span class="VALwrite_std_float_fast"><span class="keyword">val</span> write_std_float_fast</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; float -&gt; unit</code></pre>
<pre><span class="VALwrite_float_prec"><span class="keyword">val</span> write_float_prec</span> : <code class="type">int -&gt; <a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; float -&gt; unit</code></pre>
<pre><span class="VALwrite_std_float_prec"><span class="keyword">val</span> write_std_float_prec</span> : <code class="type">int -&gt; <a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; float -&gt; unit</code></pre>
<pre><span class="VALwrite_string"><span class="keyword">val</span> write_string</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; string -&gt; unit</code></pre>
<pre><span class="VALwrite_assoc"><span class="keyword">val</span> write_assoc</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; (string * <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a>) list -&gt; unit</code></pre>
<pre><span class="VALwrite_list"><span class="keyword">val</span> write_list</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> list -&gt; unit</code></pre>
<pre><span class="VALwrite_json"><span class="keyword">val</span> write_json</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; unit</code></pre>
<pre><span class="VALwrite_std_json"><span class="keyword">val</span> write_std_json</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; unit</code></pre>
<div class="info"><div class="info"><h2 id="2_TITLE">JSON pretty-printing</h2></div></div>
<pre><span class="VALpretty_format"><span class="keyword">val</span> pretty_format</span> : <code class="type">?std:bool -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; <a href="?package=easy-format&amp;module=Easy_format&amp;type=t">Easy_format.t</a></code></pre><div class="info"><div class="info">Convert into a pretty-printable tree.
      See <code class="code">to_string</code> for the role of the optional <code class="code">std</code> argument.<div class="see"><b>See also</b> <ul>  <li> <a href="http://martin.jambon.free.fr/easy-format.html">Easy-format</a></li></ul></div></div></div>
<pre><span class="VALpretty_to_string"><span class="keyword">val</span> pretty_to_string</span> : <code class="type">?std:bool -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; string</code></pre><div class="info"><div class="info">Pretty-print into a string.
      See <code class="code">to_string</code> for the role of the optional <code class="code">std</code> argument.</div></div>
<pre><span class="VALpretty_to_channel"><span class="keyword">val</span> pretty_to_channel</span> : <code class="type">?std:bool -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=out_channel">Pervasives.out_channel</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; unit</code></pre><div class="info"><div class="info">Pretty-print to a channel.
      See <code class="code">to_string</code> for the role of the optional <code class="code">std</code> argument.</div></div>
<pre><span class="VALprettify"><span class="keyword">val</span> prettify</span> : <code class="type">?std:bool -&gt; string -&gt; string</code></pre><div class="info"><div class="info">Combined parser and pretty-printer.
      See <code class="code">to_string</code> for the role of the optional <code class="code">std</code> argument.</div></div>
<pre><span class="VALcompact"><span class="keyword">val</span> compact</span> : <code class="type">?std:bool -&gt; string -&gt; string</code></pre><div class="info"><div class="info">Combined parser and printer.
      See <code class="code">to_string</code> for the role of the optional <code class="code">std</code> argument.</div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">JSON readers</h2></div></div>
<pre><span class="VALfrom_string"><span class="keyword">val</span> from_string</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?fname:string -&gt; ?lnum:int -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a></code></pre><div class="info"><div class="info">Read a JSON value from a string.<div class="parameters"><div class="param_info"><code class="code">buf</code> : use this buffer at will during parsing instead of creating
      a new one.</div><div class="param_info"><code class="code">fname</code> : data file name to be used in error messages. It does
      not have to be a real file.</div><div class="param_info"><code class="code">lnum</code> : number of the first line of input. Default is 1.</div></div></div></div>
<pre><span class="VALfrom_channel"><span class="keyword">val</span> from_channel</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?fname:string -&gt; ?lnum:int -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=in_channel">Pervasives.in_channel</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a></code></pre><div class="info"><div class="info">Read a JSON value from a channel.
      See <code class="code">from_string</code> for the meaning of the optional arguments.</div></div>
<pre><span class="VALfrom_file"><span class="keyword">val</span> from_file</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?fname:string -&gt; ?lnum:int -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a></code></pre><div class="info"><div class="info">Read a JSON value from a file.
      See <code class="code">from_string</code> for the meaning of the optional arguments.</div></div>
<pre><span class="TYPElexer_state"><span class="keyword">type</span> lexer_state</span> = {<code class="type"><a href="?package=yojson&amp;module=Yojson.Lexer_state&amp;type=t">Lexer_state.t</a></code>}</pre><table class="typetable">
		    <tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTlexer_state.buf">buf</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a></code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTlexer_state.lnum">lnum</span> : <code class="type">int</code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTlexer_state.bol">bol</span> : <code class="type">int</code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTlexer_state.fname">fname</span> : <code class="type">string option</code>;</code></td></tr><tr><td>}</td></tr></table><div class="info"><div class="info">This alias is provided for backward compatibility.
        New code should refer to  <a href="#Yojson.lexer_state">Yojson.lexer_state</a> directly.</div></div>
<pre><span class="VALinit_lexer"><span class="keyword">val</span> init_lexer</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?fname:string -&gt; ?lnum:int -&gt; unit -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a></code></pre><div class="info"><div class="info">This alias is provided for backward compatibility.
      New code should use  <a href="#Yojson.init_lexer">Yojson.init_lexer</a> directly.</div></div>
<pre><span class="VALfrom_lexbuf"><span class="keyword">val</span> from_lexbuf</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; ?stream:bool -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a></code></pre><div class="info"><div class="info">Read a JSON value from a lexbuf.
      A valid initial <code class="code">lexer_state</code> can be created with <code class="code">init_lexer</code>.
      See <code class="code">from_string</code> for the meaning of the optional arguments.<div class="parameters"><div class="param_info"><code class="code">stream</code> : indicates whether more data may follow. The default value
      is false and indicates that only JSON whitespace can be found between
      the end of the JSON value and the end of the input.</div></div></div></div>
<pre><span class="VALstream_from_string"><span class="keyword">val</span> stream_from_string</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?fname:string -&gt; ?lnum:int -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a></code></pre><div class="info"><div class="info">Input a sequence of JSON values from a string.
      Whitespace between JSON values is fine but not required.
      See <code class="code">from_string</code> for the meaning of the optional arguments.</div></div>
<pre><span class="VALstream_from_channel"><span class="keyword">val</span> stream_from_channel</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?fin:(unit -&gt; unit) -&gt;
?fname:string -&gt; ?lnum:int -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=in_channel">Pervasives.in_channel</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a></code></pre><div class="info"><div class="info">Input a sequence of JSON values from a channel.
      Whitespace between JSON values is fine but not required.<div class="parameters"><div class="param_info"><code class="code">fin</code> : finalization function executed once when the end of the
      stream is reached either because there is no more input or because
      the input could not be parsed, raising an exception.<br/>      See <code class="code">from_string</code> for the meaning of the other optional arguments.</div></div></div></div>
<pre><span class="VALstream_from_file"><span class="keyword">val</span> stream_from_file</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?fname:string -&gt; ?lnum:int -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a></code></pre><div class="info"><div class="info">Input a sequence of JSON values from a file.
      Whitespace between JSON values is fine but not required.<br/>      See <code class="code">from_string</code> for the meaning of the optional arguments.</div></div>
<pre><span class="VALstream_from_lexbuf"><span class="keyword">val</span> stream_from_lexbuf</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; ?fin:(unit -&gt; unit) -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a></code></pre><div class="info"><div class="info">Input a sequence of JSON values from a lexbuf.
      A valid initial <code class="code">lexer_state</code> can be created with <code class="code">init_lexer</code>.
      Whitespace between JSON values is fine but not required.<br/>      See <code class="code">stream_from_channel</code> for the meaning of the optional <code class="code">fin</code>
      argument.</div></div>
<pre><span class="TYPEjson_line"><span class="keyword">type</span> json_line</span> = <code class="type">[ `Exn of exn | `Json of <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> ]</code></pre><div class="info"><div class="info">The type of values resulting from a parsing attempt of a JSON value.</div></div>
<pre><span class="VALlinestream_from_channel"><span class="keyword">val</span> linestream_from_channel</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?fin:(unit -&gt; unit) -&gt;
?fname:string -&gt; ?lnum:int -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=in_channel">Pervasives.in_channel</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json_line">json_line</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a></code></pre><div class="info"><div class="info">Input a sequence of JSON values, one per line, from a channel.
      Exceptions raised when reading malformed lines are caught
      and represented using <code class="code">`Exn</code>.<br/>      See <code class="code">stream_from_channel</code> for the meaning of the optional <code class="code">fin</code>
      argument.
      See <code class="code">from_string</code> for the meaning of the other optional arguments.</div></div>
<pre><span class="VALlinestream_from_file"><span class="keyword">val</span> linestream_from_file</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?fname:string -&gt; ?lnum:int -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json_line">json_line</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a></code></pre><div class="info"><div class="info">Input a sequence of JSON values, one per line, from a file.
      Exceptions raised when reading malformed lines are caught
      and represented using <code class="code">`Exn</code>.<br/>      See <code class="code">stream_from_channel</code> for the meaning of the optional <code class="code">fin</code>
      argument.
      See <code class="code">from_string</code> for the meaning of the other optional arguments.</div></div>
<pre><span class="VALfinish_string"><span class="keyword">val</span> finish_string</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; string</code></pre>
<pre><span class="VALread_string"><span class="keyword">val</span> read_string</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; string</code></pre>
<pre><span class="VALread_ident"><span class="keyword">val</span> read_ident</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; string</code></pre>
<pre><span class="VALmap_string"><span class="keyword">val</span> map_string</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; (string -&gt; int -&gt; int -&gt; 'a) -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a</code></pre>
<pre><span class="VALmap_ident"><span class="keyword">val</span> map_ident</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; (string -&gt; int -&gt; int -&gt; 'a) -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a</code></pre>
<pre><span class="TYPEvariant_kind"><span class="keyword">type</span> variant_kind</span> = <code class="type">[ `Double_quote | `Edgy_bracket | `Square_bracket ]</code></pre>
<pre><span class="VALstart_any_variant"><span class="keyword">val</span> start_any_variant</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=variant_kind">variant_kind</a></code></pre>
<pre><span class="VALfinish_variant"><span class="keyword">val</span> finish_variant</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> option</code></pre>
<pre><span class="VALfinish_skip_variant"><span class="keyword">val</span> finish_skip_variant</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_lt"><span class="keyword">val</span> read_lt</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_gt"><span class="keyword">val</span> read_gt</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_comma"><span class="keyword">val</span> read_comma</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALfinish_stringlit"><span class="keyword">val</span> finish_stringlit</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; string</code></pre>
<pre><span class="VALfinish_skip_stringlit"><span class="keyword">val</span> finish_skip_stringlit</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALfinish_escaped_char"><span class="keyword">val</span> finish_escaped_char</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALfinish_comment"><span class="keyword">val</span> finish_comment</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_space"><span class="keyword">val</span> read_space</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_eof"><span class="keyword">val</span> read_eof</span> : <code class="type"><a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; bool</code></pre>
<pre><span class="VALread_null"><span class="keyword">val</span> read_null</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_null_if_possible"><span class="keyword">val</span> read_null_if_possible</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; bool</code></pre>
<pre><span class="VALread_bool"><span class="keyword">val</span> read_bool</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; bool</code></pre>
<pre><span class="VALread_int"><span class="keyword">val</span> read_int</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; int</code></pre>
<pre><span class="VALread_int8"><span class="keyword">val</span> read_int8</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; char</code></pre>
<pre><span class="VALread_int32"><span class="keyword">val</span> read_int32</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; int32</code></pre>
<pre><span class="VALread_int64"><span class="keyword">val</span> read_int64</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; int64</code></pre>
<pre><span class="VALread_number"><span class="keyword">val</span> read_number</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; float</code></pre>
<pre><span class="VALskip_ident"><span class="keyword">val</span> skip_ident</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_sequence"><span class="keyword">val</span> read_sequence</span> : <code class="type">('a -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a) -&gt;
'a -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a</code></pre>
<pre><span class="VALread_list"><span class="keyword">val</span> read_list</span> : <code class="type">(<a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a) -&gt;
<a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a list</code></pre>
<pre><span class="VALread_list_rev"><span class="keyword">val</span> read_list_rev</span> : <code class="type">(<a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a) -&gt;
<a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a list</code></pre>
<pre><span class="VALread_array_end"><span class="keyword">val</span> read_array_end</span> : <code class="type"><a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_array_sep"><span class="keyword">val</span> read_array_sep</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_array"><span class="keyword">val</span> read_array</span> : <code class="type">(<a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a) -&gt;
<a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a array</code></pre>
<pre><span class="VALread_tuple"><span class="keyword">val</span> read_tuple</span> : <code class="type">(int -&gt; 'a -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a) -&gt;
'a -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a</code></pre>
<pre><span class="VALstart_any_tuple"><span class="keyword">val</span> start_any_tuple</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; bool</code></pre>
<pre><span class="VALread_lpar"><span class="keyword">val</span> read_lpar</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_rpar"><span class="keyword">val</span> read_rpar</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_tuple_end"><span class="keyword">val</span> read_tuple_end</span> : <code class="type"><a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_tuple_end2"><span class="keyword">val</span> read_tuple_end2</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; bool -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_tuple_sep"><span class="keyword">val</span> read_tuple_sep</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_tuple_sep2"><span class="keyword">val</span> read_tuple_sep2</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; bool -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_lbr"><span class="keyword">val</span> read_lbr</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_rbr"><span class="keyword">val</span> read_rbr</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_fields"><span class="keyword">val</span> read_fields</span> : <code class="type">('a -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a) -&gt;
'a -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a</code></pre>
<pre><span class="VALread_lcurl"><span class="keyword">val</span> read_lcurl</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_object_end"><span class="keyword">val</span> read_object_end</span> : <code class="type"><a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_object_sep"><span class="keyword">val</span> read_object_sep</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_colon"><span class="keyword">val</span> read_colon</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_json"><span class="keyword">val</span> read_json</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a></code></pre>
<pre><span class="VALskip_json"><span class="keyword">val</span> skip_json</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<div class="ocaml_module sig" name="Util"><pre><span class="keyword">module</span> <a href="?package=yojson&amp;module=Yojson.Basic.Util">Util</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<div class="info"><div class="info">This module provides combinators for extracting fields from JSON
   values. This approach is recommended for reading a few fields
   from data returned by public APIs. However for more complex applications 
   we recommend  <a href="https://github.com/MyLifeLabs/atdgen">Atdgen</a>.<br/>   Here is some sample JSON data:
<span class="verbatim">{
  &quot;id&quot;: &quot;398eb027&quot;,
  &quot;name&quot;: &quot;John Doe&quot;,
  &quot;pages&quot;: [
    {
      &quot;id&quot;: 1,
      &quot;title&quot;: &quot;The Art of Flipping Coins&quot;,
      &quot;url&quot;: &quot;http://example.com/398eb027/1&quot;
    },
    {
      &quot;id&quot;: 2,
      &quot;deleted&quot;: true
    },
    {
      &quot;id&quot;: 3,
      &quot;title&quot;: &quot;Artichoke Salad&quot;,
      &quot;url&quot;: &quot;http://example.com/398eb027/3&quot;
    },
    {
      &quot;id&quot;: 4,
      &quot;title&quot;: &quot;Flying Bananas&quot;,
      &quot;url&quot;: &quot;http://example.com/398eb027/4&quot;
    }
  ]
}</span><br/>   In order to extract the &quot;id&quot; field, assuming it is mandatory,
   we would use the following OCaml code that operates on single JSON
   nodes:
<span class="verbatim">open Yojson.Basic.Util
...
  let id = json |&gt; member &quot;id&quot; |&gt; to_string in
  ...</span><br/>   In order to extract all the &quot;title&quot; fields, we would write the following
   OCaml code that operates on lists of JSON nodes, skipping
   undefined nodes and nodes of unexpected type:
<span class="verbatim">open Yojson.Basic.Util

let extract_titles (json : Yojson.Basic.json) : string list =
  [json]
    |&gt; filter_member &quot;pages&quot;
    |&gt; flatten
    |&gt; filter_member &quot;title&quot;
    |&gt; filter_string</span></div></div>
<pre><span class="EXCEPTIONType_error"><span class="keyword">exception</span> Type_error</span> <span class="keyword">of</span> <code class="type">string * <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a></code></pre><div class="info"><div class="info">Raised when the JSON value is not of the correct type to support an
      operation, e.g. <code class="code">member</code> on an <code class="code">`Int</code>. The string message explains the
      mismatch.</div></div>
<pre><span class="EXCEPTIONUndefined"><span class="keyword">exception</span> Undefined</span> <span class="keyword">of</span> <code class="type">string * <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a></code></pre><div class="info"><div class="info">Raised when the equivalent JavaScript operation on the JSON value would
      return undefined. Currently this only happens when an array index is out
      of bounds.</div></div>
<pre><span class="VAL(|&gt;)"><span class="keyword">val</span> (|&gt;)</span> : <code class="type">'a -&gt; ('a -&gt; 'b) -&gt; 'b</code></pre><div class="info"><div class="info">Forward pipe operator; useful for composing JSON access functions
      without too many parentheses</div></div>
<pre><span class="VALmember"><span class="keyword">val</span> member</span> : <code class="type">string -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a></code></pre><div class="info"><div class="info"><code class="code">member k obj</code> returns the value associated with the key <code class="code">k</code> in the JSON
      object <code class="code">obj</code>, or <code class="code">`Null</code> if <code class="code">k</code> is not present in <code class="code">obj</code>.</div></div>
<pre><span class="VALindex"><span class="keyword">val</span> index</span> : <code class="type">int -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a></code></pre><div class="info"><div class="info"><code class="code">index i arr</code> returns the value at index <code class="code">i</code> in the JSON array <code class="code">arr</code>.
      Negative indices count from the end of the list (so -1 is the last
      element).</div></div>
<pre><span class="VALmap"><span class="keyword">val</span> map</span> : <code class="type">(<a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a>) -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a></code></pre><div class="info"><div class="info"><code class="code">map f arr</code> calls the function <code class="code">f</code> on each element of the JSON array
      <code class="code">arr</code>, and returns a JSON array containing the results.</div></div>
<pre><span class="VALto_assoc"><span class="keyword">val</span> to_assoc</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; (string * <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a>) list</code></pre><div class="info"><div class="info">Extract the items of a JSON array or raise <code class="code">Type_error</code>.</div></div>
<pre><span class="VALto_option"><span class="keyword">val</span> to_option</span> : <code class="type">(<a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; 'a) -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; 'a option</code></pre><div class="info"><div class="info">Return <code class="code">None</code> if the JSON value is null or map the JSON value
      to <code class="code">Some</code> value using the provided function.</div></div>
<pre><span class="VALto_bool"><span class="keyword">val</span> to_bool</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; bool</code></pre><div class="info"><div class="info">Extract a boolean value or raise <code class="code">Type_error</code>.</div></div>
<pre><span class="VALto_bool_option"><span class="keyword">val</span> to_bool_option</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; bool option</code></pre><div class="info"><div class="info">Extract <code class="code">Some</code> boolean value, 
      return <code class="code">None</code> if the value is null,
      or raise <code class="code">Type_error</code> otherwise.</div></div>
<pre><span class="VALto_number"><span class="keyword">val</span> to_number</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; float</code></pre><div class="info"><div class="info">Extract a number or raise <code class="code">Type_error</code>.</div></div>
<pre><span class="VALto_number_option"><span class="keyword">val</span> to_number_option</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; float option</code></pre><div class="info"><div class="info">Extract <code class="code">Some</code> number, 
      return <code class="code">None</code> if the value is null,
      or raise <code class="code">Type_error</code> otherwise.</div></div>
<pre><span class="VALto_float"><span class="keyword">val</span> to_float</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; float</code></pre><div class="info"><div class="info">Extract a float value or raise <code class="code">Type_error</code>.
      <code class="code">to_number</code> is generally preferred as it also works with int literals.</div></div>
<pre><span class="VALto_float_option"><span class="keyword">val</span> to_float_option</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; float option</code></pre><div class="info"><div class="info">Extract <code class="code">Some</code> float value, 
      return <code class="code">None</code> if the value is null,
      or raise <code class="code">Type_error</code> otherwise.
      <code class="code">to_number_option</code> is generally preferred as it also works
      with int literals.</div></div>
<pre><span class="VALto_int"><span class="keyword">val</span> to_int</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; int</code></pre><div class="info"><div class="info">Extract an int from a JSON int or raise <code class="code">Type_error</code>.</div></div>
<pre><span class="VALto_int_option"><span class="keyword">val</span> to_int_option</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; int option</code></pre><div class="info"><div class="info">Extract <code class="code">Some</code> int from a JSON int, 
      return <code class="code">None</code> if the value is null,
      or raise <code class="code">Type_error</code> otherwise.</div></div>
<pre><span class="VALto_list"><span class="keyword">val</span> to_list</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> list</code></pre><div class="info"><div class="info">Extract a list from JSON array or raise <code class="code">Type_error</code>.</div></div>
<pre><span class="VALto_string"><span class="keyword">val</span> to_string</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; string</code></pre><div class="info"><div class="info">Extract a string from a JSON string or raise <code class="code">Type_error</code>.</div></div>
<pre><span class="VALto_string_option"><span class="keyword">val</span> to_string_option</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; string option</code></pre><div class="info"><div class="info">Extract <code class="code">Some</code> string from a JSON string, 
      return <code class="code">None</code> if the value is null,
      or raise <code class="code">Type_error</code> otherwise.</div></div>
<pre><span class="VALconvert_each"><span class="keyword">val</span> convert_each</span> : <code class="type">(<a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; 'a) -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> -&gt; 'a list</code></pre><div class="info"><div class="info">The conversion functions above cannot be used with <code class="code">map</code>, because they do
      not return JSON values. This convenience function <code class="code">convert_each to_f arr</code>
      is equivalent to <code class="code">List.map to_f (to_list arr)</code>.</div></div>
<div class="info"><div class="info"><h3 id="3_TITLE">Exception-free filters</h3></div></div>
<div class="info"><div class="info">The following functions operate on lists of JSON nodes.
   None of them raises an exception when a certain kind of node is expected
   but no node or the wrong kind of node is found.
   Instead of raising an exception, nodes that are not as expected
   are simply ignored.</div></div>
<pre><span class="VALfilter_map"><span class="keyword">val</span> filter_map</span> : <code class="type">('a -&gt; 'b option) -&gt; 'a list -&gt; 'b list</code></pre><div class="info"><div class="info"><code class="code">filter_map f l</code> maps each element of the list <code class="code">l</code> to an optional value
      using function <code class="code">f</code> and unwraps the resulting values.</div></div>
<pre><span class="VALflatten"><span class="keyword">val</span> flatten</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> list -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> list</code></pre><div class="info"><div class="info">Expects JSON arrays and returns all their elements as a single
      list. <code class="code">flatten l</code> is equivalent to <code class="code">List.flatten (filter_list l)</code>.</div></div>
<pre><span class="VALfilter_index"><span class="keyword">val</span> filter_index</span> : <code class="type">int -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> list -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> list</code></pre><div class="info"><div class="info">Expects JSON arrays and returns all their elements existing at the given
      position.</div></div>
<pre><span class="VALfilter_list"><span class="keyword">val</span> filter_list</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> list -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> list list</code></pre><div class="info"><div class="info">Expects JSON arrays and unwraps them.</div></div>
<pre><span class="VALfilter_member"><span class="keyword">val</span> filter_member</span> : <code class="type">string -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> list -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> list</code></pre><div class="info"><div class="info">Expects JSON objects and returns all the fields of the given name
      (at most one field per object).</div></div>
<pre><span class="VALfilter_assoc"><span class="keyword">val</span> filter_assoc</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> list -&gt; (string * <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a>) list list</code></pre><div class="info"><div class="info">Expects JSON objects and unwraps them.</div></div>
<pre><span class="VALfilter_bool"><span class="keyword">val</span> filter_bool</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> list -&gt; bool list</code></pre><div class="info"><div class="info">Expects JSON booleans and unwraps them.</div></div>
<pre><span class="VALfilter_int"><span class="keyword">val</span> filter_int</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> list -&gt; int list</code></pre><div class="info"><div class="info">Expects JSON integers (<code class="code">`Int</code> nodes) and unwraps them.</div></div>
<pre><span class="VALfilter_float"><span class="keyword">val</span> filter_float</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> list -&gt; float list</code></pre><div class="info"><div class="info">Expects JSON floats (<code class="code">`Float</code> nodes) and unwraps them.</div></div>
<pre><span class="VALfilter_number"><span class="keyword">val</span> filter_number</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> list -&gt; float list</code></pre><div class="info"><div class="info">Expects JSON numbers (<code class="code">`Int</code> or <code class="code">`Float</code>) and unwraps them.
      Ints are converted to floats.</div></div>
<pre><span class="VALfilter_string"><span class="keyword">val</span> filter_string</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">json</a> list -&gt; string list</code></pre><div class="info"><div class="info">Expects JSON strings and unwraps them.</div></div></div></div></div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Multipurpose JSON tree type</h1></div></div>
<div class="ocaml_module sig" name="Safe"><pre><span class="keyword">module</span> <a href="?package=yojson&amp;module=Yojson.Safe">Safe</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<div class="info"><div class="info">This module supports a specific syntax for variants and tuples
   in addition to the standard JSON nodes.
   Arbitrary integers are supported and represented as a decimal string 
   using <code class="code">`Intlit</code> when they cannot be represented using OCaml's int type.<br/>   This module is recommended for intensive use 
   or OCaml-friendly use of JSON.</div></div>
<div class="info"><div class="info"><h3 id="3_TITLE">Type of the JSON tree</h3></div></div>
<pre><span class="TYPEjson"><span class="keyword">type</span> json</span> = <code class="type">[ `Assoc of (string * <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a>) list
| `Bool of bool
| `Float of float
| `Int of int
| `Intlit of string
| `List of <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> list
| `Null
| `String of string
| `Tuple of <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> list
| `Variant of string * <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> option ]</code></pre><div class="info"><div class="info">All possible cases defined in Yojson:<ul><li>`Null: JSON null</li><li>`Bool of bool: JSON boolean</li><li>`Int of int: JSON number without decimal point or exponent.</li><li>`Intlit of string: JSON number without decimal point or exponent,
	    preserved as a string.</li><li>`Float of float: JSON number, Infinity, -Infinity or NaN.</li><li>`Floatlit of string: JSON number, Infinity, -Infinity or NaN,
	    preserved as a string.</li><li>`String of string: JSON string. Bytes in the range 128-255 are preserved
	    as-is without encoding validation for both reading
	    and writing.</li><li>`Stringlit of string: JSON string literal including the double quotes.</li><li>`Assoc of (string * json) list: JSON object.</li><li>`List of json list: JSON array.</li><li>`Tuple of json list: Tuple (non-standard extension of JSON).
	    Syntax: <code class="code">(&quot;abc&quot;, 123)</code>.</li><li>`Variant of (string * json option): Variant (non-standard extension of JSON).
	    Syntax: <code class="code">&lt;&quot;Foo&quot;&gt;</code> or <code class="code">&lt;&quot;Bar&quot;:123&gt;</code>.
</li></ul></div></div>
<pre><span class="VALto_basic"><span class="keyword">val</span> to_basic</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Basic&amp;type=json">Basic.json</a></code></pre><div class="info"><div class="info">Tuples are converted to JSON arrays,
     Variants are converted to JSON strings or arrays of a string (constructor)
     and a json value (argument).
     Long integers are converted to JSON strings.<br/>     Examples:
<span class="verbatim">`Tuple [ `Int 1; `Float 2.3 ]   -&gt;    `List [ `Int 1; `Float 2.3 ]
`Variant (&quot;A&quot;, None)            -&gt;    `String &quot;A&quot;
`Variant (&quot;B&quot;, Some x)          -&gt;    `List [ `String &quot;B&quot;, x ]
`Intlit &quot;12345678901234567890&quot;  -&gt;    `String &quot;12345678901234567890&quot;</span></div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">JSON writers</h2></div></div>
<pre><span class="VALto_string"><span class="keyword">val</span> to_string</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?len:int -&gt; ?std:bool -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> -&gt; string</code></pre><div class="info"><div class="info">Write a compact JSON value to a string.<div class="parameters"><div class="param_info"><code class="code">buf</code> : allows to reuse an existing buffer created with 
      <code class="code">Bi_outbuf.create</code>. The buffer is cleared of all contents
      before starting and right before returning.</div><div class="param_info"><code class="code">len</code> : initial length of the output buffer.</div><div class="param_info"><code class="code">std</code> : use only standard JSON syntax,
      i.e. convert tuples and variants into standard JSON (if applicable),
      refuse to print NaN and infinities,
      require the root node to be either an object or an array.
      Default is <code class="code">false</code>.</div></div></div></div>
<pre><span class="VALto_channel"><span class="keyword">val</span> to_channel</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?len:int -&gt; ?std:bool -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=out_channel">Pervasives.out_channel</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a compact JSON value to a channel.<div class="parameters"><div class="param_info"><code class="code">buf</code> : allows to reuse an existing buffer created with 
      <code class="code">Bi_outbuf.create_channel_writer</code> on the same channel.
      <code class="code">buf</code> is flushed right
      before <code class="code">to_channel</code> returns but the <code class="code">out_channel</code> is
      not flushed automatically.<br/>      See <code class="code">to_string</code> for the role of the other optional arguments.</div></div></div></div>
<pre><span class="VALto_output"><span class="keyword">val</span> to_output</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?len:int -&gt;
?std:bool -&gt; &lt; output : string -&gt; int -&gt; int -&gt; int; .. &gt; -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a compact JSON value to an OO channel.<div class="parameters"><div class="param_info"><code class="code">buf</code> : allows to reuse an existing buffer created with 
      <code class="code">Bi_outbuf.create_output_writer</code> on the same channel.
      <code class="code">buf</code> is flushed right
      before <code class="code">to_output</code> returns but the channel itself is
      not flushed automatically.<br/>      See <code class="code">to_string</code> for the role of the other optional arguments.</div></div></div></div>
<pre><span class="VALto_file"><span class="keyword">val</span> to_file</span> : <code class="type">?len:int -&gt; ?std:bool -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a compact JSON value to a file.
      See <code class="code">to_string</code> for the role of the optional arguments.</div></div>
<pre><span class="VALto_outbuf"><span class="keyword">val</span> to_outbuf</span> : <code class="type">?std:bool -&gt; <a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a compact JSON value to an existing buffer.
      See <code class="code">to_string</code> for the role of the optional argument.</div></div>
<pre><span class="VALstream_to_string"><span class="keyword">val</span> stream_to_string</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?len:int -&gt; ?std:bool -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a> -&gt; string</code></pre><div class="info"><div class="info">Write a newline-separated sequence of compact one-line JSON values to
      a string.
      See <code class="code">to_string</code> for the role of the optional arguments.</div></div>
<pre><span class="VALstream_to_channel"><span class="keyword">val</span> stream_to_channel</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?len:int -&gt; ?std:bool -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=out_channel">Pervasives.out_channel</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a newline-separated sequence of compact one-line JSON values to
      a channel.
      See <code class="code">to_channel</code> for the role of the optional arguments.</div></div>
<pre><span class="VALstream_to_file"><span class="keyword">val</span> stream_to_file</span> : <code class="type">?len:int -&gt; ?std:bool -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a newline-separated sequence of compact one-line JSON values to
      a file.
      See <code class="code">to_string</code> for the role of the optional arguments.</div></div>
<pre><span class="VALstream_to_outbuf"><span class="keyword">val</span> stream_to_outbuf</span> : <code class="type">?std:bool -&gt; <a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a newline-separated sequence of compact one-line JSON values to
      an existing buffer.
      See <code class="code">to_string</code> for the role of the optional arguments.</div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">Miscellaneous</h2></div></div>
<pre><span class="VALsort"><span class="keyword">val</span> sort</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a></code></pre><div class="info"><div class="info">Sort object fields (stable sort, comparing field names
      and treating them as byte sequences)</div></div>
<pre><span class="VALwrite_null"><span class="keyword">val</span> write_null</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; unit -&gt; unit</code></pre>
<pre><span class="VALwrite_bool"><span class="keyword">val</span> write_bool</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; bool -&gt; unit</code></pre>
<pre><span class="VALwrite_int"><span class="keyword">val</span> write_int</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; int -&gt; unit</code></pre>
<pre><span class="VALwrite_float"><span class="keyword">val</span> write_float</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; float -&gt; unit</code></pre>
<pre><span class="VALwrite_std_float"><span class="keyword">val</span> write_std_float</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; float -&gt; unit</code></pre>
<pre><span class="VALwrite_float_fast"><span class="keyword">val</span> write_float_fast</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; float -&gt; unit</code></pre>
<pre><span class="VALwrite_std_float_fast"><span class="keyword">val</span> write_std_float_fast</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; float -&gt; unit</code></pre>
<pre><span class="VALwrite_float_prec"><span class="keyword">val</span> write_float_prec</span> : <code class="type">int -&gt; <a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; float -&gt; unit</code></pre>
<pre><span class="VALwrite_std_float_prec"><span class="keyword">val</span> write_std_float_prec</span> : <code class="type">int -&gt; <a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; float -&gt; unit</code></pre>
<pre><span class="VALwrite_string"><span class="keyword">val</span> write_string</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; string -&gt; unit</code></pre>
<pre><span class="VALwrite_intlit"><span class="keyword">val</span> write_intlit</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; string -&gt; unit</code></pre>
<pre><span class="VALwrite_assoc"><span class="keyword">val</span> write_assoc</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; (string * <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a>) list -&gt; unit</code></pre>
<pre><span class="VALwrite_list"><span class="keyword">val</span> write_list</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> list -&gt; unit</code></pre>
<pre><span class="VALwrite_tuple"><span class="keyword">val</span> write_tuple</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> list -&gt; unit</code></pre>
<pre><span class="VALwrite_std_tuple"><span class="keyword">val</span> write_std_tuple</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> list -&gt; unit</code></pre>
<pre><span class="VALwrite_variant"><span class="keyword">val</span> write_variant</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> option -&gt; unit</code></pre>
<pre><span class="VALwrite_std_variant"><span class="keyword">val</span> write_std_variant</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> option -&gt; unit</code></pre>
<pre><span class="VALwrite_json"><span class="keyword">val</span> write_json</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> -&gt; unit</code></pre>
<pre><span class="VALwrite_std_json"><span class="keyword">val</span> write_std_json</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> -&gt; unit</code></pre>
<div class="info"><div class="info"><h2 id="2_TITLE">JSON pretty-printing</h2></div></div>
<pre><span class="VALpretty_format"><span class="keyword">val</span> pretty_format</span> : <code class="type">?std:bool -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> -&gt; <a href="?package=easy-format&amp;module=Easy_format&amp;type=t">Easy_format.t</a></code></pre><div class="info"><div class="info">Convert into a pretty-printable tree.
      See <code class="code">to_string</code> for the role of the optional <code class="code">std</code> argument.<div class="see"><b>See also</b> <ul>  <li> <a href="http://martin.jambon.free.fr/easy-format.html">Easy-format</a></li></ul></div></div></div>
<pre><span class="VALpretty_to_string"><span class="keyword">val</span> pretty_to_string</span> : <code class="type">?std:bool -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> -&gt; string</code></pre><div class="info"><div class="info">Pretty-print into a string.
      See <code class="code">to_string</code> for the role of the optional <code class="code">std</code> argument.</div></div>
<pre><span class="VALpretty_to_channel"><span class="keyword">val</span> pretty_to_channel</span> : <code class="type">?std:bool -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=out_channel">Pervasives.out_channel</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> -&gt; unit</code></pre><div class="info"><div class="info">Pretty-print to a channel.
      See <code class="code">to_string</code> for the role of the optional <code class="code">std</code> argument.</div></div>
<pre><span class="VALprettify"><span class="keyword">val</span> prettify</span> : <code class="type">?std:bool -&gt; string -&gt; string</code></pre><div class="info"><div class="info">Combined parser and pretty-printer.
      See <code class="code">to_string</code> for the role of the optional <code class="code">std</code> argument.</div></div>
<pre><span class="VALcompact"><span class="keyword">val</span> compact</span> : <code class="type">?std:bool -&gt; string -&gt; string</code></pre><div class="info"><div class="info">Combined parser and printer.
      See <code class="code">to_string</code> for the role of the optional <code class="code">std</code> argument.</div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">JSON readers</h2></div></div>
<pre><span class="VALfrom_string"><span class="keyword">val</span> from_string</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?fname:string -&gt; ?lnum:int -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a></code></pre><div class="info"><div class="info">Read a JSON value from a string.<div class="parameters"><div class="param_info"><code class="code">buf</code> : use this buffer at will during parsing instead of creating
      a new one.</div><div class="param_info"><code class="code">fname</code> : data file name to be used in error messages. It does
      not have to be a real file.</div><div class="param_info"><code class="code">lnum</code> : number of the first line of input. Default is 1.</div></div></div></div>
<pre><span class="VALfrom_channel"><span class="keyword">val</span> from_channel</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?fname:string -&gt; ?lnum:int -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=in_channel">Pervasives.in_channel</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a></code></pre><div class="info"><div class="info">Read a JSON value from a channel.
      See <code class="code">from_string</code> for the meaning of the optional arguments.</div></div>
<pre><span class="VALfrom_file"><span class="keyword">val</span> from_file</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?fname:string -&gt; ?lnum:int -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a></code></pre><div class="info"><div class="info">Read a JSON value from a file.
      See <code class="code">from_string</code> for the meaning of the optional arguments.</div></div>
<pre><span class="TYPElexer_state"><span class="keyword">type</span> lexer_state</span> = {<code class="type"><a href="?package=yojson&amp;module=Yojson.Lexer_state&amp;type=t">Lexer_state.t</a></code>}</pre><table class="typetable">
		    <tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTlexer_state.buf">buf</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a></code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTlexer_state.lnum">lnum</span> : <code class="type">int</code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTlexer_state.bol">bol</span> : <code class="type">int</code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTlexer_state.fname">fname</span> : <code class="type">string option</code>;</code></td></tr><tr><td>}</td></tr></table><div class="info"><div class="info">This alias is provided for backward compatibility.
        New code should refer to  <a href="#Yojson.lexer_state">Yojson.lexer_state</a> directly.</div></div>
<pre><span class="VALinit_lexer"><span class="keyword">val</span> init_lexer</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?fname:string -&gt; ?lnum:int -&gt; unit -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a></code></pre><div class="info"><div class="info">This alias is provided for backward compatibility.
      New code should use  <a href="#Yojson.init_lexer">Yojson.init_lexer</a> directly.</div></div>
<pre><span class="VALfrom_lexbuf"><span class="keyword">val</span> from_lexbuf</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; ?stream:bool -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a></code></pre><div class="info"><div class="info">Read a JSON value from a lexbuf.
      A valid initial <code class="code">lexer_state</code> can be created with <code class="code">init_lexer</code>.
      See <code class="code">from_string</code> for the meaning of the optional arguments.<div class="parameters"><div class="param_info"><code class="code">stream</code> : indicates whether more data may follow. The default value
      is false and indicates that only JSON whitespace can be found between
      the end of the JSON value and the end of the input.</div></div></div></div>
<pre><span class="VALstream_from_string"><span class="keyword">val</span> stream_from_string</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?fname:string -&gt; ?lnum:int -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a></code></pre><div class="info"><div class="info">Input a sequence of JSON values from a string.
      Whitespace between JSON values is fine but not required.
      See <code class="code">from_string</code> for the meaning of the optional arguments.</div></div>
<pre><span class="VALstream_from_channel"><span class="keyword">val</span> stream_from_channel</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?fin:(unit -&gt; unit) -&gt;
?fname:string -&gt; ?lnum:int -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=in_channel">Pervasives.in_channel</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a></code></pre><div class="info"><div class="info">Input a sequence of JSON values from a channel.
      Whitespace between JSON values is fine but not required.<div class="parameters"><div class="param_info"><code class="code">fin</code> : finalization function executed once when the end of the
      stream is reached either because there is no more input or because
      the input could not be parsed, raising an exception.<br/>      See <code class="code">from_string</code> for the meaning of the other optional arguments.</div></div></div></div>
<pre><span class="VALstream_from_file"><span class="keyword">val</span> stream_from_file</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?fname:string -&gt; ?lnum:int -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a></code></pre><div class="info"><div class="info">Input a sequence of JSON values from a file.
      Whitespace between JSON values is fine but not required.<br/>      See <code class="code">from_string</code> for the meaning of the optional arguments.</div></div>
<pre><span class="VALstream_from_lexbuf"><span class="keyword">val</span> stream_from_lexbuf</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; ?fin:(unit -&gt; unit) -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a></code></pre><div class="info"><div class="info">Input a sequence of JSON values from a lexbuf.
      A valid initial <code class="code">lexer_state</code> can be created with <code class="code">init_lexer</code>.
      Whitespace between JSON values is fine but not required.<br/>      See <code class="code">stream_from_channel</code> for the meaning of the optional <code class="code">fin</code>
      argument.</div></div>
<pre><span class="TYPEjson_line"><span class="keyword">type</span> json_line</span> = <code class="type">[ `Exn of exn | `Json of <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> ]</code></pre><div class="info"><div class="info">The type of values resulting from a parsing attempt of a JSON value.</div></div>
<pre><span class="VALlinestream_from_channel"><span class="keyword">val</span> linestream_from_channel</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?fin:(unit -&gt; unit) -&gt;
?fname:string -&gt; ?lnum:int -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=in_channel">Pervasives.in_channel</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json_line">json_line</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a></code></pre><div class="info"><div class="info">Input a sequence of JSON values, one per line, from a channel.
      Exceptions raised when reading malformed lines are caught
      and represented using <code class="code">`Exn</code>.<br/>      See <code class="code">stream_from_channel</code> for the meaning of the optional <code class="code">fin</code>
      argument.
      See <code class="code">from_string</code> for the meaning of the other optional arguments.</div></div>
<pre><span class="VALlinestream_from_file"><span class="keyword">val</span> linestream_from_file</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?fname:string -&gt; ?lnum:int -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json_line">json_line</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a></code></pre><div class="info"><div class="info">Input a sequence of JSON values, one per line, from a file.
      Exceptions raised when reading malformed lines are caught
      and represented using <code class="code">`Exn</code>.<br/>      See <code class="code">stream_from_channel</code> for the meaning of the optional <code class="code">fin</code>
      argument.
      See <code class="code">from_string</code> for the meaning of the other optional arguments.</div></div>
<pre><span class="VALfinish_string"><span class="keyword">val</span> finish_string</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; string</code></pre>
<pre><span class="VALread_string"><span class="keyword">val</span> read_string</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; string</code></pre>
<pre><span class="VALread_ident"><span class="keyword">val</span> read_ident</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; string</code></pre>
<pre><span class="VALmap_string"><span class="keyword">val</span> map_string</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; (string -&gt; int -&gt; int -&gt; 'a) -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a</code></pre>
<pre><span class="VALmap_ident"><span class="keyword">val</span> map_ident</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; (string -&gt; int -&gt; int -&gt; 'a) -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a</code></pre>
<pre><span class="TYPEvariant_kind"><span class="keyword">type</span> variant_kind</span> = <code class="type">[ `Double_quote | `Edgy_bracket | `Square_bracket ]</code></pre>
<pre><span class="VALstart_any_variant"><span class="keyword">val</span> start_any_variant</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=variant_kind">variant_kind</a></code></pre>
<pre><span class="VALfinish_variant"><span class="keyword">val</span> finish_variant</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a> option</code></pre>
<pre><span class="VALfinish_skip_variant"><span class="keyword">val</span> finish_skip_variant</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_lt"><span class="keyword">val</span> read_lt</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_gt"><span class="keyword">val</span> read_gt</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_comma"><span class="keyword">val</span> read_comma</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALfinish_stringlit"><span class="keyword">val</span> finish_stringlit</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; string</code></pre>
<pre><span class="VALfinish_skip_stringlit"><span class="keyword">val</span> finish_skip_stringlit</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALfinish_escaped_char"><span class="keyword">val</span> finish_escaped_char</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALfinish_comment"><span class="keyword">val</span> finish_comment</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_space"><span class="keyword">val</span> read_space</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_eof"><span class="keyword">val</span> read_eof</span> : <code class="type"><a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; bool</code></pre>
<pre><span class="VALread_null"><span class="keyword">val</span> read_null</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_null_if_possible"><span class="keyword">val</span> read_null_if_possible</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; bool</code></pre>
<pre><span class="VALread_bool"><span class="keyword">val</span> read_bool</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; bool</code></pre>
<pre><span class="VALread_int"><span class="keyword">val</span> read_int</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; int</code></pre>
<pre><span class="VALread_int8"><span class="keyword">val</span> read_int8</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; char</code></pre>
<pre><span class="VALread_int32"><span class="keyword">val</span> read_int32</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; int32</code></pre>
<pre><span class="VALread_int64"><span class="keyword">val</span> read_int64</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; int64</code></pre>
<pre><span class="VALread_number"><span class="keyword">val</span> read_number</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; float</code></pre>
<pre><span class="VALskip_ident"><span class="keyword">val</span> skip_ident</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_sequence"><span class="keyword">val</span> read_sequence</span> : <code class="type">('a -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a) -&gt;
'a -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a</code></pre>
<pre><span class="VALread_list"><span class="keyword">val</span> read_list</span> : <code class="type">(<a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a) -&gt;
<a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a list</code></pre>
<pre><span class="VALread_list_rev"><span class="keyword">val</span> read_list_rev</span> : <code class="type">(<a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a) -&gt;
<a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a list</code></pre>
<pre><span class="VALread_array_end"><span class="keyword">val</span> read_array_end</span> : <code class="type"><a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_array_sep"><span class="keyword">val</span> read_array_sep</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_array"><span class="keyword">val</span> read_array</span> : <code class="type">(<a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a) -&gt;
<a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a array</code></pre>
<pre><span class="VALread_tuple"><span class="keyword">val</span> read_tuple</span> : <code class="type">(int -&gt; 'a -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a) -&gt;
'a -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a</code></pre>
<pre><span class="VALstart_any_tuple"><span class="keyword">val</span> start_any_tuple</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; bool</code></pre>
<pre><span class="VALread_lpar"><span class="keyword">val</span> read_lpar</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_rpar"><span class="keyword">val</span> read_rpar</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_tuple_end"><span class="keyword">val</span> read_tuple_end</span> : <code class="type"><a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_tuple_end2"><span class="keyword">val</span> read_tuple_end2</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; bool -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_tuple_sep"><span class="keyword">val</span> read_tuple_sep</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_tuple_sep2"><span class="keyword">val</span> read_tuple_sep2</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; bool -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_lbr"><span class="keyword">val</span> read_lbr</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_rbr"><span class="keyword">val</span> read_rbr</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_fields"><span class="keyword">val</span> read_fields</span> : <code class="type">('a -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a) -&gt;
'a -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a</code></pre>
<pre><span class="VALread_lcurl"><span class="keyword">val</span> read_lcurl</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_object_end"><span class="keyword">val</span> read_object_end</span> : <code class="type"><a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_object_sep"><span class="keyword">val</span> read_object_sep</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_colon"><span class="keyword">val</span> read_colon</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_json"><span class="keyword">val</span> read_json</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Safe&amp;type=json">json</a></code></pre>
<pre><span class="VALskip_json"><span class="keyword">val</span> skip_json</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Safe&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre></div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">JSON tree type with literal int/float/string leaves</h1></div></div>
<div class="ocaml_module sig" name="Raw"><pre><span class="keyword">module</span> <a href="?package=yojson&amp;module=Yojson.Raw">Raw</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<div class="info"><div class="info">Ints, floats and strings literals are systematically preserved using
   <code class="code">`Intlit</code>, <code class="code">`Floatlit</code> and <code class="code">`Stringlit</code>.
   This module also supports the specific syntax for variants and tuples
   supported by  <a href="#Yojson.Safe">Yojson.Safe</a>.</div></div>
<div class="info"><div class="info"><h3 id="3_TITLE">Type of the JSON tree</h3></div></div>
<pre><span class="TYPEjson"><span class="keyword">type</span> json</span> = <code class="type">[ `Assoc of (string * <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a>) list
| `Bool of bool
| `Floatlit of string
| `Intlit of string
| `List of <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> list
| `Null
| `Stringlit of string
| `Tuple of <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> list
| `Variant of string * <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> option ]</code></pre><div class="info"><div class="info">All possible cases defined in Yojson:<ul><li>`Null: JSON null</li><li>`Bool of bool: JSON boolean</li><li>`Int of int: JSON number without decimal point or exponent.</li><li>`Intlit of string: JSON number without decimal point or exponent,
	    preserved as a string.</li><li>`Float of float: JSON number, Infinity, -Infinity or NaN.</li><li>`Floatlit of string: JSON number, Infinity, -Infinity or NaN,
	    preserved as a string.</li><li>`String of string: JSON string. Bytes in the range 128-255 are preserved
	    as-is without encoding validation for both reading
	    and writing.</li><li>`Stringlit of string: JSON string literal including the double quotes.</li><li>`Assoc of (string * json) list: JSON object.</li><li>`List of json list: JSON array.</li><li>`Tuple of json list: Tuple (non-standard extension of JSON).
	    Syntax: <code class="code">(&quot;abc&quot;, 123)</code>.</li><li>`Variant of (string * json option): Variant (non-standard extension of JSON).
	    Syntax: <code class="code">&lt;&quot;Foo&quot;&gt;</code> or <code class="code">&lt;&quot;Bar&quot;:123&gt;</code>.
</li></ul></div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">JSON writers</h2></div></div>
<pre><span class="VALto_string"><span class="keyword">val</span> to_string</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?len:int -&gt; ?std:bool -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> -&gt; string</code></pre><div class="info"><div class="info">Write a compact JSON value to a string.<div class="parameters"><div class="param_info"><code class="code">buf</code> : allows to reuse an existing buffer created with 
      <code class="code">Bi_outbuf.create</code>. The buffer is cleared of all contents
      before starting and right before returning.</div><div class="param_info"><code class="code">len</code> : initial length of the output buffer.</div><div class="param_info"><code class="code">std</code> : use only standard JSON syntax,
      i.e. convert tuples and variants into standard JSON (if applicable),
      refuse to print NaN and infinities,
      require the root node to be either an object or an array.
      Default is <code class="code">false</code>.</div></div></div></div>
<pre><span class="VALto_channel"><span class="keyword">val</span> to_channel</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?len:int -&gt; ?std:bool -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=out_channel">Pervasives.out_channel</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a compact JSON value to a channel.<div class="parameters"><div class="param_info"><code class="code">buf</code> : allows to reuse an existing buffer created with 
      <code class="code">Bi_outbuf.create_channel_writer</code> on the same channel.
      <code class="code">buf</code> is flushed right
      before <code class="code">to_channel</code> returns but the <code class="code">out_channel</code> is
      not flushed automatically.<br/>      See <code class="code">to_string</code> for the role of the other optional arguments.</div></div></div></div>
<pre><span class="VALto_output"><span class="keyword">val</span> to_output</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?len:int -&gt;
?std:bool -&gt; &lt; output : string -&gt; int -&gt; int -&gt; int; .. &gt; -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a compact JSON value to an OO channel.<div class="parameters"><div class="param_info"><code class="code">buf</code> : allows to reuse an existing buffer created with 
      <code class="code">Bi_outbuf.create_output_writer</code> on the same channel.
      <code class="code">buf</code> is flushed right
      before <code class="code">to_output</code> returns but the channel itself is
      not flushed automatically.<br/>      See <code class="code">to_string</code> for the role of the other optional arguments.</div></div></div></div>
<pre><span class="VALto_file"><span class="keyword">val</span> to_file</span> : <code class="type">?len:int -&gt; ?std:bool -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a compact JSON value to a file.
      See <code class="code">to_string</code> for the role of the optional arguments.</div></div>
<pre><span class="VALto_outbuf"><span class="keyword">val</span> to_outbuf</span> : <code class="type">?std:bool -&gt; <a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a compact JSON value to an existing buffer.
      See <code class="code">to_string</code> for the role of the optional argument.</div></div>
<pre><span class="VALstream_to_string"><span class="keyword">val</span> stream_to_string</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?len:int -&gt; ?std:bool -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a> -&gt; string</code></pre><div class="info"><div class="info">Write a newline-separated sequence of compact one-line JSON values to
      a string.
      See <code class="code">to_string</code> for the role of the optional arguments.</div></div>
<pre><span class="VALstream_to_channel"><span class="keyword">val</span> stream_to_channel</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?len:int -&gt; ?std:bool -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=out_channel">Pervasives.out_channel</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a newline-separated sequence of compact one-line JSON values to
      a channel.
      See <code class="code">to_channel</code> for the role of the optional arguments.</div></div>
<pre><span class="VALstream_to_file"><span class="keyword">val</span> stream_to_file</span> : <code class="type">?len:int -&gt; ?std:bool -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a newline-separated sequence of compact one-line JSON values to
      a file.
      See <code class="code">to_string</code> for the role of the optional arguments.</div></div>
<pre><span class="VALstream_to_outbuf"><span class="keyword">val</span> stream_to_outbuf</span> : <code class="type">?std:bool -&gt; <a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a newline-separated sequence of compact one-line JSON values to
      an existing buffer.
      See <code class="code">to_string</code> for the role of the optional arguments.</div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">Miscellaneous</h2></div></div>
<pre><span class="VALsort"><span class="keyword">val</span> sort</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a></code></pre><div class="info"><div class="info">Sort object fields (stable sort, comparing field names
      and treating them as byte sequences)</div></div>
<pre><span class="VALwrite_null"><span class="keyword">val</span> write_null</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; unit -&gt; unit</code></pre>
<pre><span class="VALwrite_bool"><span class="keyword">val</span> write_bool</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; bool -&gt; unit</code></pre>
<pre><span class="VALwrite_intlit"><span class="keyword">val</span> write_intlit</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; string -&gt; unit</code></pre>
<pre><span class="VALwrite_floatlit"><span class="keyword">val</span> write_floatlit</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; string -&gt; unit</code></pre>
<pre><span class="VALwrite_stringlit"><span class="keyword">val</span> write_stringlit</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; string -&gt; unit</code></pre>
<pre><span class="VALwrite_assoc"><span class="keyword">val</span> write_assoc</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; (string * <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a>) list -&gt; unit</code></pre>
<pre><span class="VALwrite_list"><span class="keyword">val</span> write_list</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> list -&gt; unit</code></pre>
<pre><span class="VALwrite_tuple"><span class="keyword">val</span> write_tuple</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> list -&gt; unit</code></pre>
<pre><span class="VALwrite_std_tuple"><span class="keyword">val</span> write_std_tuple</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> list -&gt; unit</code></pre>
<pre><span class="VALwrite_variant"><span class="keyword">val</span> write_variant</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> option -&gt; unit</code></pre>
<pre><span class="VALwrite_std_variant"><span class="keyword">val</span> write_std_variant</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> option -&gt; unit</code></pre>
<pre><span class="VALwrite_json"><span class="keyword">val</span> write_json</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> -&gt; unit</code></pre>
<pre><span class="VALwrite_std_json"><span class="keyword">val</span> write_std_json</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> -&gt; unit</code></pre>
<div class="info"><div class="info"><h2 id="2_TITLE">JSON pretty-printing</h2></div></div>
<pre><span class="VALpretty_format"><span class="keyword">val</span> pretty_format</span> : <code class="type">?std:bool -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> -&gt; <a href="?package=easy-format&amp;module=Easy_format&amp;type=t">Easy_format.t</a></code></pre><div class="info"><div class="info">Convert into a pretty-printable tree.
      See <code class="code">to_string</code> for the role of the optional <code class="code">std</code> argument.<div class="see"><b>See also</b> <ul>  <li> <a href="http://martin.jambon.free.fr/easy-format.html">Easy-format</a></li></ul></div></div></div>
<pre><span class="VALpretty_to_string"><span class="keyword">val</span> pretty_to_string</span> : <code class="type">?std:bool -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> -&gt; string</code></pre><div class="info"><div class="info">Pretty-print into a string.
      See <code class="code">to_string</code> for the role of the optional <code class="code">std</code> argument.</div></div>
<pre><span class="VALpretty_to_channel"><span class="keyword">val</span> pretty_to_channel</span> : <code class="type">?std:bool -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=out_channel">Pervasives.out_channel</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> -&gt; unit</code></pre><div class="info"><div class="info">Pretty-print to a channel.
      See <code class="code">to_string</code> for the role of the optional <code class="code">std</code> argument.</div></div>
<pre><span class="VALprettify"><span class="keyword">val</span> prettify</span> : <code class="type">?std:bool -&gt; string -&gt; string</code></pre><div class="info"><div class="info">Combined parser and pretty-printer.
      See <code class="code">to_string</code> for the role of the optional <code class="code">std</code> argument.</div></div>
<pre><span class="VALcompact"><span class="keyword">val</span> compact</span> : <code class="type">?std:bool -&gt; string -&gt; string</code></pre><div class="info"><div class="info">Combined parser and printer.
      See <code class="code">to_string</code> for the role of the optional <code class="code">std</code> argument.</div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">JSON readers</h2></div></div>
<pre><span class="VALfrom_string"><span class="keyword">val</span> from_string</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?fname:string -&gt; ?lnum:int -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a></code></pre><div class="info"><div class="info">Read a JSON value from a string.<div class="parameters"><div class="param_info"><code class="code">buf</code> : use this buffer at will during parsing instead of creating
      a new one.</div><div class="param_info"><code class="code">fname</code> : data file name to be used in error messages. It does
      not have to be a real file.</div><div class="param_info"><code class="code">lnum</code> : number of the first line of input. Default is 1.</div></div></div></div>
<pre><span class="VALfrom_channel"><span class="keyword">val</span> from_channel</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?fname:string -&gt; ?lnum:int -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=in_channel">Pervasives.in_channel</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a></code></pre><div class="info"><div class="info">Read a JSON value from a channel.
      See <code class="code">from_string</code> for the meaning of the optional arguments.</div></div>
<pre><span class="VALfrom_file"><span class="keyword">val</span> from_file</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?fname:string -&gt; ?lnum:int -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a></code></pre><div class="info"><div class="info">Read a JSON value from a file.
      See <code class="code">from_string</code> for the meaning of the optional arguments.</div></div>
<pre><span class="TYPElexer_state"><span class="keyword">type</span> lexer_state</span> = {<code class="type"><a href="?package=yojson&amp;module=Yojson.Lexer_state&amp;type=t">Lexer_state.t</a></code>}</pre><table class="typetable">
		    <tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTlexer_state.buf">buf</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a></code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTlexer_state.lnum">lnum</span> : <code class="type">int</code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTlexer_state.bol">bol</span> : <code class="type">int</code>;</code></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTlexer_state.fname">fname</span> : <code class="type">string option</code>;</code></td></tr><tr><td>}</td></tr></table><div class="info"><div class="info">This alias is provided for backward compatibility.
        New code should refer to  <a href="#Yojson.lexer_state">Yojson.lexer_state</a> directly.</div></div>
<pre><span class="VALinit_lexer"><span class="keyword">val</span> init_lexer</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?fname:string -&gt; ?lnum:int -&gt; unit -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a></code></pre><div class="info"><div class="info">This alias is provided for backward compatibility.
      New code should use  <a href="#Yojson.init_lexer">Yojson.init_lexer</a> directly.</div></div>
<pre><span class="VALfrom_lexbuf"><span class="keyword">val</span> from_lexbuf</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; ?stream:bool -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a></code></pre><div class="info"><div class="info">Read a JSON value from a lexbuf.
      A valid initial <code class="code">lexer_state</code> can be created with <code class="code">init_lexer</code>.
      See <code class="code">from_string</code> for the meaning of the optional arguments.<div class="parameters"><div class="param_info"><code class="code">stream</code> : indicates whether more data may follow. The default value
      is false and indicates that only JSON whitespace can be found between
      the end of the JSON value and the end of the input.</div></div></div></div>
<pre><span class="VALstream_from_string"><span class="keyword">val</span> stream_from_string</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?fname:string -&gt; ?lnum:int -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a></code></pre><div class="info"><div class="info">Input a sequence of JSON values from a string.
      Whitespace between JSON values is fine but not required.
      See <code class="code">from_string</code> for the meaning of the optional arguments.</div></div>
<pre><span class="VALstream_from_channel"><span class="keyword">val</span> stream_from_channel</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?fin:(unit -&gt; unit) -&gt;
?fname:string -&gt; ?lnum:int -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=in_channel">Pervasives.in_channel</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a></code></pre><div class="info"><div class="info">Input a sequence of JSON values from a channel.
      Whitespace between JSON values is fine but not required.<div class="parameters"><div class="param_info"><code class="code">fin</code> : finalization function executed once when the end of the
      stream is reached either because there is no more input or because
      the input could not be parsed, raising an exception.<br/>      See <code class="code">from_string</code> for the meaning of the other optional arguments.</div></div></div></div>
<pre><span class="VALstream_from_file"><span class="keyword">val</span> stream_from_file</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?fname:string -&gt; ?lnum:int -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a></code></pre><div class="info"><div class="info">Input a sequence of JSON values from a file.
      Whitespace between JSON values is fine but not required.<br/>      See <code class="code">from_string</code> for the meaning of the optional arguments.</div></div>
<pre><span class="VALstream_from_lexbuf"><span class="keyword">val</span> stream_from_lexbuf</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; ?fin:(unit -&gt; unit) -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a></code></pre><div class="info"><div class="info">Input a sequence of JSON values from a lexbuf.
      A valid initial <code class="code">lexer_state</code> can be created with <code class="code">init_lexer</code>.
      Whitespace between JSON values is fine but not required.<br/>      See <code class="code">stream_from_channel</code> for the meaning of the optional <code class="code">fin</code>
      argument.</div></div>
<pre><span class="TYPEjson_line"><span class="keyword">type</span> json_line</span> = <code class="type">[ `Exn of exn | `Json of <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> ]</code></pre><div class="info"><div class="info">The type of values resulting from a parsing attempt of a JSON value.</div></div>
<pre><span class="VALlinestream_from_channel"><span class="keyword">val</span> linestream_from_channel</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?fin:(unit -&gt; unit) -&gt;
?fname:string -&gt; ?lnum:int -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=in_channel">Pervasives.in_channel</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json_line">json_line</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a></code></pre><div class="info"><div class="info">Input a sequence of JSON values, one per line, from a channel.
      Exceptions raised when reading malformed lines are caught
      and represented using <code class="code">`Exn</code>.<br/>      See <code class="code">stream_from_channel</code> for the meaning of the optional <code class="code">fin</code>
      argument.
      See <code class="code">from_string</code> for the meaning of the other optional arguments.</div></div>
<pre><span class="VALlinestream_from_file"><span class="keyword">val</span> linestream_from_file</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?fname:string -&gt; ?lnum:int -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json_line">json_line</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a></code></pre><div class="info"><div class="info">Input a sequence of JSON values, one per line, from a file.
      Exceptions raised when reading malformed lines are caught
      and represented using <code class="code">`Exn</code>.<br/>      See <code class="code">stream_from_channel</code> for the meaning of the optional <code class="code">fin</code>
      argument.
      See <code class="code">from_string</code> for the meaning of the other optional arguments.</div></div>
<pre><span class="VALfinish_string"><span class="keyword">val</span> finish_string</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; string</code></pre>
<pre><span class="VALread_string"><span class="keyword">val</span> read_string</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; string</code></pre>
<pre><span class="VALread_ident"><span class="keyword">val</span> read_ident</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; string</code></pre>
<pre><span class="VALmap_string"><span class="keyword">val</span> map_string</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; (string -&gt; int -&gt; int -&gt; 'a) -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a</code></pre>
<pre><span class="VALmap_ident"><span class="keyword">val</span> map_ident</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; (string -&gt; int -&gt; int -&gt; 'a) -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a</code></pre>
<pre><span class="TYPEvariant_kind"><span class="keyword">type</span> variant_kind</span> = <code class="type">[ `Double_quote | `Edgy_bracket | `Square_bracket ]</code></pre>
<pre><span class="VALstart_any_variant"><span class="keyword">val</span> start_any_variant</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=variant_kind">variant_kind</a></code></pre>
<pre><span class="VALfinish_variant"><span class="keyword">val</span> finish_variant</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a> option</code></pre>
<pre><span class="VALfinish_skip_variant"><span class="keyword">val</span> finish_skip_variant</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_lt"><span class="keyword">val</span> read_lt</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_gt"><span class="keyword">val</span> read_gt</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_comma"><span class="keyword">val</span> read_comma</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALfinish_stringlit"><span class="keyword">val</span> finish_stringlit</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; string</code></pre>
<pre><span class="VALfinish_skip_stringlit"><span class="keyword">val</span> finish_skip_stringlit</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALfinish_escaped_char"><span class="keyword">val</span> finish_escaped_char</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALfinish_comment"><span class="keyword">val</span> finish_comment</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_space"><span class="keyword">val</span> read_space</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_eof"><span class="keyword">val</span> read_eof</span> : <code class="type"><a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; bool</code></pre>
<pre><span class="VALread_null"><span class="keyword">val</span> read_null</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_null_if_possible"><span class="keyword">val</span> read_null_if_possible</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; bool</code></pre>
<pre><span class="VALread_bool"><span class="keyword">val</span> read_bool</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; bool</code></pre>
<pre><span class="VALread_int"><span class="keyword">val</span> read_int</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; int</code></pre>
<pre><span class="VALread_int8"><span class="keyword">val</span> read_int8</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; char</code></pre>
<pre><span class="VALread_int32"><span class="keyword">val</span> read_int32</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; int32</code></pre>
<pre><span class="VALread_int64"><span class="keyword">val</span> read_int64</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; int64</code></pre>
<pre><span class="VALread_number"><span class="keyword">val</span> read_number</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; float</code></pre>
<pre><span class="VALskip_ident"><span class="keyword">val</span> skip_ident</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_sequence"><span class="keyword">val</span> read_sequence</span> : <code class="type">('a -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a) -&gt;
'a -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a</code></pre>
<pre><span class="VALread_list"><span class="keyword">val</span> read_list</span> : <code class="type">(<a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a) -&gt;
<a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a list</code></pre>
<pre><span class="VALread_list_rev"><span class="keyword">val</span> read_list_rev</span> : <code class="type">(<a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a) -&gt;
<a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a list</code></pre>
<pre><span class="VALread_array_end"><span class="keyword">val</span> read_array_end</span> : <code class="type"><a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_array_sep"><span class="keyword">val</span> read_array_sep</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_array"><span class="keyword">val</span> read_array</span> : <code class="type">(<a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a) -&gt;
<a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a array</code></pre>
<pre><span class="VALread_tuple"><span class="keyword">val</span> read_tuple</span> : <code class="type">(int -&gt; 'a -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a) -&gt;
'a -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a</code></pre>
<pre><span class="VALstart_any_tuple"><span class="keyword">val</span> start_any_tuple</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; bool</code></pre>
<pre><span class="VALread_lpar"><span class="keyword">val</span> read_lpar</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_rpar"><span class="keyword">val</span> read_rpar</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_tuple_end"><span class="keyword">val</span> read_tuple_end</span> : <code class="type"><a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_tuple_end2"><span class="keyword">val</span> read_tuple_end2</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; bool -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_tuple_sep"><span class="keyword">val</span> read_tuple_sep</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_tuple_sep2"><span class="keyword">val</span> read_tuple_sep2</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; bool -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_lbr"><span class="keyword">val</span> read_lbr</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_rbr"><span class="keyword">val</span> read_rbr</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_fields"><span class="keyword">val</span> read_fields</span> : <code class="type">('a -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a) -&gt;
'a -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; 'a</code></pre>
<pre><span class="VALread_lcurl"><span class="keyword">val</span> read_lcurl</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_object_end"><span class="keyword">val</span> read_object_end</span> : <code class="type"><a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_object_sep"><span class="keyword">val</span> read_object_sep</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_colon"><span class="keyword">val</span> read_colon</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre>
<pre><span class="VALread_json"><span class="keyword">val</span> read_json</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; <a href="?package=yojson&amp;module=Yojson.Raw&amp;type=json">json</a></code></pre>
<pre><span class="VALskip_json"><span class="keyword">val</span> skip_json</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson.Raw&amp;type=lexer_state">lexer_state</a> -&gt; <a href="?package=ocaml&amp;module=Lexing&amp;type=lexbuf">Lexing.lexbuf</a> -&gt; unit</code></pre></div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Supertype of all JSON tree types</h1></div></div>
<div class="info"><div class="info"><h3 id="3_TITLE">Type of the JSON tree</h3></div></div>
<pre><span class="TYPEjson"><span class="keyword">type</span> json</span> = <code class="type">[ `Assoc of (string * <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a>) list
| `Bool of bool
| `Float of float
| `Floatlit of string
| `Int of int
| `Intlit of string
| `List of <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> list
| `Null
| `String of string
| `Stringlit of string
| `Tuple of <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> list
| `Variant of string * <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> option ]</code></pre><div class="info"><div class="info">All possible cases defined in Yojson:<ul><li>`Null: JSON null</li><li>`Bool of bool: JSON boolean</li><li>`Int of int: JSON number without decimal point or exponent.</li><li>`Intlit of string: JSON number without decimal point or exponent,
	    preserved as a string.</li><li>`Float of float: JSON number, Infinity, -Infinity or NaN.</li><li>`Floatlit of string: JSON number, Infinity, -Infinity or NaN,
	    preserved as a string.</li><li>`String of string: JSON string. Bytes in the range 128-255 are preserved
	    as-is without encoding validation for both reading
	    and writing.</li><li>`Stringlit of string: JSON string literal including the double quotes.</li><li>`Assoc of (string * json) list: JSON object.</li><li>`List of json list: JSON array.</li><li>`Tuple of json list: Tuple (non-standard extension of JSON).
	    Syntax: <code class="code">(&quot;abc&quot;, 123)</code>.</li><li>`Variant of (string * json option): Variant (non-standard extension of JSON).
	    Syntax: <code class="code">&lt;&quot;Foo&quot;&gt;</code> or <code class="code">&lt;&quot;Bar&quot;:123&gt;</code>.
</li></ul></div></div>
<pre><span class="TYPEjson_max"><span class="keyword">type</span> json_max</span> = <code class="type"><a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a></code></pre><div class="info"><div class="info"><h2 id="2_TITLE">JSON writers</h2></div></div>
<pre><span class="VALto_string"><span class="keyword">val</span> to_string</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?len:int -&gt; ?std:bool -&gt; <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> -&gt; string</code></pre><div class="info"><div class="info">Write a compact JSON value to a string.<div class="parameters"><div class="param_info"><code class="code">buf</code> : allows to reuse an existing buffer created with 
      <code class="code">Bi_outbuf.create</code>. The buffer is cleared of all contents
      before starting and right before returning.</div><div class="param_info"><code class="code">len</code> : initial length of the output buffer.</div><div class="param_info"><code class="code">std</code> : use only standard JSON syntax,
      i.e. convert tuples and variants into standard JSON (if applicable),
      refuse to print NaN and infinities,
      require the root node to be either an object or an array.
      Default is <code class="code">false</code>.</div></div></div></div>
<pre><span class="VALto_channel"><span class="keyword">val</span> to_channel</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?len:int -&gt; ?std:bool -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=out_channel">Pervasives.out_channel</a> -&gt; <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a compact JSON value to a channel.<div class="parameters"><div class="param_info"><code class="code">buf</code> : allows to reuse an existing buffer created with 
      <code class="code">Bi_outbuf.create_channel_writer</code> on the same channel.
      <code class="code">buf</code> is flushed right
      before <code class="code">to_channel</code> returns but the <code class="code">out_channel</code> is
      not flushed automatically.<br/>      See <code class="code">to_string</code> for the role of the other optional arguments.</div></div></div></div>
<pre><span class="VALto_output"><span class="keyword">val</span> to_output</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?len:int -&gt;
?std:bool -&gt; &lt; output : string -&gt; int -&gt; int -&gt; int; .. &gt; -&gt; <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a compact JSON value to an OO channel.<div class="parameters"><div class="param_info"><code class="code">buf</code> : allows to reuse an existing buffer created with 
      <code class="code">Bi_outbuf.create_output_writer</code> on the same channel.
      <code class="code">buf</code> is flushed right
      before <code class="code">to_output</code> returns but the channel itself is
      not flushed automatically.<br/>      See <code class="code">to_string</code> for the role of the other optional arguments.</div></div></div></div>
<pre><span class="VALto_file"><span class="keyword">val</span> to_file</span> : <code class="type">?len:int -&gt; ?std:bool -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a compact JSON value to a file.
      See <code class="code">to_string</code> for the role of the optional arguments.</div></div>
<pre><span class="VALto_outbuf"><span class="keyword">val</span> to_outbuf</span> : <code class="type">?std:bool -&gt; <a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a compact JSON value to an existing buffer.
      See <code class="code">to_string</code> for the role of the optional argument.</div></div>
<pre><span class="VALstream_to_string"><span class="keyword">val</span> stream_to_string</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; ?len:int -&gt; ?std:bool -&gt; <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a> -&gt; string</code></pre><div class="info"><div class="info">Write a newline-separated sequence of compact one-line JSON values to
      a string.
      See <code class="code">to_string</code> for the role of the optional arguments.</div></div>
<pre><span class="VALstream_to_channel"><span class="keyword">val</span> stream_to_channel</span> : <code class="type">?buf:<a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt;
?len:int -&gt; ?std:bool -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=out_channel">Pervasives.out_channel</a> -&gt; <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a newline-separated sequence of compact one-line JSON values to
      a channel.
      See <code class="code">to_channel</code> for the role of the optional arguments.</div></div>
<pre><span class="VALstream_to_file"><span class="keyword">val</span> stream_to_file</span> : <code class="type">?len:int -&gt; ?std:bool -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a newline-separated sequence of compact one-line JSON values to
      a file.
      See <code class="code">to_string</code> for the role of the optional arguments.</div></div>
<pre><span class="VALstream_to_outbuf"><span class="keyword">val</span> stream_to_outbuf</span> : <code class="type">?std:bool -&gt; <a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> <a href="?package=ocaml&amp;module=Stream&amp;type=t">Stream.t</a> -&gt; unit</code></pre><div class="info"><div class="info">Write a newline-separated sequence of compact one-line JSON values to
      an existing buffer.
      See <code class="code">to_string</code> for the role of the optional arguments.</div></div>
<div class="info"><div class="info"><h2 id="2_TITLE">Miscellaneous</h2></div></div>
<pre><span class="VALsort"><span class="keyword">val</span> sort</span> : <code class="type"><a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> -&gt; <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a></code></pre><div class="info"><div class="info">Sort object fields (stable sort, comparing field names
      and treating them as byte sequences)</div></div>
<pre><span class="VALwrite_null"><span class="keyword">val</span> write_null</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; unit -&gt; unit</code></pre>
<pre><span class="VALwrite_bool"><span class="keyword">val</span> write_bool</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; bool -&gt; unit</code></pre>
<pre><span class="VALwrite_int"><span class="keyword">val</span> write_int</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; int -&gt; unit</code></pre>
<pre><span class="VALwrite_float"><span class="keyword">val</span> write_float</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; float -&gt; unit</code></pre>
<pre><span class="VALwrite_std_float"><span class="keyword">val</span> write_std_float</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; float -&gt; unit</code></pre>
<pre><span class="VALwrite_float_fast"><span class="keyword">val</span> write_float_fast</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; float -&gt; unit</code></pre>
<pre><span class="VALwrite_std_float_fast"><span class="keyword">val</span> write_std_float_fast</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; float -&gt; unit</code></pre>
<pre><span class="VALwrite_float_prec"><span class="keyword">val</span> write_float_prec</span> : <code class="type">int -&gt; <a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; float -&gt; unit</code></pre>
<pre><span class="VALwrite_std_float_prec"><span class="keyword">val</span> write_std_float_prec</span> : <code class="type">int -&gt; <a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; float -&gt; unit</code></pre>
<pre><span class="VALwrite_string"><span class="keyword">val</span> write_string</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; string -&gt; unit</code></pre>
<pre><span class="VALwrite_intlit"><span class="keyword">val</span> write_intlit</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; string -&gt; unit</code></pre>
<pre><span class="VALwrite_floatlit"><span class="keyword">val</span> write_floatlit</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; string -&gt; unit</code></pre>
<pre><span class="VALwrite_stringlit"><span class="keyword">val</span> write_stringlit</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; string -&gt; unit</code></pre>
<pre><span class="VALwrite_assoc"><span class="keyword">val</span> write_assoc</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; (string * <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a>) list -&gt; unit</code></pre>
<pre><span class="VALwrite_list"><span class="keyword">val</span> write_list</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> list -&gt; unit</code></pre>
<pre><span class="VALwrite_tuple"><span class="keyword">val</span> write_tuple</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> list -&gt; unit</code></pre>
<pre><span class="VALwrite_std_tuple"><span class="keyword">val</span> write_std_tuple</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> list -&gt; unit</code></pre>
<pre><span class="VALwrite_variant"><span class="keyword">val</span> write_variant</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> option -&gt; unit</code></pre>
<pre><span class="VALwrite_std_variant"><span class="keyword">val</span> write_std_variant</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; string -&gt; <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> option -&gt; unit</code></pre>
<pre><span class="VALwrite_json"><span class="keyword">val</span> write_json</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> -&gt; unit</code></pre>
<pre><span class="VALwrite_std_json"><span class="keyword">val</span> write_std_json</span> : <code class="type"><a href="?package=biniou&amp;module=Bi_outbuf&amp;type=t">Bi_outbuf.t</a> -&gt; <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> -&gt; unit</code></pre>
<div class="info"><div class="info"><h2 id="2_TITLE">JSON pretty-printing</h2></div></div>
<pre><span class="VALpretty_format"><span class="keyword">val</span> pretty_format</span> : <code class="type">?std:bool -&gt; <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> -&gt; <a href="?package=easy-format&amp;module=Easy_format&amp;type=t">Easy_format.t</a></code></pre><div class="info"><div class="info">Convert into a pretty-printable tree.
      See <code class="code">to_string</code> for the role of the optional <code class="code">std</code> argument.<div class="see"><b>See also</b> <ul>  <li> <a href="http://martin.jambon.free.fr/easy-format.html">Easy-format</a></li></ul></div></div></div>
<pre><span class="VALpretty_to_string"><span class="keyword">val</span> pretty_to_string</span> : <code class="type">?std:bool -&gt; <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> -&gt; string</code></pre><div class="info"><div class="info">Pretty-print into a string.
      See <code class="code">to_string</code> for the role of the optional <code class="code">std</code> argument.</div></div>
<pre><span class="VALpretty_to_channel"><span class="keyword">val</span> pretty_to_channel</span> : <code class="type">?std:bool -&gt; <a href="?package=ocaml&amp;module=Pervasives&amp;type=out_channel">Pervasives.out_channel</a> -&gt; <a href="?package=yojson&amp;module=Yojson&amp;type=json">json</a> -&gt; unit</code></pre><div class="info"><div class="info">Pretty-print to a channel.
      See <code class="code">to_string</code> for the role of the optional <code class="code">std</code> argument.</div></div>
</div>