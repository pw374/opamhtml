<div class="ocaml_toplevel_module"><div class="info">This module defines the <code class="code">Map</code> module for <code class="code">Core.Std</code>.  We use &quot;core_map&quot; as the file
    name rather than &quot;map&quot; to avoid conflicts with OCaml's standard map module.  In this
    documentation, we use <code class="code">Map</code> to mean this module, not the OCaml standard one.<br/>    <code class="code">Map</code> is a functional datastructure (balanced binary tree) implementing finite maps
    over a totally-ordered domain, called a &quot;key&quot;.  The map types and operations appear
    in three places:<br/>    <span class="verbatim">    | Map      | polymorphic map operations                                      |
    | Map.Poly | maps that use polymorphic comparison to order keys              |
    | Key.Map  | maps with a fixed key type that use [Key.compare] to order keys |
    </span><br/>    Where <code class="code">Key</code> is any module defining values that can be used as keys of a map, like
    <code class="code">Int</code>, <code class="code">String</code>, etc.  To add this functionality to an arbitrary module, use the
    <code class="code">Comparable.Make</code> functor.<br/>    One should use <code class="code">Map</code> for functions that access existing maps, like <code class="code">find</code>, <code class="code">mem</code>,
    <code class="code">add</code>, <code class="code">fold</code>, <code class="code">iter</code>, and <code class="code">to_alist</code>.  For functions that create maps, like <code class="code">empty</code>,
    <code class="code">singleton</code>, and <code class="code">of_alist</code>, one should strive to use the corresponding <code class="code">Key.Map</code>
    function, which will use the comparison function specifically for <code class="code">Key</code>.  As a last
    resort, if one does not have easy access to a comparison function for the keys in
    one's map, use <code class="code">Map.Poly</code> to create the map.  This will use OCaml's built-in
    polymorphic comparison to compare keys, which has all the usual performance and
    robustness problems that entails.<br/>    Parallel to the three kinds of map modules, there are also tree modules <code class="code">Map.Tree</code>,
    <code class="code">Map.Poly.Tree</code>, and <code class="code">Key.Map.Tree</code>.  A tree is a bare representation of a map,
    without the comparator.  Thus tree operations need to obtain the comparator from
    somewhere.  For <code class="code">Map.Poly.Tree</code> and <code class="code">Key.Map.Tree</code>, the comparator is implicit in the
    module name.  For <code class="code">Map.Tree</code>, the comparator must be passed to each operation.  The
    main advantages of trees over maps are slightly improved space usage (there is no
    outer container holding the comparator) and the ability to marshal trees, because a
    tree doesn't contain a closure, unlike a map.  The main disadvantages of using trees
    are needing to be more explicit about the comparator, and the possibility of
    accidental use of polymorphic equality on a tree (for which maps dynamically detect
    failure due to the presence of a closure in the data structure).<br/>    For a detailed explanation of the interface design, read on.<br/>    An instance of the map type is determined by the types of the map's keys and values,
    and the comparison function used to order the keys:<br/>    <pre class="codepre"><code class="code"> type ('key, 'value, 'cmp) Map.t </code></pre><br/>    <code class="code">'cmp</code> is a phantom type uniquely identifying the comparison function, as generated by
    <code class="code">Comparator.Make</code>.<br/>    <code class="code">Map.Poly</code> supports arbitrary key and value types, but enforces that the comparison
    function used to order the keys is polymorphic comparison.  <code class="code">Key.Map</code> has a fixed key
    type and comparison function, and supports arbitrary values.<br/>    <pre class="codepre"><code class="code">
      type ('key, 'value) Map.Poly.t = ('key , 'value, Comparator.Poly.t) Map.t
      type 'value Key.Map.t          = (Key.t, 'value, Key.comparator   ) Map.t
    </code></pre><br/>    The same map operations exist in <code class="code">Map</code>, <code class="code">Map.Poly</code>, and <code class="code">Key.Map</code>, albeit with
    different types.  For example:<br/>    <pre class="codepre"><code class="code">
      val Map.length      : (_, _, _) Map.t   -&gt; int
      val Map.Poly.length : (_, _) Map.Poly.t -&gt; int
      val Key.Map.length  : _ Key.Map.t       -&gt; int
    </code></pre><br/>    Because <code class="code">Map.Poly.t</code> and <code class="code">Key.Map.t</code> are exposed as instances of the more general
    <code class="code">Map.t</code> type, one can use <code class="code">Map.length</code> on any map.  The same is true for all of the
    functions that access an existing map, such as <code class="code">add</code>, <code class="code">change</code>, <code class="code">find</code>, <code class="code">fold</code>,
    <code class="code">iter</code>, <code class="code">map</code>, <code class="code">to_alist</code>, etc.<br/>    Depending on the number of type variables <code class="code">N</code>, the type of accessor (resp. creator)
    functions are defined in the module type <code class="code">AccessorsN</code> (resp. <code class="code">CreatorsN</code>) in
     <a href="#Core_map_intf">Core_map_intf</a>.  Also for creators, when the comparison function is not fixed,
    i.e. the <code class="code">'cmp</code> variable of <code class="code">Map.t</code> is free, we need to pass a comparator to the
    function creating the map.  The module type is called <code class="code">Creators3_with_comparator</code>.
    There is also a module type <code class="code">Accessors3_with_comparator</code> in addition to <code class="code">Accessors3</code>
    which used for trees since the comparator is not known.</div>
<div class="ocaml_module sig" name="Tree"><pre><span class="keyword">module</span> <a href="?package=core_kernel&amp;module=Core_map.Tree">Tree</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEt"><span class="keyword">type</span> <code class="type">('k, +'v, 'cmp) </code>t</span> </pre>
<div class="ocaml_include ident" path="?package=core_kernel&amp;module=Core_map_intf.Creators_and_accessors3_with_comparator" items="[]"><pre><span class="keyword">include</span> <code class="type"><code class="code"><a href="?package=core_kernel&amp;module=Core_map_intf.Creators_and_accessors3_with_comparator">Core_map_intf.Creators_and_accessors3_with_comparator</a></code> with type t := ('a, 'b, 'c) <a href="?package=core_kernel&amp;module=Core_map.Tree&amp;type=t">t</a> with type tree := ('a, 'b, 'c) <a href="?package=core_kernel&amp;module=Core_map.Tree&amp;type=t">t</a></code></pre></div>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type">('k -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a>) -&gt;
('v -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a>) -&gt;
('cmp -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a>) -&gt; ('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map.Tree&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre></div></div>
<pre><span class="TYPEt"><span class="keyword">type</span> <code class="type">('key, +'value, 'cmp) </code>t</span> </pre>
<pre><span class="VALinvariants"><span class="keyword">val</span> invariants</span> : <code class="type">('a, 'b, 'c) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; bool</code></pre><div class="info"><div class="info">Test if invariants of internal AVL search tree hold.</div></div>
<pre><span class="VALcomparator"><span class="keyword">val</span> comparator</span> : <code class="type">('a, 'b, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; ('a, 'cmp) <a href="?package=core_kernel&amp;module=Comparator&amp;type=t">Comparator.t</a></code></pre>
<pre><span class="VALempty"><span class="keyword">val</span> empty</span> : <code class="type">comparator:('a, 'cmp) <a href="?package=core_kernel&amp;module=Comparator&amp;type=t">Comparator.t</a> -&gt; ('a, 'b, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a></code></pre><div class="info"><div class="info">the empty map</div></div>
<pre><span class="VALsingleton"><span class="keyword">val</span> singleton</span> : <code class="type">comparator:('a, 'cmp) <a href="?package=core_kernel&amp;module=Comparator&amp;type=t">Comparator.t</a> -&gt; 'a -&gt; 'b -&gt; ('a, 'b, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a></code></pre><div class="info"><div class="info">map with one key, data pair</div></div>
<pre><span class="VALof_alist"><span class="keyword">val</span> of_alist</span> : <code class="type">comparator:('a, 'cmp) <a href="?package=core_kernel&amp;module=Comparator&amp;type=t">Comparator.t</a> -&gt;
('a * 'b) list -&gt; [ `Duplicate_key of 'a | `Ok of ('a, 'b, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> ]</code></pre><div class="info"><div class="info">creates map from association list with unique keys</div></div>
<pre><span class="VALof_alist_exn"><span class="keyword">val</span> of_alist_exn</span> : <code class="type">comparator:('a, 'cmp) <a href="?package=core_kernel&amp;module=Comparator&amp;type=t">Comparator.t</a> -&gt; ('a * 'b) list -&gt; ('a, 'b, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a></code></pre><div class="info"><div class="info">creates map from association list with unique keys.  Raises an exception if duplicate
    'a keys are found.</div></div>
<pre><span class="VALof_alist_multi"><span class="keyword">val</span> of_alist_multi</span> : <code class="type">comparator:('a, 'cmp) <a href="?package=core_kernel&amp;module=Comparator&amp;type=t">Comparator.t</a> -&gt; ('a * 'b) list -&gt; ('a, 'b list, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a></code></pre><div class="info"><div class="info">creates map from association list with possibly repeated keys.</div></div>
<pre><span class="VALof_alist_fold"><span class="keyword">val</span> of_alist_fold</span> : <code class="type">comparator:('a, 'cmp) <a href="?package=core_kernel&amp;module=Comparator&amp;type=t">Comparator.t</a> -&gt;
('a * 'b) list -&gt; init:'c -&gt; f:('c -&gt; 'b -&gt; 'c) -&gt; ('a, 'c, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a></code></pre><div class="info"><div class="info">combines an association list into a map, folding together bound values with common
    keys</div></div>
<pre><span class="VALto_tree"><span class="keyword">val</span> to_tree</span> : <code class="type">('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; ('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map.Tree&amp;type=t">Tree.t</a></code></pre>
<pre><span class="VALof_tree"><span class="keyword">val</span> of_tree</span> : <code class="type">comparator:('k, 'cmp) <a href="?package=core_kernel&amp;module=Comparator&amp;type=t">Comparator.t</a> -&gt;
('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map.Tree&amp;type=t">Tree.t</a> -&gt; ('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a></code></pre>
<pre><span class="VALof_sorted_array"><span class="keyword">val</span> of_sorted_array</span> : <code class="type">comparator:('a, 'cmp) <a href="?package=core_kernel&amp;module=Comparator&amp;type=t">Comparator.t</a> -&gt;
('a * 'b) array -&gt; ('a, 'b, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Or_error&amp;type=t">Or_error.t</a></code></pre><div class="info"><div class="info">creates map from sorted array of key-data pairs. The input array must be sorted, as
    given by the relevant comparator (either in ascending or descending order), and must
    not contain any duplicate keys.  If either of these conditions do not hold, an error
    is returned.</div></div>
<pre><span class="VALof_sorted_array_unchecked"><span class="keyword">val</span> of_sorted_array_unchecked</span> : <code class="type">comparator:('a, 'cmp) <a href="?package=core_kernel&amp;module=Comparator&amp;type=t">Comparator.t</a> -&gt; ('a * 'b) array -&gt; ('a, 'b, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a></code></pre><div class="info"><div class="info">Like <code class="code">of_sorted_array</code> except behavior is undefined when an <code class="code">Error</code> would have been
    returned.</div></div>
<pre><span class="VALis_empty"><span class="keyword">val</span> is_empty</span> : <code class="type">('a, 'b, 'c) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; bool</code></pre><div class="info"><div class="info">Test whether a map is empty or not.</div></div>
<pre><span class="VALlength"><span class="keyword">val</span> length</span> : <code class="type">('a, 'b, 'c) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">length map</code> <b>Returns</b> number of elements in <code class="code">map</code>.</div></div>
<pre><span class="VALadd"><span class="keyword">val</span> add</span> : <code class="type">('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; key:'k -&gt; data:'v -&gt; ('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a></code></pre><div class="info"><div class="info">returns a new map with the specified new binding;
    if the key was already bound, its previous binding disappears.</div></div>
<pre><span class="VALadd_multi"><span class="keyword">val</span> add_multi</span> : <code class="type">('k, 'v list, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; key:'k -&gt; data:'v -&gt; ('k, 'v list, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a></code></pre><div class="info"><div class="info">if key is not present then add a singleton list, otherwise, cons data on the head of
    the existing list.</div></div>
<pre><span class="VALchange"><span class="keyword">val</span> change</span> : <code class="type">('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; 'k -&gt; ('v option -&gt; 'v option) -&gt; ('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a></code></pre><div class="info"><div class="info"><code class="code">change map key f</code> updates the given map by changing the value stored under <code class="code">key</code>
    according to <code class="code">f</code>.  Thus, for example, one might write:<br/>    <pre class="codepre"><code class="code">change m k (function None -&gt; Some 0 | Some x -&gt; Some (x + 1))</code></pre><br/>    to produce a new map where the integer stored under key <code class="code">k</code> is incremented by one
    (treating an unknown key as zero).</div></div>
<pre><span class="VALfind"><span class="keyword">val</span> find</span> : <code class="type">('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; 'k -&gt; 'v option</code></pre><div class="info"><div class="info">returns the value bound to the given key, raising <code class="code">Not_found</code> if none such exists</div></div>
<pre><span class="VALfind_exn"><span class="keyword">val</span> find_exn</span> : <code class="type">('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; 'k -&gt; 'v</code></pre>
<pre><span class="VALremove"><span class="keyword">val</span> remove</span> : <code class="type">('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; 'k -&gt; ('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a></code></pre><div class="info"><div class="info">returns a new map with any binding for the key in question removed</div></div>
<pre><span class="VALmem"><span class="keyword">val</span> mem</span> : <code class="type">('k, 'a, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; 'k -&gt; bool</code></pre><div class="info"><div class="info"><code class="code">mem map key</code> tests whether <code class="code">map</code> contains a binding for <code class="code">key</code></div></div>
<pre><span class="VALiter"><span class="keyword">val</span> iter</span> : <code class="type">('k, 'v, 'a) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; f:(key:'k -&gt; data:'v -&gt; unit) -&gt; unit</code></pre><div class="info"><div class="info">iterator for map</div></div>
<pre><span class="VALiter2"><span class="keyword">val</span> iter2</span> : <code class="type">('k, 'v1, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt;
('k, 'v2, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt;
f:(key:'k -&gt;
   data:[ `Both of 'v1 * 'v2 | `Left of 'v1 | `Right of 'v2 ] -&gt; unit) -&gt;
unit</code></pre><div class="info"><div class="info">Iterate two maps side by side.  Complexity of this function is O(M+N).  If two inputs
    are <code class="code">(0, a); (1, a)</code> and <code class="code">(1, b); (2, b)</code>, <code class="code">f</code> will be called with <code class="code">(0, `Left a); (1,
    `Both (a, b)); (2, `Right b)</code></div></div>
<pre><span class="VALmap"><span class="keyword">val</span> map</span> : <code class="type">('k, 'v1, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; f:('v1 -&gt; 'v2) -&gt; ('k, 'v2, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a></code></pre><div class="info"><div class="info">returns new map with bound values replaced by f applied to the bound values</div></div>
<pre><span class="VALmapi"><span class="keyword">val</span> mapi</span> : <code class="type">('k, 'v1, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; f:(key:'k -&gt; data:'v1 -&gt; 'v2) -&gt; ('k, 'v2, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a></code></pre><div class="info"><div class="info">like <code class="code">map</code>, but function takes both key and data as arguments</div></div>
<pre><span class="VALfold"><span class="keyword">val</span> fold</span> : <code class="type">('k, 'v, 'b) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; init:'a -&gt; f:(key:'k -&gt; data:'v -&gt; 'a -&gt; 'a) -&gt; 'a</code></pre><div class="info"><div class="info">folds over keys and data in map in increasing order of key.</div></div>
<pre><span class="VALfold_right"><span class="keyword">val</span> fold_right</span> : <code class="type">('k, 'v, 'b) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; init:'a -&gt; f:(key:'k -&gt; data:'v -&gt; 'a -&gt; 'a) -&gt; 'a</code></pre><div class="info"><div class="info">folds over keys and data in map in decreasing order of key.</div></div>
<pre><span class="VALfilter"><span class="keyword">val</span> filter</span> : <code class="type">('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; f:(key:'k -&gt; data:'v -&gt; bool) -&gt; ('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a></code></pre>
<pre><span class="VALfilter_map"><span class="keyword">val</span> filter_map</span> : <code class="type">('k, 'v1, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; f:('v1 -&gt; 'v2 option) -&gt; ('k, 'v2, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a></code></pre><div class="info"><div class="info">returns new map with bound values filtered by f applied to the bound values</div></div>
<pre><span class="VALfilter_mapi"><span class="keyword">val</span> filter_mapi</span> : <code class="type">('k, 'v1, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt;
f:(key:'k -&gt; data:'v1 -&gt; 'v2 option) -&gt; ('k, 'v2, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a></code></pre><div class="info"><div class="info">like <code class="code">filter_map</code>, but function takes both key and data as arguments</div></div>
<pre><span class="VALcompare_direct"><span class="keyword">val</span> compare_direct</span> : <code class="type">('v -&gt; 'v -&gt; int) -&gt; ('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; ('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info">Total ordering between maps.  The first argument is a total ordering used to compare
    data associated with equal keys in the two maps.</div></div>
<pre><span class="VALequal"><span class="keyword">val</span> equal</span> : <code class="type">('v -&gt; 'v -&gt; bool) -&gt; ('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; ('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; bool</code></pre><div class="info"><div class="info"><code class="code">equal cmp m1 m2</code> tests whether the maps <code class="code">m1</code> and <code class="code">m2</code> are equal, that is, contain
    equal keys and associate them with equal data.  <code class="code">cmp</code> is the equality predicate used
    to compare the data associated with the keys.</div></div>
<pre><span class="VALkeys"><span class="keyword">val</span> keys</span> : <code class="type">('k, 'a, 'b) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; 'k list</code></pre><div class="info"><div class="info">returns list of keys in map</div></div>
<pre><span class="VALdata"><span class="keyword">val</span> data</span> : <code class="type">('a, 'v, 'b) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; 'v list</code></pre><div class="info"><div class="info">returns list of data in map</div></div>
<pre><span class="VALto_alist"><span class="keyword">val</span> to_alist</span> : <code class="type">('k, 'v, 'a) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; ('k * 'v) list</code></pre><div class="info"><div class="info">creates association list from map.  No guarantee about order.</div></div>
<pre><span class="VALvalidate"><span class="keyword">val</span> validate</span> : <code class="type">name:('k -&gt; string) -&gt; 'v <a href="?package=core_kernel&amp;module=Validate&amp;type=check">Validate.check</a> -&gt; ('k, 'v, 'a) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> <a href="?package=core_kernel&amp;module=Validate&amp;type=check">Validate.check</a></code></pre>
<div class="info"><div class="info"><h6 id="6_TITLE">Additional operations on maps</h6></div></div>
<pre><span class="VALmerge"><span class="keyword">val</span> merge</span> : <code class="type">('k, 'v1, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt;
('k, 'v2, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt;
f:(key:'k -&gt;
   [ `Both of 'v1 * 'v2 | `Left of 'v1 | `Right of 'v2 ] -&gt; 'v3 option) -&gt;
('k, 'v3, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a></code></pre><div class="info"><div class="info">merges two maps</div></div>
<pre><span class="VALsymmetric_diff"><span class="keyword">val</span> symmetric_diff</span> : <code class="type">('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt;
('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt;
data_equal:('v -&gt; 'v -&gt; bool) -&gt;
('k * [ `Left of 'v | `Right of 'v | `Unequal of 'v * 'v ]) list</code></pre><div class="info"><div class="info"><code class="code">symmetric_diff t1 t2 ~data_equal</code> returns a list of changes between <code class="code">t1</code> and <code class="code">t2</code>.
    It is intended to be efficient in the case where <code class="code">t1</code> and <code class="code">t2</code> share a large amount of
    structure.</div></div>
<pre><span class="VALmin_elt"><span class="keyword">val</span> min_elt</span> : <code class="type">('k, 'v, 'a) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; ('k * 'v) option</code></pre><div class="info"><div class="info"><code class="code">min_elt map</code> <b>Returns</b> Some <code class="code">(key, data)</code> pair corresponding to the minimum key in
    <code class="code">map</code>, None if empty.</div></div>
<pre><span class="VALmin_elt_exn"><span class="keyword">val</span> min_elt_exn</span> : <code class="type">('k, 'v, 'a) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; 'k * 'v</code></pre>
<pre><span class="VALmax_elt"><span class="keyword">val</span> max_elt</span> : <code class="type">('k, 'v, 'a) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; ('k * 'v) option</code></pre><div class="info"><div class="info"><code class="code">max_elt map</code> <b>Returns</b> Some <code class="code">(key, data)</code> pair corresponding to the maximum key in
    <code class="code">map</code>, and None if <code class="code">map</code> is empty.</div></div>
<pre><span class="VALmax_elt_exn"><span class="keyword">val</span> max_elt_exn</span> : <code class="type">('k, 'v, 'a) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; 'k * 'v</code></pre>
<pre><span class="VALfor_all"><span class="keyword">val</span> for_all</span> : <code class="type">('k, 'v, 'a) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; f:('v -&gt; bool) -&gt; bool</code></pre><div class="info"><div class="info">same semantics as similar functions in List</div></div>
<pre><span class="VALexists"><span class="keyword">val</span> exists</span> : <code class="type">('k, 'v, 'a) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; f:('v -&gt; bool) -&gt; bool</code></pre>
<pre><span class="VALfold_range_inclusive"><span class="keyword">val</span> fold_range_inclusive</span> : <code class="type">('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt;
min:'k -&gt; max:'k -&gt; init:'a -&gt; f:(key:'k -&gt; data:'v -&gt; 'a -&gt; 'a) -&gt; 'a</code></pre><div class="info"><div class="info"><code class="code">fold_range_inclusive t ~min ~max ~init ~f</code>
    folds f (with initial value ~init) over all keys (and their associated values)
    that are in the range <code class="code">min, max</code> (inclusive).</div></div>
<pre><span class="VALrange_to_alist"><span class="keyword">val</span> range_to_alist</span> : <code class="type">('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; min:'k -&gt; max:'k -&gt; ('k * 'v) list</code></pre><div class="info"><div class="info"><code class="code">range_to_alist t ~min ~max</code> returns an associative list of the elements whose
    keys lie in <code class="code">min, max</code> (inclusive), with the smallest key being at the head of the
    list.</div></div>
<pre><span class="VALprev_key"><span class="keyword">val</span> prev_key</span> : <code class="type">('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; 'k -&gt; ('k * 'v) option</code></pre><div class="info"><div class="info"><code class="code">prev_key t k</code> returns the largest (key, value) pair in t with key less than k</div></div>
<pre><span class="VALnext_key"><span class="keyword">val</span> next_key</span> : <code class="type">('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; 'k -&gt; ('k * 'v) option</code></pre><div class="info"><div class="info"><code class="code">next_key t k</code> returns the smallest (key, value) pair in t with key greater than k</div></div>
<pre><span class="VALrank"><span class="keyword">val</span> rank</span> : <code class="type">('k, 'v, 'cmp) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> -&gt; 'k -&gt; int option</code></pre><div class="info"><div class="info"><code class="code">rank t k</code> if k is in t, returns the number of keys strictly less than k in t,
    otherwise None</div></div>
<div class="ocaml_module sig" name="Poly"><pre><span class="keyword">module</span> <a href="?package=core_kernel&amp;module=Core_map.Poly">Poly</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code> with type <a href="?package=core_kernel&amp;module=Core_map.Poly&amp;type=map">map</a> = ('a, 'b, 'c) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEmap"><span class="keyword">type</span> <code class="type">('a, +'b, 'c) </code>map</span> </pre>
<div class="ocaml_module sig" name="Tree"><pre><span class="keyword">module</span> <a href="?package=core_kernel&amp;module=Core_map.Poly.Tree">Tree</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><span class="TYPEt"><span class="keyword">type</span> <code class="type">('k, +'v) </code>t</span> = <code class="type">('k, 'v, <a href="?package=core_kernel&amp;module=Comparator.Poly&amp;type=comparator">Comparator.Poly.comparator</a>) <a href="?package=core_kernel&amp;module=Core_map.Tree&amp;type=t">Tree.t</a></code></pre>
<div class="ocaml_include ident" path="?package=core_kernel&amp;module=Core_map_intf.Creators_and_accessors2" items="[]"><pre><span class="keyword">include</span> <code class="type"><code class="code"><a href="?package=core_kernel&amp;module=Core_map_intf.Creators_and_accessors2">Core_map_intf.Creators_and_accessors2</a></code> with type t := ('a, 'b) <a href="?package=core_kernel&amp;module=Core_map.Poly.Tree&amp;type=t">t</a> with type tree := ('a, 'b) <a href="?package=core_kernel&amp;module=Core_map.Poly.Tree&amp;type=t">t</a></code></pre></div>
<pre><span class="VALt_of_sexp"><span class="keyword">val</span> t_of_sexp</span> : <code class="type">(<a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a> -&gt; 'k) -&gt;
(<a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a> -&gt; 'v) -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a> -&gt; ('k, 'v) <a href="?package=core_kernel&amp;module=Core_map.Poly.Tree&amp;type=t">t</a></code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type">('k -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a>) -&gt;
('v -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a>) -&gt; ('k, 'v) <a href="?package=core_kernel&amp;module=Core_map.Poly.Tree&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre></div></div>
<pre><span class="TYPEt"><span class="keyword">type</span> <code class="type">('a, +'b) </code>t</span> = <code class="type">('a, 'b, <a href="?package=core_kernel&amp;module=Comparator.Poly&amp;type=comparator">Comparator.Poly.comparator</a>) <a href="?package=core_kernel&amp;module=Core_map.Poly&amp;type=map">map</a></code></pre>
<div class="ocaml_include ident" path="?package=core_kernel&amp;module=Core_map_intf.Creators_and_accessors2" items="[]"><pre><span class="keyword">include</span> <code class="type"><code class="code"><a href="?package=core_kernel&amp;module=Core_map_intf.Creators_and_accessors2">Core_map_intf.Creators_and_accessors2</a></code> with type t := ('a, 'b) <a href="?package=core_kernel&amp;module=Core_map.Poly&amp;type=t">t</a> with type tree := ('a, 'b) <a href="?package=core_kernel&amp;module=Core_map.Poly.Tree&amp;type=t">Tree.t</a></code></pre></div>
<pre><span class="VALcompare"><span class="keyword">val</span> compare</span> : <code class="type">('a -&gt; 'a -&gt; int) -&gt; ('b -&gt; 'b -&gt; int) -&gt; ('a, 'b) <a href="?package=core_kernel&amp;module=Core_map.Poly&amp;type=t">t</a> -&gt; ('a, 'b) <a href="?package=core_kernel&amp;module=Core_map.Poly&amp;type=t">t</a> -&gt; int</code></pre>
<pre><span class="VALt_of_sexp"><span class="keyword">val</span> t_of_sexp</span> : <code class="type">(<a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a> -&gt; 'a) -&gt;
(<a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a> -&gt; 'b) -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a> -&gt; ('a, 'b) <a href="?package=core_kernel&amp;module=Core_map.Poly&amp;type=t">t</a></code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type">('a -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a>) -&gt;
('b -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a>) -&gt; ('a, 'b) <a href="?package=core_kernel&amp;module=Core_map.Poly&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre>
<pre><span class="VALbin_t"><span class="keyword">val</span> bin_t</span> : <code class="type">'a <a href="?package=bin_prot&amp;module=Type_class&amp;type=t">Bin_prot.Type_class.t</a> -&gt;
'b <a href="?package=bin_prot&amp;module=Type_class&amp;type=t">Bin_prot.Type_class.t</a> -&gt; ('a, 'b) <a href="?package=core_kernel&amp;module=Core_map.Poly&amp;type=t">t</a> <a href="?package=bin_prot&amp;module=Type_class&amp;type=t">Bin_prot.Type_class.t</a></code></pre>
<pre><span class="VALbin_read_t"><span class="keyword">val</span> bin_read_t</span> : <code class="type">'a <a href="?package=bin_prot&amp;module=Unsafe_read_c&amp;type=reader">Bin_prot.Unsafe_read_c.reader</a> -&gt;
'b <a href="?package=bin_prot&amp;module=Unsafe_read_c&amp;type=reader">Bin_prot.Unsafe_read_c.reader</a> -&gt; ('a, 'b) <a href="?package=core_kernel&amp;module=Core_map.Poly&amp;type=t">t</a> <a href="?package=bin_prot&amp;module=Read_ml&amp;type=reader">Bin_prot.Read_ml.reader</a></code></pre>
<pre><span class="VALbin_read_t_"><span class="keyword">val</span> bin_read_t_</span> : <code class="type">'a <a href="?package=bin_prot&amp;module=Unsafe_read_c&amp;type=reader">Bin_prot.Unsafe_read_c.reader</a> -&gt;
'b <a href="?package=bin_prot&amp;module=Unsafe_read_c&amp;type=reader">Bin_prot.Unsafe_read_c.reader</a> -&gt; ('a, 'b) <a href="?package=core_kernel&amp;module=Core_map.Poly&amp;type=t">t</a> <a href="?package=bin_prot&amp;module=Unsafe_read_c&amp;type=reader">Bin_prot.Unsafe_read_c.reader</a></code></pre>
<pre><span class="VALbin_read_t__"><span class="keyword">val</span> bin_read_t__</span> : <code class="type">'a <a href="?package=bin_prot&amp;module=Unsafe_read_c&amp;type=reader">Bin_prot.Unsafe_read_c.reader</a> -&gt;
'b <a href="?package=bin_prot&amp;module=Unsafe_read_c&amp;type=reader">Bin_prot.Unsafe_read_c.reader</a> -&gt;
(int -&gt; ('a, 'b) <a href="?package=core_kernel&amp;module=Core_map.Poly&amp;type=t">t</a>) <a href="?package=bin_prot&amp;module=Unsafe_read_c&amp;type=reader">Bin_prot.Unsafe_read_c.reader</a></code></pre>
<pre><span class="VALbin_reader_t"><span class="keyword">val</span> bin_reader_t</span> : <code class="type">'a <a href="?package=bin_prot&amp;module=Type_class&amp;type=reader">Bin_prot.Type_class.reader</a> -&gt;
'b <a href="?package=bin_prot&amp;module=Type_class&amp;type=reader">Bin_prot.Type_class.reader</a> -&gt; ('a, 'b) <a href="?package=core_kernel&amp;module=Core_map.Poly&amp;type=t">t</a> <a href="?package=bin_prot&amp;module=Type_class&amp;type=reader">Bin_prot.Type_class.reader</a></code></pre>
<pre><span class="VALbin_size_t"><span class="keyword">val</span> bin_size_t</span> : <code class="type">'a <a href="?package=bin_prot&amp;module=Size&amp;type=sizer">Bin_prot.Size.sizer</a> -&gt;
'b <a href="?package=bin_prot&amp;module=Size&amp;type=sizer">Bin_prot.Size.sizer</a> -&gt; ('a, 'b) <a href="?package=core_kernel&amp;module=Core_map.Poly&amp;type=t">t</a> <a href="?package=bin_prot&amp;module=Size&amp;type=sizer">Bin_prot.Size.sizer</a></code></pre>
<pre><span class="VALbin_write_t"><span class="keyword">val</span> bin_write_t</span> : <code class="type">'a <a href="?package=bin_prot&amp;module=Unsafe_write_c&amp;type=writer">Bin_prot.Unsafe_write_c.writer</a> -&gt;
'b <a href="?package=bin_prot&amp;module=Unsafe_write_c&amp;type=writer">Bin_prot.Unsafe_write_c.writer</a> -&gt; ('a, 'b) <a href="?package=core_kernel&amp;module=Core_map.Poly&amp;type=t">t</a> <a href="?package=bin_prot&amp;module=Write_ml&amp;type=writer">Bin_prot.Write_ml.writer</a></code></pre>
<pre><span class="VALbin_write_t_"><span class="keyword">val</span> bin_write_t_</span> : <code class="type">'a <a href="?package=bin_prot&amp;module=Unsafe_write_c&amp;type=writer">Bin_prot.Unsafe_write_c.writer</a> -&gt;
'b <a href="?package=bin_prot&amp;module=Unsafe_write_c&amp;type=writer">Bin_prot.Unsafe_write_c.writer</a> -&gt;
('a, 'b) <a href="?package=core_kernel&amp;module=Core_map.Poly&amp;type=t">t</a> <a href="?package=bin_prot&amp;module=Unsafe_write_c&amp;type=writer">Bin_prot.Unsafe_write_c.writer</a></code></pre>
<pre><span class="VALbin_writer_t"><span class="keyword">val</span> bin_writer_t</span> : <code class="type">'a <a href="?package=bin_prot&amp;module=Type_class&amp;type=writer">Bin_prot.Type_class.writer</a> -&gt;
'b <a href="?package=bin_prot&amp;module=Type_class&amp;type=writer">Bin_prot.Type_class.writer</a> -&gt; ('a, 'b) <a href="?package=core_kernel&amp;module=Core_map.Poly&amp;type=t">t</a> <a href="?package=bin_prot&amp;module=Type_class&amp;type=writer">Bin_prot.Type_class.writer</a></code></pre></div></div>
<div class="ocaml_module ident" name="Key" path="?package=core_kernel&amp;module=Core_map_intf.Key"><pre><span class="keyword">module type</span> <a href="?package=core_kernel&amp;module=Core_map.Key">Key</a> = <code class="type"><code class="code"><a href="?package=core_kernel&amp;module=Core_map_intf.Key">Core_map_intf.Key</a></code></code></pre></div>
<div class="ocaml_module ident" name="Key_binable" path="?package=core_kernel&amp;module=Core_map_intf.Key_binable"><pre><span class="keyword">module type</span> <a href="?package=core_kernel&amp;module=Core_map.Key_binable">Key_binable</a> = <code class="type"><code class="code"><a href="?package=core_kernel&amp;module=Core_map_intf.Key_binable">Core_map_intf.Key_binable</a></code></code></pre></div>
<div class="ocaml_module ident" name="S" path="?package=core_kernel&amp;module=Core_map_intf.S"><pre><span class="keyword">module type</span> <a href="?package=core_kernel&amp;module=Core_map.S">S</a> = <code class="type"><code class="code"><a href="?package=core_kernel&amp;module=Core_map_intf.S">Core_map_intf.S</a></code> with type map := ('a, 'b, 'c) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> with type tree := ('a, 'b, 'c) <a href="?package=core_kernel&amp;module=Core_map.Tree&amp;type=t">Tree.t</a></code></pre></div>
<div class="ocaml_module ident" name="S_binable" path="?package=core_kernel&amp;module=Core_map_intf.S_binable"><pre><span class="keyword">module type</span> <a href="?package=core_kernel&amp;module=Core_map.S_binable">S_binable</a> = <code class="type"><code class="code"><a href="?package=core_kernel&amp;module=Core_map_intf.S_binable">Core_map_intf.S_binable</a></code> with type map := ('a, 'b, 'c) <a href="?package=core_kernel&amp;module=Core_map&amp;type=t">t</a> with type tree := ('a, 'b, 'c) <a href="?package=core_kernel&amp;module=Core_map.Tree&amp;type=t">Tree.t</a></code></pre></div>
<div class="ocaml_module ident" name="Make" path="?package=core_kernel&amp;module=Core_map.S"><pre><span class="keyword">module</span> <a href="?package=core_kernel&amp;module=Core_map.Make">Make</a> : <code class="type"><div class="sig_block"><code class="code">functor (</code><code class="code">Key</code><code class="code"> : </code><code class="code"><a href="?package=core_kernel&amp;module=Core_map.Key">Key</a></code><code class="code">) -&gt; </code><code class="code"><a href="?package=core_kernel&amp;module=Core_map.S">S</a></code> with type Key.t = Key.t</div></code></pre></div>
<div class="ocaml_module ident" name="Make_using_comparator" path="?package=core_kernel&amp;module=Core_map.S"><pre><span class="keyword">module</span> <a href="?package=core_kernel&amp;module=Core_map.Make_using_comparator">Make_using_comparator</a> : <code class="type"><div class="sig_block"><code class="code">functor (</code><code class="code">Key</code><code class="code"> : </code><code class="code"><a href="?package=core_kernel&amp;module=Comparator.S">Comparator.S</a></code><code class="code">) -&gt; </code><code class="code"><a href="?package=core_kernel&amp;module=Core_map.S">S</a></code> with type Key.t = Key.t with type Key.comparator = Key.comparator</div></code></pre></div>
<div class="ocaml_module ident" name="Make_binable" path="?package=core_kernel&amp;module=Core_map.S_binable"><pre><span class="keyword">module</span> <a href="?package=core_kernel&amp;module=Core_map.Make_binable">Make_binable</a> : <code class="type"><div class="sig_block"><code class="code">functor (</code><code class="code">Key</code><code class="code"> : </code><code class="code"><a href="?package=core_kernel&amp;module=Core_map.Key_binable">Key_binable</a></code><code class="code">) -&gt; </code><code class="code"><a href="?package=core_kernel&amp;module=Core_map.S_binable">S_binable</a></code> with type Key.t = Key.t</div></code></pre></div>
<div class="ocaml_module ident" name="Make_binable_using_comparator" path="?package=core_kernel&amp;module=Core_map.S_binable"><pre><span class="keyword">module</span> <a href="?package=core_kernel&amp;module=Core_map.Make_binable_using_comparator">Make_binable_using_comparator</a> : <code class="type"><div class="sig_block"><code class="code">functor (</code><code class="code">Key</code><code class="code"> : </code><code class="code"><a href="?package=core_kernel&amp;module=Comparator.S_binable">Comparator.S_binable</a></code><code class="code">) -&gt; </code><code class="code"><a href="?package=core_kernel&amp;module=Core_map.S_binable">S_binable</a></code> with type Key.t = Key.t with type Key.comparator = Key.comparator</div></code></pre></div>
</div>