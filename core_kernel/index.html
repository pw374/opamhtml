<h1>Modules</h1>
<table class="indextable">
    <tr><td class="module"><a href="?package=core_kernel&amp;module=Array_permute">Array_permute</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Avltree">Avltree</a></td><td><div class="info">This module implements a very low level interface to a mutable AVL tree. It is not
    intended to be used directly by casual users. It is used for implementing other data
    structures. The interface is somewhat ugly, and it's that way for a reason. The goal
    of this module is minimum memory overhead, and maximum performance.<br/>**************** Points of Ugliness *****************<br/> compare is passed in to every function where it is used. If you pass a different
    compare to functions on the same tree, then all bets are off as far as what it does,
    and it's all your fault. Why? Because otherwise we'd need a top level record to store
    compare, and when building a hash table, or other structure, that little t is a block
    that increases memory overhead. However, if an empty tree is just a constructor
    'Empty', then it's just a number, and uses no extra memory beyond the array bucket
    that holds it. That's the first secret of how Core_hashtbl's memory overhead isn't
    higher than INRIA's, even though it uses a tree instead of a list for buckets.<br/> But you said it's mutable, why do all the 'mutators' return t. Answer, it is
    mutable, but the root node might change due to balancing. Since we have no top level
    record to hold the current root node (see point 1), you have to do it. If you fail to
    do it, and use an old root node, you're responsible for the (sure to be nasty)
    consequences.<br/> What on earth is up with the ~removed argument to some functions. See point 1, since
    there is no top level node, it isn't possible to keep track of how many nodes are in
    the tree unless each mutator tells you whether or not it added or removed a node, vs
    replacing an existing one. If you intend to keep a count (as you must in a hash
    table), then you will need to pay attention to this flag.<br/>    After all this, you're probably asking yourself whether all these hacks are worth
    it. Yes! They are! With them, we built a hash table that is faster than INRIA's (no
    small feat actually), with the same memory overhead, with sane add semantics (the add
    semantics they used were a performance hack), and with worst case log(N) insertion,
    lookup, and removal. I'd say that's worth it. But for those of you who will feel
    morally compelled to put in a CR about this interface. I challenge you to write a
    better interface, implement a hash table with it, and show that your table has better
    performance than Core_hashtbl.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Bag">Bag</a></td><td><div class="info">Imperative set-like data structure.<br/>    Primary differences from a simple set:<br/>    - It doesn't require anything (hashable, comparable) of elements in the bag.<ul><li>Duplicates are allowed.</li><li>Addition and removal are constant time.</li></ul>    It is an error to modify a bag (<code class="code">add</code>, <code class="code">remove</code>, <code class="code">remove_one</code>, ...) during iteration
    (<code class="code">fold</code>, <code class="code">iter</code>, ...).</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Bigbuffer">Bigbuffer</a></td><td><div class="info">Extensible string buffers based on Bigstrings.<br/>   This module implements string buffers that automatically expand as necessary.  It
   provides accumulative concatenation of strings in quasi-linear time (instead of
   quadratic time when strings are concatenated pairwise).<br/>   This implementation uses Bigstrings instead of strings.  This removes the 16MB limit on
   buffer size, and improves I/O-performance when reading/writing from/to channels.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Bigbuffer_internal">Bigbuffer_internal</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Bigstring">Bigstring</a></td><td><div class="info">String type based on <code class="code">Bigarray</code>, for use in I/O and C-bindings</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Bigstring_marshal">Bigstring_marshal</a></td><td><div class="info">Utility functions for marshalling to and from bigstring<div class="authors"><b>Author(s): </b><span class="author">Markus Mottl &lt;mmottl@janestreet.com&gt;</span></div></div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Bigsubstring">Bigsubstring</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Binable">Binable</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Binable0">Binable0</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Binary_packing">Binary_packing</a></td><td><div class="info">Packs and unpacks various types of integers into and from strings.<br/>   Functions ending in _int should not be used on 32 bit programs because native ocaml
   ints will not be big enough.<br/>   <code class="code">pos</code> arguments refer to the location in the buf string.<br/>   We support big and little endian ints.  Note that for an 8 bit (1 byte) integer, there
   is no difference because endian-ness only changes the order of bytes, not bits.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Blang">Blang</a></td><td><div class="info">A simple boolean domain-specific language</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Blit">Blit</a></td><td><div class="info">See  <a href="#Blit_intf">Blit_intf</a> for documentation.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Blit_intf">Blit_intf</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Bool">Bool</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Bounded_int_table">Bounded_int_table</a></td><td><div class="info">A <code class="code">Bounded_int_table</code> is a table whose keys can be mapped to integers in a fixed
    range, 0 ... num_keys-1, where <code class="code">num_keys</code> is specified at table-creation time.  The
    purpose of <code class="code">Bounded_int_table</code> is to be faster than <code class="code">Hashtbl</code> in situations where one
    is willing to pay a space cost for the speed.<br/>    <code class="code">Bounded_int_table</code> presents a subset of the <code class="code">Hashtbl</code> interface.  The key type can be
    any type, but table creation requires a <code class="code">key_to_int</code> function, which will be used
    to extract the integer of all keys.  If multiple keys map to the same integer, then
    only one of them can be in the table at a time.  Any operation that supplies a key
    whose corresponding integer is outside the allowed range for the table will cause an
    exception.<br/>    A <code class="code">Bounded_int_table</code> is implemented using two fixed size arrays of size <code class="code">num_keys</code>,
    which is supplied at table-creation time.  The space used does not depend on the
    <code class="code">length</code> of the table but rather only on <code class="code">num_keys</code>.  Operations that deal with a
    single element (find, mem, add, remove, set) take constant time, and perform one or
    two array operations.  Operations that deal with all of the keys defined in the table
    (data, fold, iter, iter_vals, keys, to_alist) take time proportional to the <code class="code">length</code>
    of the table, not <code class="code">num_keys</code>.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Bucket">Bucket</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Byte_units">Byte_units</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Caml">Caml</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Common">Common</a></td><td><div class="info">Basic types and definitions required throughout the system.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Commutative_group">Commutative_group</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Comparable">Comparable</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Comparable_intf">Comparable_intf</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Comparator">Comparator</a></td><td><div class="info">A Comparator.t is a type-indexed value that allows you to compare (and for generating
    error messages, serialize) values of the type in question.  One of the type parameters
    is a phantom parameter used to distinguish comparators potentially built on different
    comparison functions.  In particular, we want to distinguish those using polymorphic
    compare and those using a monomorphic compare.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Constrained_float">Constrained_float</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Container">Container</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Container_unit_tests">Container_unit_tests</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_arg">Core_arg</a></td><td><div class="info">Parsing of command line arguments.<br/>   This module provides a general mechanism for extracting options and
   arguments from the command line to the program.<br/>   Syntax of command lines:
    A keyword is a character string starting with a <code class="code">-</code>.
    An option is a keyword alone or followed by an argument.
    The types of keywords are: <code class="code">Unit</code>, <code class="code">Bool</code>, <code class="code">Set</code>, <code class="code">Clear</code>,
    <code class="code">String</code>, <code class="code">Set_string</code>, <code class="code">Int</code>, <code class="code">Set_int</code>, <code class="code">Float</code>, <code class="code">Set_float</code>,
    <code class="code">Tuple</code>, <code class="code">Symbol</code>, and <code class="code">Rest</code>.
    <code class="code">Unit</code>, <code class="code">Set</code> and <code class="code">Clear</code> keywords take no argument. A <code class="code">Rest</code>
    keyword takes the remainder of the command line as arguments.
    Every other keyword takes the following word on the command line
    as argument.
    Arguments not preceded by a keyword are called anonymous arguments.<br/>   Examples (<code class="code">cmd</code> is assumed to be the command name):<ul><li>  <code class="code">cmd -flag           </code>(a unit option)</li><li>  <code class="code">cmd -int 1          </code>(an int option with argument <code class="code">1</code>)</li><li>  <code class="code">cmd -string foobar  </code>(a string option with argument <code class="code">&quot;foobar&quot;</code>)</li><li>  <code class="code">cmd -float 12.34    </code>(a float option with argument <code class="code">12.34</code>)</li><li>  <code class="code">cmd a b c           </code>(three anonymous arguments: <code class="code">&quot;a&quot;</code>, <code class="code">&quot;b&quot;</code>, and <code class="code">&quot;c&quot;</code>)</li><li>  <code class="code">cmd a b -- c d      </code>(two anonymous arguments and a rest option with
                           two arguments)
</li></ul></div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_array">Core_array</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_bin_prot">Core_bin_prot</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_char">Core_char</a></td><td><div class="info">Character operations.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_field">Core_field</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_gc">Core_gc</a></td><td><div class="info">Memory management control and statistics; finalised values.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_hashtbl">Core_hashtbl</a></td><td><div class="info">For many students of ocaml, using hashtables is complicated by the
    functors.  Here are a few tips:</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_hashtbl_intf">Core_hashtbl_intf</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_int">Core_int</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_int32">Core_int32</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_int63">Core_int63</a></td><td><div class="info">The size of Int63 is always at least 63 bits.  On a 64-bit platform it is just an int
    (63-bits), and on a 32-bit platform it is an int64.<br/>    Because Int63 has different sizes on 32-bit and 64-bit platforms, there are several
    pitfalls to be aware of:<br/>    - Int63 will behave differently in the case of overflow.<br/>    - marshalling Int63 will not work between 32-bit and 64-bit platforms.
    unmarshal will segfault.<br/>    - bin_io will work, except that it will raise an overflow exception when you send too
      large of an int from a 32-bit to a 64-bit platform.  This is couterintuitive because
      the 32-bit platform has the larger int size.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_int64">Core_int64</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_lazy">Core_lazy</a></td><td><div class="info">A value of type <code class="code">'a Lazy.t</code> is a deferred computation, called
   a suspension, that has a result of type <code class="code">'a</code>.  The special
   expression syntax <code class="code">lazy (expr)</code> makes a suspension of the
   computation of <code class="code">expr</code>, without computing <code class="code">expr</code> itself yet.
   &quot;Forcing&quot; the suspension will then compute <code class="code">expr</code> and return its
   result.<br/>   Note: <code class="code">lazy_t</code> is the built-in type constructor used by the compiler
   for the <code class="code">lazy</code> keyword.  You should not use it directly.  Always use
   <code class="code">Lazy.t</code> instead.<br/>   Note: <code class="code">Lazy.force</code> is not thread-safe.  If you use this module in
   a multi-threaded program, you will need to add some locks.<br/>   Note: if the program is compiled with the <code class="code">-rectypes</code> option,
   ill-founded recursive definitions of the form <code class="code">let rec x = lazy x</code>
   or <code class="code">let rec x = lazy(lazy(...(lazy x)))</code> are accepted by the type-checker
   and lead, when forced, to ill-formed values that trigger infinite
   loops in the garbage collector and other parts of the run-time system.
   Without the <code class="code">-rectypes</code> option, such ill-founded recursive definitions
   are rejected by the type-checker.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_list">Core_list</a></td><td><div class="info">Tail recursive version of standard List functions, plus additional operations.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_map">Core_map</a></td><td><div class="info">This module defines the <code class="code">Map</code> module for <code class="code">Core.Std</code>.  We use &quot;core_map&quot; as the file
    name rather than &quot;map&quot; to avoid conflicts with OCaml's standard map module.  In this
    documentation, we use <code class="code">Map</code> to mean this module, not the OCaml standard one.<br/>    <code class="code">Map</code> is a functional datastructure (balanced binary tree) implementing finite maps
    over a totally-ordered domain, called a &quot;key&quot;.  The map types and operations appear
    in three places:<br/>    <span class="verbatim">    | Map      | polymorphic map operations                                      |
    | Map.Poly | maps that use polymorphic comparison to order keys              |
    | Key.Map  | maps with a fixed key type that use [Key.compare] to order keys |
    </span><br/>    Where <code class="code">Key</code> is any module defining values that can be used as keys of a map, like
    <code class="code">Int</code>, <code class="code">String</code>, etc.  To add this functionality to an arbitrary module, use the
    <code class="code">Comparable.Make</code> functor.<br/>    One should use <code class="code">Map</code> for functions that access existing maps, like <code class="code">find</code>, <code class="code">mem</code>,
    <code class="code">add</code>, <code class="code">fold</code>, <code class="code">iter</code>, and <code class="code">to_alist</code>.  For functions that create maps, like <code class="code">empty</code>,
    <code class="code">singleton</code>, and <code class="code">of_alist</code>, one should strive to use the corresponding <code class="code">Key.Map</code>
    function, which will use the comparison function specifically for <code class="code">Key</code>.  As a last
    resort, if one does not have easy access to a comparison function for the keys in
    one's map, use <code class="code">Map.Poly</code> to create the map.  This will use OCaml's built-in
    polymorphic comparison to compare keys, which has all the usual performance and
    robustness problems that entails.<br/>    Parallel to the three kinds of map modules, there are also tree modules <code class="code">Map.Tree</code>,
    <code class="code">Map.Poly.Tree</code>, and <code class="code">Key.Map.Tree</code>.  A tree is a bare representation of a map,
    without the comparator.  Thus tree operations need to obtain the comparator from
    somewhere.  For <code class="code">Map.Poly.Tree</code> and <code class="code">Key.Map.Tree</code>, the comparator is implicit in the
    module name.  For <code class="code">Map.Tree</code>, the comparator must be passed to each operation.  The
    main advantages of trees over maps are slightly improved space usage (there is no
    outer container holding the comparator) and the ability to marshal trees, because a
    tree doesn't contain a closure, unlike a map.  The main disadvantages of using trees
    are needing to be more explicit about the comparator, and the possibility of
    accidental use of polymorphic equality on a tree (for which maps dynamically detect
    failure due to the presence of a closure in the data structure).<br/>    For a detailed explanation of the interface design, read on.<br/>    An instance of the map type is determined by the types of the map's keys and values,
    and the comparison function used to order the keys:<br/>    <pre class="codepre"><code class="code"> type ('key, 'value, 'cmp) Map.t </code></pre><br/>    <code class="code">'cmp</code> is a phantom type uniquely identifying the comparison function, as generated by
    <code class="code">Comparator.Make</code>.<br/>    <code class="code">Map.Poly</code> supports arbitrary key and value types, but enforces that the comparison
    function used to order the keys is polymorphic comparison.  <code class="code">Key.Map</code> has a fixed key
    type and comparison function, and supports arbitrary values.<br/>    <pre class="codepre"><code class="code">
      type ('key, 'value) Map.Poly.t = ('key , 'value, Comparator.Poly.t) Map.t
      type 'value Key.Map.t          = (Key.t, 'value, Key.comparator   ) Map.t
    </code></pre><br/>    The same map operations exist in <code class="code">Map</code>, <code class="code">Map.Poly</code>, and <code class="code">Key.Map</code>, albeit with
    different types.  For example:<br/>    <pre class="codepre"><code class="code">
      val Map.length      : (_, _, _) Map.t   -&gt; int
      val Map.Poly.length : (_, _) Map.Poly.t -&gt; int
      val Key.Map.length  : _ Key.Map.t       -&gt; int
    </code></pre><br/>    Because <code class="code">Map.Poly.t</code> and <code class="code">Key.Map.t</code> are exposed as instances of the more general
    <code class="code">Map.t</code> type, one can use <code class="code">Map.length</code> on any map.  The same is true for all of the
    functions that access an existing map, such as <code class="code">add</code>, <code class="code">change</code>, <code class="code">find</code>, <code class="code">fold</code>,
    <code class="code">iter</code>, <code class="code">map</code>, <code class="code">to_alist</code>, etc.<br/>    Depending on the number of type variables <code class="code">N</code>, the type of accessor (resp. creator)
    functions are defined in the module type <code class="code">AccessorsN</code> (resp. <code class="code">CreatorsN</code>) in
     <a href="#Core_map_intf">Core_map_intf</a>.  Also for creators, when the comparison function is not fixed,
    i.e. the <code class="code">'cmp</code> variable of <code class="code">Map.t</code> is free, we need to pass a comparator to the
    function creating the map.  The module type is called <code class="code">Creators3_with_comparator</code>.
    There is also a module type <code class="code">Accessors3_with_comparator</code> in addition to <code class="code">Accessors3</code>
    which used for trees since the comparator is not known.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_map_intf">Core_map_intf</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_map_unit_tests">Core_map_unit_tests</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_nativeint">Core_nativeint</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_printexc">Core_printexc</a></td><td><div class="info">This module is here to ensure that we don't use the functions in <code class="code">Caml.Printexc</code>
    inadvertently</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_printf">Core_printf</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_queue">Core_queue</a></td><td><div class="info">Core_queue is a wrapper around OCaml's standard Queue module that
    follows Core idioms and adds some functions.<br/>    Differences from the standard module:
      <code class="code">enqueue</code> replaces <code class="code">push</code>, <code class="code">add</code>, and takes the queue first.
      <code class="code">dequeue</code> replaces <code class="code">pop</code>, <code class="code">take</code>, takes the queue first, and returns an
        option rather than raising <code class="code">Empty</code>.
      <code class="code">dequeue_exn</code> is available if you want to raise <code class="code">Empty</code>.
      <code class="code">iter</code> takes a labeled argument.
      <code class="code">transfer</code>'s arguments are labeled.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_random">Core_random</a></td><td><div class="info">Pseudo-random number generators (PRNG).</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_set">Core_set</a></td><td><div class="info">This module defines the <code class="code">Set</code> module for <code class="code">Core.Std</code>.  We use &quot;core_set&quot; as the file
    name rather than &quot;set&quot; to avoid conflicts with OCaml's standard set module.<br/>    This module uses the same organizational approach as <code class="code">Core_map</code>.  See the
    documentation in core_map.mli for a description of the approach.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_set_intf">Core_set_intf</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_set_unit_tests">Core_set_unit_tests</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_sexp">Core_sexp</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_stack">Core_stack</a></td><td><div class="info">A stack implemented with an array.  See  <a href="#Stack_intf">Stack_intf</a> for documentation.<br/>    The implementation will grow the array as necessary.  By default, it will not
    automatically shrink the array.  One can use <code class="code">set_auto_shrink</code> to change
    auto-shrinking behavior.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_string">Core_string</a></td><td><div class="info">An extension of the standard StringLabels. If you open Core.Std, you'll get
    these in the String module.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Core_weak">Core_weak</a></td><td><div class="info"><code class="code">Weak</code> is like the OCaml standard library module of the same name, except that it
    requires that the values in the weak set are heap blocks.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Day_of_week">Day_of_week</a></td><td><div class="info">For representing a day of the week.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Debug">Debug</a></td><td><div class="info">Utilities for printing debug messages.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Decimal">Decimal</a></td><td><div class="info">The <code class="code">decimal</code> type alias provides more readable serializations to s-expressions, at
    the cost of lower precision.  For example:<br/>    <pre class="codepre"><code class="code">
    # sexp_of_decimal 3.000000000001;;
    - : Sexp.t = 3
    # sexp_of_float 3.000000000001;;
    - : Sexp.t = 3.0000000000010000889
    </code></pre><br/>    Also, the decimal sexp-converter will fail when provided with <code class="code">nan</code> or <code class="code">infinity</code>.<br/>    <pre class="codepre"><code class="code">
    # float_of_sexp (Sexp.Atom &quot;nan&quot;);;
    - : float = nan
    # decimal_of_sexp (Sexp.Atom &quot;nan&quot;);;
    Exception:
    (Sexplib.Conv.Of_sexp_error (Failure common.ml.Decimal_nan_or_inf) nan).
    </code></pre></div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Dequeue">Dequeue</a></td><td><div class="info">A double ended queue that can shrink and expand on both ends.<br/>    An index is assigned to an element when it enters the queue, and the index of an
    element is static (i.e. an index refers to a distinct element until that element is
    removed from the queue, no matter how many intervening push/pop operations occur).<br/>    One consequence of this is that the minimum index may be &lt; 0.<br/>    The &quot;front&quot; is the smallest valid index, while the &quot;back&quot; is the largest.<br/>    All operations are amortized O(1) with a small constant.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Doubly_linked">Doubly_linked</a></td><td><div class="info">doubly-linked lists</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Equal">Equal</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Error">Error</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Exn">Exn</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Flags">Flags</a></td><td><div class="info">See flags_intf.ml for documentation.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Flags_intf">Flags_intf</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Flat_array">Flat_array</a></td><td><div class="info">An array of flat tuples.<br/>    A flat tuple is like an ordinary OCaml tuple, except it is second class and mutable.
    The flat tuples in a <code class="code">Flat_array.t</code> are layed out sequentially in a single array, with
    each flat tuple's components immediately following the components of the prior flat
    tuple.  A flat tuple is not first class -- one can only refer to a flat tuple via its
    index in the array holding it.  Flat tuples are mutable via <code class="code">Flat_array.set</code>.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Flat_array_debug">Flat_array_debug</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Flat_array_unit_tests">Flat_array_unit_tests</a></td><td><div class="info">This signature is here to remind us to update the unit tests whenever we change
    <code class="code">Flat_array</code>.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Flat_queue">Flat_queue</a></td><td><div class="info">A queue of flat tuples, represented in a  <a href="#Flat_array">Flat_array</a>.<br/>    The elements of a queue are numbered 0, 1, ..., <code class="code">length t - 1</code>, where element <code class="code">0</code> is
    at the front of the queue.  One can access the <code class="code">j</code>'th component of the <code class="code">i</code>'th element
    using <code class="code">get t i Slot.tj</code>.<br/>    A flat tuple is like an ordinary OCaml tuple, except it is second class and mutable.
    The flat tuples in a flat queue are layed out sequentially, with each flat tuple's
    components immediately following the components of the prior flat tuple.  A flat tuple
    is not first class -- one can only refer to a flat tuple via its index in the queue
    holding it.  Flat tuples are mutable via <code class="code">Flat_queue.set</code>.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Flat_queue_debug">Flat_queue_debug</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Flat_queue_unit_tests">Flat_queue_unit_tests</a></td><td><div class="info">This signature is here to remind us to update the unit tests whenever we change
    <code class="code">Flat_queue</code>.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Float">Float</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Float_intf">Float_intf</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Float_robust_compare">Float_robust_compare</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Floatable">Floatable</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Fn">Fn</a></td><td><div class="info">various combinators for functions</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Force_once">Force_once</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Fqueue">Fqueue</a></td><td><div class="info">A simple polymorphic functional queue.<br/>    Amortized running times assumes that enqueue/dequeue are used sequentially, threading
    the changing Fqueue through the calls.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Hash_heap">Hash_heap</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Hash_queue">Hash_queue</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Hash_set">Hash_set</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Hash_set_intf">Hash_set_intf</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Hashable">Hashable</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Hashtbl_unit_tests">Hashtbl_unit_tests</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Heap">Heap</a></td><td><div class="info">Heap implementation based on a pairing-heap.<br/>    This heap implementations supports an arbitrary element type, via a comparison
    function.  If you need a heap with elements ordered by integers, then it may be more
    efficient to use a <code class="code">Timing_wheel.Priority_queue</code>, which is a heap implementation
    specialized to integer keys, and with some other performance differences and usage
    restrictions.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Heap_block">Heap_block</a></td><td><div class="info">A heap block is a value that is guaranteed to live on the OCaml heap, and is hence
    guaranteed to be usable with finalization or in a weak pointer.  It is an abstract
    type so we can use the type system to guarantee that the values we put in weak
    pointers and use with finalizers are heap blocks.<br/>    Some examples of values that are not heap-allocated are integers, constant
    constructors, booleans, the empty array, the empty list, the unit value.  The exact
    list of what is heap-allocated or not is implementation-dependent.  Some constant
    values can be heap-allocated but never deallocated during the lifetime of the program,
    for example a list of integer constants; this is also implementation-dependent.  You
    should also be aware that compiler optimizations may duplicate some immutable values,
    for example floating-point numbers when stored into arrays; thus they can be finalized
    and collected while another copy is still in use by the program.<br/>    The results of calling  <a href="#String.make">String.make</a>,  <a href="#String.create">String.create</a>,  <a href="#Array.make">Array.make</a>, and
     <a href="#Pervasives.ref">Pervasives.ref</a> are guaranteed to be heap-allocated and non-constant except when the
    length argument is <code class="code">0</code>.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Heap_intf">Heap_intf</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Host_and_port">Host_and_port</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Identifiable">Identifiable</a></td><td><div class="info">a signature for opaque identifier types.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=In_channel">In_channel</a></td><td><div class="info">In_channel collects all of the pervasive functions that work on in_channels.
 It adds some new functions (like <code class="code">input_all</code> and <code class="code">input_lines</code>).
 It names things using the fact that there is no worry about toplevel name
      conflicts (since we are in a module).
 It uses labelled arguments.
 It returns an option rather than raising End_of_file.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Info">Info</a></td><td><div class="info"><code class="code">Info</code> is a library for lazily constructing human-readable information as a string or
    sexp, with a primary use being error messages.  Using <code class="code">Info</code> is often preferable to
    <code class="code">sprintf</code> or manually constructing strings because you don't have to eagerly construct
    the string --- you only need to pay when you actually want to display the info.  which
    for many applications is rare.  Using <code class="code">Info</code> is also better than creating custom
    exceptions because you have more control over the format.<br/>    Info is intended to be constructed in the following style; for simple info, you write:<br/>    <pre class="codepre"><code class="code">Info.of_string &quot;Unable to find file&quot;</code></pre><br/>    For info where you want to attach some content, you would write:<br/>    <pre class="codepre"><code class="code">Info.create &quot;Unable to find file&quot; filename &lt;:sexp_of&lt; string &gt;&gt;</code></pre><br/>    Or even,<br/>    <pre class="codepre"><code class="code">
    Info.create &quot;price too big&quot; (price, [`Max max_price])
      (&lt;:sexp_of&lt; float * [`Max of float] &gt;&gt;)
    </code></pre><br/>    Note that an <code class="code">Info.t</code> can be created from any arbritrary sexp with <code class="code">Info.t_of_sexp</code>.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Int_conversions">Int_conversions</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Int_intf">Int_intf</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Int_math">Int_math</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Int_replace_polymorphic_compare">Int_replace_polymorphic_compare</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Int_set">Int_set</a></td><td><div class="info">An implementation of compressed integer sets using lists of integer ranges. Operations
    such as adding and membership are O(n) where n is the number of contigous ranges in
    the set. For data that is mostly serial, n should remain very small.<br/>    Note that when n gets very large, in addition to poor performance, this behavior may
    throw exceptions since some of the code is not tail-recursive.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Intable">Intable</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Interfaces">Interfaces</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Interned_string">Interned_string</a></td><td><div class="info">Provides a functor for creating an interned string type.<br/>    An interned string is internally an int which is an index into a lookup table, which
    makes hashing and (non-lexicographic) comparison faster than for strings.  The
    tradeoff is that converting an interned string to and from a string is slower, since
    they require table lookups instead of being no-ops.<br/>    Some notes on the implementation:<br/>    - It is not thread-safe (different applications of the functor can be used
      safely from different threads, but an individual interned string module
      is not safe to use concurrently from different threads.)<ul><li>It is leaky, meaning that an interned string, once allocated, will never be
      deallocated.</li><li>Interned strings are compared based on the integer they are assigned on creation,
      which is not a lexicographic order, and is not necessarily stable between runs of a
      program.</li></ul>    The semantics of the other operations should be the same as for <code class="code">String</code>.<br/>    We don't fix the memory leak with weak pointers for performance reasons.  See
    <code class="code">jane</code>/interns/ahuq/strint/README at revision b9a2b9dbf290.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Invariant">Invariant</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Invariant_intf">Invariant_intf</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Linked_stack">Linked_stack</a></td><td><div class="info">A stack implemented with a list.  See  <a href="#Stack_intf">Stack_intf</a> for documentation.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Make_substring">Make_substring</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Memo">Memo</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Monad">Monad</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Month">Month</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Never_returns">Never_returns</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=No_polymorphic_compare">No_polymorphic_compare</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Nothing">Nothing</a></td><td><div class="info">An uninhabited type.<br/>    This is useful when interfaces require that a type be specified, but the implementer
    knows this type will not be used in their implementation of the interface.<br/>    For instance, <code class="code">Async.Std.Rpc.Pipe_rpc.t</code> is parameterized by an error type, but a user
    may want to define a Pipe RPC that can't fail.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Nothing0">Nothing0</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Obj_array">Obj_array</a></td><td><div class="info">An array of <code class="code">Obj.t</code>s.<br/>    This is useful to have as its own type because we can implement faster <code class="code">get</code> and <code class="code">set</code>
    functions that know that they aren't dealing with float arrays and save a test for it.
    We also have <code class="code">set</code> avoid the write barrier (caml_modify) in certain situations.<br/>    Just like with a regular <code class="code">Array</code>, the elements are boxed so they don't get copied by
    <code class="code">sub</code>, <code class="code">get</code>, <code class="code">set</code>, <code class="code">blit</code>, etc.<br/>    The dynamic check this array module implements is something we hope to have
    implemented at a lower level (as part of the native compiler's code generation).
    Given that, the interface is somewhat spartan and intended for use within internal
    data structures.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Only_in_test">Only_in_test</a></td><td><div class="info">This module can be used to safely expose functions and values in signatures
    that can only be used in unit tests.<br/>    Under the hood, <code class="code">'a t = (unit -&gt; 'a)</code> and the only thing that ever forces them
    is the <code class="code">run_tests_and_exit</code> function below which actually runs the unit tests.<br/>    For example, suppose in some module, <code class="code">type t</code> is actually an <code class="code">int</code>.  You
    want to keep the type definition opaque, but use the underlying
    representation in unit tests.  You could write in the ml:<br/>    <pre class="codepre"><code class="code">let test_to_int t = Only_in_test.return t
    [let test_of_int n = Only_in_test.return n</code></pre><br/>    You would then expose in the mli:<br/>    <pre class="codepre"><code class="code">type t
    ... functions for use in regular programming...
    val test_to_int : t -&gt; int Only_in_test.t
    val test_of_int : int -&gt; t Only_in_test.t</code></pre><br/>    Finally, if you have specific values that you might want to use in unit
    tests, but that have top-level side-effects or take too long to compute, you
    can delay the side-effects or computation until the unit tests are run by
    writing, e.g.:<br/>    <code class="code">let (test_special_value : t Only_in_test.t) =
       Only_in_test.of_thunk (fun () -&gt;  (factorial 100))</code><br/>    instead of<br/>    <code class="code">let (test_special_value : t Only_in_test.t) =
       Only_in_test.return (factorial 100)</code></div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Option">Option</a></td><td><div class="info"><code class="code">Option</code> wraps the output <code class="code">x</code> of successful functions in <code class="code">Some x</code>.  Failed
    functions return <code class="code">None</code>.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Or_error">Or_error</a></td><td><div class="info">Type for tracking errors in an Error.t. This is a specialization of the Result type,
    where the Error constructor carries an Error.t.<br/>    A common idiom is to wrap a function that is not implemented on all platforms, e.g.:<br/>    val do_something_linux_specific : (unit -&gt; unit) Or_error.t</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Ordered_collection_common">Ordered_collection_common</a></td><td><div class="info"><code class="code">normalize length_fun thing_with_length i</code> is just <code class="code">i</code>, unless
    <code class="code">i</code> is negative, in which case it's <code class="code">length_fun thing_with_length + i</code>.
    This is used by various python-style slice functions.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Ordering">Ordering</a></td><td><div class="info"><code class="code">Ordering</code> is intended to make code that matches on the result of a comparison
    more concise and easier to read.  For example, one would write:<br/>    <pre class="codepre"><code class="code">
      match Ordering.of_int (compare x y) with
      | Less -&gt; ...
      | Equal -&gt; ...
      | Greater -&gt; ...
    </code></pre><br/>    rather than:<br/>    <pre class="codepre"><code class="code">
      let r = compare x y in
      if r &lt; 0 then
        ...
      else if r = 0 then
        ...
      else
        ...
    </code></pre></div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Out_channel">Out_channel</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Pid">Pid</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Poly">Poly</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Polymorphic_compare">Polymorphic_compare</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Polymorphic_compare_intf">Polymorphic_compare_intf</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Pool">Pool</a></td><td><div class="info">See pool_intf.ml for documentation.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Pool_intf">Pool_intf</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Pool_unit_tests">Pool_unit_tests</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Pooled_hashtbl">Pooled_hashtbl</a></td><td><div class="info">A polymorphic hashtbl that uses <code class="code">Pool</code> to avoid allocation.<br/>    This uses the standard linked-chain hashtable algorithm, albeit with links performed
    through a pool and hence avoiding caml_modify (for table manipulation), even when
    hashing object keys/values.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Pooled_hashtbl_unit_test">Pooled_hashtbl_unit_test</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Pretty_printer">Pretty_printer</a></td><td><div class="info">A list of pretty printers for various types, for use in toplevels.<br/>    <code class="code">Pretty_printer</code> has a <code class="code">string list ref</code> with the names of <code class="code">pp</code> functions matching the
    interface:<br/>    <pre class="codepre"><code class="code">
      val pp : Format.formatter -&gt; t -&gt; unit
    </code></pre><br/>    The names are actually OCaml identifier names, e.g. &quot;Core.Date.pp&quot;.  Code for building
    toplevels (this code is not in Core) evaluates the strings to yield the pretty
    printers and register them with OCaml runtime.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Quickcheck">Quickcheck</a></td><td><div class="info">Module for easily generating unit tests.  Based on code posted by
    padiolea@irisa.fr to the caml mailing list.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Ref">Ref</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Result">Result</a></td><td><div class="info"><code class="code">Result</code> is often used to handle error messages.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Robustly_comparable">Robustly_comparable</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Set_once">Set_once</a></td><td><div class="info">This module implements an option ref that starts out as None, and
    may be set only once. If one tries to set it twice a run time
    error is generated.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Sexpable">Sexpable</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Source_code_position">Source_code_position</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Source_code_position0">Source_code_position0</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Stable">Stable</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Stable_containers">Stable_containers</a></td><td><div class="info">The Stable versions of Hashtbl, Hash_set, Map, and Set are defined here rather than in
    their respective modules because:<br/>    1. We guarantee their serializations independent of the implementation of those modules
    2. Given 1. it is cleaner (and still okay) to separate the code into a separate file</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Stable_internal">Stable_internal</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Stable_unit_test">Stable_unit_test</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Stable_unit_test_intf">Stable_unit_test_intf</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Stack_intf">Stack_intf</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Stack_unit_tests">Stack_unit_tests</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Staged">Staged</a></td><td><div class="info">A type for making staging explicit in the type of a function.  For example, you might
    want to have a function that creates a function for allocating unique identifiers.
    Rather than using the type:<br/>    <pre class="codepre"><code class="code">
    val make_id_allocator : unit -&gt; unit -&gt; int
    </code></pre><br/>    you would have<br/>    <pre class="codepre"><code class="code">
    val make_id_allocator : unit -&gt; (unit -&gt; int) Staged.t
    </code></pre><br/>    Such a function could be defined as follows:<br/>    <pre class="codepre"><code class="code">
    let make_id_allocator () =
      let ctr = ref 0 in
      stage (fun () -&gt; incr ctr; !ctr)
    </code></pre><br/>    and could be invoked as follows:<br/>    <pre class="codepre"><code class="code">
    let (id1,id2) =
      let alloc = unstage (make_id_allocator ()) in
      (alloc (), alloc ())
    </code></pre><br/>    both stage and unstage functions are available in Common.<br/>    (Note that in many cases, including perhaps the one above, it's preferable to create a
    custom type rather than use Staged.)</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Std">Std</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Std_common">Std_common</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Std_internal">Std_internal</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Std_kernel">Std_kernel</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=String_id">String_id</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Stringable">Stringable</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Substring">Substring</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Substring_intf">Substring_intf</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=T">T</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Thread_safe_queue">Thread_safe_queue</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Tuple">Tuple</a></td><td><div class="info">Functors and signatures for dealing with modules for tuples.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Tuple_type">Tuple_type</a></td><td><div class="info">Tuple-like types used in <code class="code">Flat_array</code> and <code class="code">Pool</code>.<br/>    See  <a href="#Tuple_type_intf">Tuple_type_intf</a> for documentation.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Tuple_type_intf">Tuple_type_intf</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Type_equal">Type_equal</a></td><td><div class="info">For representing type equalities otherwise not known by the type-checker.<br/>    The purpose of <code class="code">Type_equal</code> is to represent type equalities that the type checker
    otherwise would not know, perhaps because the type equality depends on dynamic data,
    or perhaps because the type system isn't powerful enough.<br/>    A value of type <code class="code">(a, b) Type_equal.t</code> represents that types <code class="code">a</code> and <code class="code">b</code> are equal.
    One can think of such a value as a proof of type equality.  The <code class="code">Type_equal</code> module
    has operations for constructing and manipulating such proofs.  For example, the
    functions <code class="code">refl</code>, <code class="code">sym</code>, and <code class="code">trans</code> express the usual properties of reflexivity,
    symmetry, and transitivity of equality.<br/>    If one has a value <code class="code">t : (a, b) Type_equal.t</code> that proves types <code class="code">a</code> and <code class="code">b</code> are equal,
    there are two ways to use <code class="code">t</code> to safely convert a value of type <code class="code">a</code> to a value of type
    <code class="code">b</code>: <code class="code">Type_equal.conv</code> or pattern matching on <code class="code">Type_equal.T</code>:<br/>    <pre class="codepre"><code class="code">
      let f (type a) (type b) (t : (a, b) Type_equal.t) (a : a) : b =
        Type_equal.conv t a

      let f (type a) (type b) (t : (a, b) Type_equal.t) (a : a) : b =
        let Type_equal.T = t in a
    </code></pre><br/>    At runtime, conversion by either means is just the identity -- nothing is changing
    about the value.  Consistent with this, a value of type <code class="code">Type_equal.t</code> is always just
    a constructor <code class="code">Type_equal.T</code>; the value has no interesting semantic content.
    <code class="code">Type_equal</code> gets its power from the ability to, in a type-safe way, prove to the type
    checker that two types are equal.  The <code class="code">Type_equal.t</code> value that is passed is
    necessary for the type-checker's rules to be correct, but the compiler, could, in
    principle, not pass around values of type <code class="code">Type_equal.t</code> at run time.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Union_find">Union_find</a></td><td><div class="info">Imperative data structure for representing disjoint sets.<br/>    Union find is used to implement an equivalence relation on objects, where
    the equivalence relation can dynamically be coarsened by &quot;union&quot;ing two
    equivalence classes together.<br/>    All of the operations are effectively (amortized) constant time.<div class="see"><b>See also</b> <ul>  <li> <a href="en.wikipedia.org/wiki/Disjoint-set_data_structure">wikipedia.<br/>    This implementation is not thread-safe.</a></li></ul></div></div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Unique_id">Unique_id</a></td><td><div class="info">Functors for creating modules that mint unique identifiers.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Unique_id_intf">Unique_id_intf</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Unit">Unit</a></td><td><div class="info">Module for the type <code class="code">unit</code>.  This is mostly useful for building functor arguments.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Univ">Univ</a></td><td><div class="info">An extensible &quot;universal&quot; variant type, that can be extended by adding new
    constructors with arguments of arbitrary type.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Univ_map">Univ_map</a></td><td><div class="info">Universal/heterogeneous maps.<br/>    These maps are useful for storing values of arbitrary type in a single map.  In order
    to recover a value, it must be looked up with exactly the <code class="code">Key.t</code> it was stored in.
    In other words, given different <code class="code">Key.t</code>'s from the same <code class="code">string</code>, one will not be able
    to recover the key stored in the other one.<br/>    This is similar to <code class="code">Univ</code> in spirit, and is indeed built on top of <code class="code">Univ</code>.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Unpack_buffer">Unpack_buffer</a></td><td><div class="info">A buffer for incremental decoding of an input stream.<br/>    An <code class="code">Unpack_buffer.t</code> is a buffer to which one can <code class="code">feed</code> strings, and then <code class="code">unpack</code>
    from the buffer to produce a queue of values.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Validate">Validate</a></td><td><div class="info">A module for organizing validations of data structures.  Allows standardized ways of
    checking for conditions, and keeps track of the location of errors by keeping a path
    to each error found.  Thus, if you were validating the following datastructure:<br/>    <pre class="codepre"><code class="code">
      { foo = 3;
        bar = { snoo = 34.5;
                blue = Snoot -6; }
      }
    </code></pre><br/>    One might end up with an error with the error path:<br/>    <span class="verbatim">bar.blue.Snoot : value -6 &lt;= bound 0 </span><br/>    By convention, the validations for a type defined in module <code class="code">M</code> appear in module <code class="code">M</code>,
    and have their name prefixed by <code class="code">validate_</code>.  E.g. <code class="code">Int.validate_positive</code>.<br/>    Here's an example of how you would use validate with a record.<br/>    <pre class="codepre"><code class="code">
     type t =
       { foo: int;
         bar: float;
       }
     with fields

     let validate t =
       let module V = Validate in
       let w check = V.field_folder t check in
       V.of_list
         (Fields.fold ~init:[]
            ~foo:(w Int.validate_positive)
            ~bar:(w Float.validate_non_negative)
         )
    </code></pre><br/>    And here's an example of how you would use it with a variant type:<br/>    <pre class="codepre"><code class="code">
      type t =
        | Foo of int
        | Bar of (float * int)
        | Snoo of Floogle.t

      let validate = function
        | Foo i -&gt; V.name &quot;Foo&quot; (Int.validate_positive i)
        | Bar p -&gt; V.name &quot;Bar&quot; (V.pair
                                   ~fst:Float.validate_positive
                                   ~snd:Int.validate_non_negative)
        | Snoo floogle -&gt; V.name &quot;Snoo&quot; Floogle.validate
    </code></pre></div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Validated">Validated</a></td><td><div class="info">See  <a href="#Validated_intf">Validated_intf</a> for documentation.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Validated_intf">Validated_intf</a></td><td/></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=With_return">With_return</a></td><td><div class="info">This is <code class="code">include</code>'d and documented in  <a href="#module: Common">module: Common</a>.  It is defined here to avoid
    circular dependencies.</div></td></tr>
<tr><td class="module"><a href="?package=core_kernel&amp;module=Word_size">Word_size</a></td><td><div class="info">For determining the word size that the program is using.</div></td></tr>
</table>