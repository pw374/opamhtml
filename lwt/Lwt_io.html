<div class="ocaml_toplevel_module"><div class="info">Buffered byte channels</div>
<div class="info"><div class="info">A <b>channel</b> is a high-level object for performing IOs. It allow
    to read/write things from/to the outside worlds in an efficient
    way, by minimising the number of system calls.<br/>    An <b>output channel</b> is a channel that can be used to send data
    and an <b>input channel</b> is a channel that can used to receive
    data.<br/>    If you are familiar with buffered channels you may be familiar too
    with the <b>flush</b> operation. Note that byte channles of this
    modules are automatically flushed when there is nothing else to do
    (i.e. before the program goes into idle), so this means that you
    no longer have to write:<br/>    <pre class="codepre"><code class="code">
      eprintf &quot;log message\n&quot;;
      flush stderr;
    </code></pre><br/>    to have you messages displayed.<br/>    Note about errors: input functions of this module raise
    <code class="code">End_of_file</code> when the end-of-file is reached (i.e. when the read
    function returns <code class="code">0</code>). Other exceptions are ones caused by the
    backend read/write functions, such as <code class="code">Unix.Unix_error</code>.</div></div>
<pre><span class="EXCEPTIONChannel_closed"><span class="keyword">exception</span> Channel_closed</span> <span class="keyword">of</span> <code class="type">string</code></pre><div class="info"><div class="info">Exception raised when a channel is closed. The parameter is a
      description of the channel.</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Types</h6></div></div>
<pre><span class="TYPEchannel"><span class="keyword">type</span> <code class="type">'mode </code>channel</span> </pre><div class="info"><div class="info">Type of buffered byte channels</div></div>
<pre><span class="TYPEinput"><span class="keyword">type</span> input</span> </pre><div class="info"><div class="info">Input mode</div></div>
<pre><span class="TYPEoutput"><span class="keyword">type</span> output</span> </pre><div class="info"><div class="info">Output mode</div></div>
<pre><code><span class="TYPEmode"><span class="keyword">type</span> <code class="type">'a </code>mode</span> = </code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTmode.Input"><span class="constructor">Input</span></span></code></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTmode.Output"><span class="constructor">Output</span></span></code></td></tr></table><div class="info"><div class="info">Channel mode</div></div>
<pre><span class="VALinput"><span class="keyword">val</span> input</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=input">input</a> <a href="?package=lwt&amp;module=Lwt_io&amp;type=mode">mode</a></code></pre><div class="info"><div class="info"><code class="code">input</code> input mode representation</div></div>
<pre><span class="VALoutput"><span class="keyword">val</span> output</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output">output</a> <a href="?package=lwt&amp;module=Lwt_io&amp;type=mode">mode</a></code></pre><div class="info"><div class="info"><code class="code">output</code> output mode representation</div></div>
<pre><span class="TYPEinput_channel"><span class="keyword">type</span> input_channel</span> = <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=input">input</a> <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a></code></pre><div class="info"><div class="info">Type of input channels</div></div>
<pre><span class="TYPEoutput_channel"><span class="keyword">type</span> output_channel</span> = <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output">output</a> <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a></code></pre><div class="info"><div class="info">Type of output channels</div></div>
<pre><span class="VALmode"><span class="keyword">val</span> mode</span> : <code class="type">'a <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a> -&gt; 'a <a href="?package=lwt&amp;module=Lwt_io&amp;type=mode">mode</a></code></pre><div class="info"><div class="info"><code class="code">mode ch</code> returns the mode of a channel</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Well-known instances</h6></div></div>
<pre><span class="VALstdin"><span class="keyword">val</span> stdin</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=input_channel">input_channel</a></code></pre><div class="info"><div class="info">The standard input, it reads data from  <a href="#Lwt_unix.stdin">Lwt_unix.stdin</a></div></div>
<pre><span class="VALstdout"><span class="keyword">val</span> stdout</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a></code></pre><div class="info"><div class="info">The standard output, it writes data to  <a href="#Lwt_unix.stdout">Lwt_unix.stdout</a></div></div>
<pre><span class="VALstderr"><span class="keyword">val</span> stderr</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a></code></pre><div class="info"><div class="info">The standard output for error messages, it writes data to
       <a href="#Lwt_unix.stderr">Lwt_unix.stderr</a></div></div>
<pre><span class="VALzero"><span class="keyword">val</span> zero</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=input_channel">input_channel</a></code></pre><div class="info"><div class="info">Inputs which returns always <code class="code">'\x00'</code></div></div>
<pre><span class="VALnull"><span class="keyword">val</span> null</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a></code></pre><div class="info"><div class="info">Output which drops everything</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Channels creation/manipulation</h6></div></div>
<pre><span class="VALpipe"><span class="keyword">val</span> pipe</span> : <code class="type">?buffer_size:int -&gt; unit -&gt; <a href="?package=lwt&amp;module=Lwt_io&amp;type=input_channel">input_channel</a> * <a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a></code></pre><div class="info"><div class="info"><code class="code">pipe ?buffer_size ()</code> creates a pipe using  <a href="#Lwt_unix.pipe">Lwt_unix.pipe</a> and
      makes two channels from the two returned file descriptors</div></div>
<pre><span class="VALmake"><span class="keyword">val</span> make</span> : <code class="type">?buffer_size:int -&gt;
?close:(unit -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a>) -&gt;
?seek:(int64 -&gt; <a href="?package=ocaml&amp;module=Unix&amp;type=seek_command">Unix.seek_command</a> -&gt; int64 <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a>) -&gt;
mode:'mode <a href="?package=lwt&amp;module=Lwt_io&amp;type=mode">mode</a> -&gt; (<a href="?package=lwt&amp;module=Lwt_bytes&amp;type=t">Lwt_bytes.t</a> -&gt; int -&gt; int -&gt; int <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a>) -&gt; 'mode <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a></code></pre><div class="info"><div class="info"><code class="code">make ?buffer_size ?close ~mode perform_io</code> is the
      main function for creating new channels.<div class="parameters"><div class="param_info"><code class="code">buffer_size</code> : size of the internal buffer. It must be
      between 16 and <code class="code">Sys.max_string_length</code></div><div class="param_info"><code class="code">close</code> : close function of the channel. It defaults to
      <code class="code">Lwt.return</code></div><div class="param_info"><code class="code">seek</code> : same meaning as <code class="code">Unix.lseek</code></div><div class="param_info"><code class="code">mode</code> : either  <a href="#input">input</a> or  <a href="#output">output</a></div><div class="param_info"><code class="code">perform_io</code> : is the read or write function. It is called
      when more input is needed or when the buffer need to be
      flushed.</div></div></div></div>
<pre><span class="VALof_bytes"><span class="keyword">val</span> of_bytes</span> : <code class="type">mode:'mode <a href="?package=lwt&amp;module=Lwt_io&amp;type=mode">mode</a> -&gt; <a href="?package=lwt&amp;module=Lwt_bytes&amp;type=t">Lwt_bytes.t</a> -&gt; 'mode <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a></code></pre><div class="info"><div class="info">Create a channel from a byte array. Reading/writing is done
      directly on the provided array.</div></div>
<pre><span class="VALof_fd"><span class="keyword">val</span> of_fd</span> : <code class="type">?buffer_size:int -&gt;
?close:(unit -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a>) -&gt;
mode:'mode <a href="?package=lwt&amp;module=Lwt_io&amp;type=mode">mode</a> -&gt; <a href="?package=lwt&amp;module=Lwt_unix&amp;type=file_descr">Lwt_unix.file_descr</a> -&gt; 'mode <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a></code></pre><div class="info"><div class="info"><code class="code">of_fd ?buffer_size ?close ~mode fd</code> creates a channel from a
      file descriptor.<div class="parameters"><div class="param_info"><code class="code">close</code> : defaults to closing the file descriptor.</div></div></div></div>
<pre><span class="VALof_unix_fd"><span class="keyword">val</span> of_unix_fd</span> : <code class="type">?buffer_size:int -&gt;
?close:(unit -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a>) -&gt;
mode:'mode <a href="?package=lwt&amp;module=Lwt_io&amp;type=mode">mode</a> -&gt; <a href="?package=ocaml&amp;module=Unix&amp;type=file_descr">Unix.file_descr</a> -&gt; 'mode <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a></code></pre><div class="info"><div class="info"><code class="code">of_unix_fd ?buffer_size ?close ~mode fd</code> is a short-hand for:<br/>      <code class="code">of_fd ?buffer_size ?close (Lwt_unix.of_unix_file_descr fd)</code></div></div>
<pre><span class="VALclose"><span class="keyword">val</span> close</span> : <code class="type">'a <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a> -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">close ch</code> closes the given channel. If <code class="code">ch</code> is an output
      channel, it performs all pending actions, flush it and close
      it. If <code class="code">ch</code> is an input channel, it just close it immediatly.<br/>      <code class="code">close</code> returns the result of the close function of the
      channel. Multiple calls to <code class="code">close</code> will return exactly the same
      value.<br/>      Note: you cannot use <code class="code">close</code> on channel obtained with an
       <a href="#atomic">atomic</a>.</div></div>
<pre><span class="VALabort"><span class="keyword">val</span> abort</span> : <code class="type">'a <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a> -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">abort ch</code> abort current operations and close the channel
      immediatly.</div></div>
<pre><span class="VALatomic"><span class="keyword">val</span> atomic</span> : <code class="type">('a <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a> -&gt; 'b <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a>) -&gt; 'a <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a> -&gt; 'b <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">atomic f</code> transforms a sequence of io operations into one
      single atomic io operation.<br/>      Note:<ul><li>the channel passed to <code class="code">f</code> is invalid after <code class="code">f</code> terminates</li><li><code class="code">atomic</code> can be called inside another <code class="code">atomic</code> </li></ul></div></div>
<pre><span class="VALfile_length"><span class="keyword">val</span> file_length</span> : <code class="type">string -&gt; int64 <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info">Returns the length of a file</div></div>
<pre><span class="VALbuffered"><span class="keyword">val</span> buffered</span> : <code class="type">'a <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">buffered oc</code> returns the number of bytes in the buffer</div></div>
<pre><span class="VALflush"><span class="keyword">val</span> flush</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">flush oc</code> performs all pending writes on <code class="code">oc</code></div></div>
<pre><span class="VALflush_all"><span class="keyword">val</span> flush_all</span> : <code class="type">unit -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">flush_all ()</code> flushes all open output channels</div></div>
<pre><span class="VALbuffer_size"><span class="keyword">val</span> buffer_size</span> : <code class="type">'a <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a> -&gt; int</code></pre><div class="info"><div class="info">Returns the size of the internal buffer.</div></div>
<pre><span class="VALresize_buffer"><span class="keyword">val</span> resize_buffer</span> : <code class="type">'a <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a> -&gt; int -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info">Resize the internal buffer to the given size</div></div>
<pre><span class="VALis_busy"><span class="keyword">val</span> is_busy</span> : <code class="type">'a <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a> -&gt; bool</code></pre><div class="info"><div class="info"><code class="code">is_busy channel</code> returns whether the given channel is currently
      busy. A channel is busy when there is at least one job using it
      that has not yet terminated.</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Random access</h6></div></div>
<pre><span class="VALposition"><span class="keyword">val</span> position</span> : <code class="type">'a <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a> -&gt; int64</code></pre><div class="info"><div class="info"><code class="code">position ch</code> Returns the current position in the channel.</div></div>
<pre><span class="VALset_position"><span class="keyword">val</span> set_position</span> : <code class="type">'a <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a> -&gt; int64 -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">set_position ch pos</code> Sets the position in the output channel. This
      does not work if the channel do not support random access.</div></div>
<pre><span class="VALlength"><span class="keyword">val</span> length</span> : <code class="type">'a <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a> -&gt; int64 <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info">Returns the length of the channel in bytes</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Reading</h6></div></div>
<div class="info"><div class="info">Note: except for functions dealing with streams ( <a href="#read_chars">read_chars</a> and
     <a href="#read_lines">read_lines</a>) all functions are <b>atomic</b>.</div></div>
<pre><span class="VALread_char"><span class="keyword">val</span> read_char</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=input_channel">input_channel</a> -&gt; char <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">read_char ic</code> reads the next character of <code class="code">ic</code>. <b>Raises</b> <code>End_of_file</code> if the end of the file is reached<br/></div></div>
<pre><span class="VALread_char_opt"><span class="keyword">val</span> read_char_opt</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=input_channel">input_channel</a> -&gt; char option <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info">Same as  <a href="#read_byte">read_byte</a> but does not raises <code class="code">End_of_file</code> on end of
      input</div></div>
<pre><span class="VALread_chars"><span class="keyword">val</span> read_chars</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=input_channel">input_channel</a> -&gt; char <a href="?package=lwt&amp;module=Lwt_stream&amp;type=t">Lwt_stream.t</a></code></pre><div class="info"><div class="info"><code class="code">read_chars ic</code> returns a stream holding all characters of
      <code class="code">ic</code></div></div>
<pre><span class="VALread_line"><span class="keyword">val</span> read_line</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=input_channel">input_channel</a> -&gt; string <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">read_line ic</code> reads one complete line from <code class="code">ic</code> and returns it
      without the end of line. End of line is either <code class="code">&quot;\n&quot;</code> or
      <code class="code">&quot;\r\n&quot;</code>.<br/>      If the end of line is reached before reading any character,
      <code class="code">End_of_file</code> is raised. If it is reached before reading an end
      of line but characters have already been read, they are
      returned.</div></div>
<pre><span class="VALread_line_opt"><span class="keyword">val</span> read_line_opt</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=input_channel">input_channel</a> -&gt; string option <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info">Same as  <a href="#read_line">read_line</a> but do not raise <code class="code">End_of_file</code> on end of
      input.</div></div>
<pre><span class="VALread_lines"><span class="keyword">val</span> read_lines</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=input_channel">input_channel</a> -&gt; string <a href="?package=lwt&amp;module=Lwt_stream&amp;type=t">Lwt_stream.t</a></code></pre><div class="info"><div class="info"><code class="code">read_lines ic</code> returns a stream holding all lines of <code class="code">ic</code></div></div>
<pre><span class="VALread"><span class="keyword">val</span> read</span> : <code class="type">?count:int -&gt; <a href="?package=lwt&amp;module=Lwt_io&amp;type=input_channel">input_channel</a> -&gt; string <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">read ?count ic</code> reads at most <code class="code">len</code> characters from <code class="code">ic</code>. It
      returns <code class="code">&quot;&quot;</code> if the end of input is reached. If <code class="code">count</code> is not
      specified, it reads all bytes until the end of input.</div></div>
<pre><span class="VALread_into"><span class="keyword">val</span> read_into</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=input_channel">input_channel</a> -&gt; string -&gt; int -&gt; int -&gt; int <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">read_into ic buffer offset length</code> reads up to <code class="code">length</code> bytes,
      stores them in <code class="code">buffer</code> at offset <code class="code">offset</code>, and returns the
      number of bytes read.<br/>      Note: <code class="code">read_into</code> does not raise <code class="code">End_of_file</code>, it returns a
      length of <code class="code">0</code> instead.</div></div>
<pre><span class="VALread_into_exactly"><span class="keyword">val</span> read_into_exactly</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=input_channel">input_channel</a> -&gt; string -&gt; int -&gt; int -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">read_into_exactly ic buffer offset length</code> reads exactly
      <code class="code">length</code> bytes and stores them in <code class="code">buffer</code> at offset <code class="code">offset</code>. <b>Raises</b> <code>End_of_file</code> on end of input<br/></div></div>
<pre><span class="VALread_value"><span class="keyword">val</span> read_value</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=input_channel">input_channel</a> -&gt; 'a <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">read_value ic</code> reads a marshaled value from <code class="code">ic</code></div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Writing</h6></div></div>
<div class="info"><div class="info">Note: as for reading functions, all functions except
     <a href="#write_chars">write_chars</a> and  <a href="#write_lines">write_lines</a> are <b>atomic</b>.<br/>    For example if you use  <a href="#write_line">write_line</a> in to different threads, the
    two operations will be serialized, and lines cannot be mixed.</div></div>
<pre><span class="VALwrite_char"><span class="keyword">val</span> write_char</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; char -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">write_char oc char</code> writes <code class="code">char</code> on <code class="code">oc</code></div></div>
<pre><span class="VALwrite_chars"><span class="keyword">val</span> write_chars</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; char <a href="?package=lwt&amp;module=Lwt_stream&amp;type=t">Lwt_stream.t</a> -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">write_chars oc chars</code> writes all characters of <code class="code">chars</code> on
      <code class="code">oc</code></div></div>
<pre><span class="VALwrite"><span class="keyword">val</span> write</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; string -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">write oc str</code> writes all characters of <code class="code">str</code> on <code class="code">oc</code></div></div>
<pre><span class="VALwrite_line"><span class="keyword">val</span> write_line</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; string -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">write_line oc str</code> writes <code class="code">str</code> on <code class="code">oc</code> followed by a
      new-line.</div></div>
<pre><span class="VALwrite_lines"><span class="keyword">val</span> write_lines</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; string <a href="?package=lwt&amp;module=Lwt_stream&amp;type=t">Lwt_stream.t</a> -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">write_lines oc lines</code> writes all lines of <code class="code">lines</code> to <code class="code">oc</code></div></div>
<pre><span class="VALwrite_from"><span class="keyword">val</span> write_from</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; string -&gt; int -&gt; int -&gt; int <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">write_from oc buffer offset length</code> writes up to <code class="code">length</code> bytes
      to <code class="code">oc</code>, from <code class="code">buffer</code> at offset <code class="code">offset</code> and returns the number
      of bytes actually written</div></div>
<pre><span class="VALwrite_from_exactly"><span class="keyword">val</span> write_from_exactly</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; string -&gt; int -&gt; int -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">write_from_exactly oc buffer offset length</code> writes all <code class="code">length</code>
      bytes from <code class="code">buffer</code> at offset <code class="code">offset</code> to <code class="code">oc</code></div></div>
<pre><span class="VALwrite_value"><span class="keyword">val</span> write_value</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; ?flags:<a href="?package=ocaml&amp;module=Marshal&amp;type=extern_flags">Marshal.extern_flags</a> list -&gt; 'a -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">write_value oc ?flags x</code> marshals the value <code class="code">x</code> to <code class="code">oc</code></div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Printing</h6></div></div>
<div class="info"><div class="info">These functions are basically helpers. Also you may prefer the
    using the name  <a href="#printl">printl</a> rather than  <a href="#write_line">write_line</a> because it is
    shorter.<br/>    The general name of a printing function is <code class="code">&lt;prefix&gt;print&lt;suffixes&gt;</code>.<br/>    Where <code class="code">&lt;prefix&gt;</code> is one of:<ul><li><code class="code">'f'</code>, which means that the function takes as argument a channel</li><li>nothing, which means that the function prints on  <a href="#stdout">stdout</a></li><li><code class="code">'e'</code>, which means that the function prints on  <a href="#stderr">stderr</a></li></ul>    and <code class="code">&lt;suffixes&gt;</code> is a combination of:<ul><li><code class="code">'l'</code> which means that a new-line character is printed after the message</li><li><code class="code">'f'</code> which means that the function takes as argument a <b>format</b> instead
    of a string
</li></ul></div></div>
<pre><span class="VALfprint"><span class="keyword">val</span> fprint</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; string -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre>
<pre><span class="VALfprintl"><span class="keyword">val</span> fprintl</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; string -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre>
<pre><span class="VALfprintf"><span class="keyword">val</span> fprintf</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; ('a, unit, string, unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a>) <a href="?package=ocaml&amp;module=Pervasives&amp;type=format4">Pervasives.format4</a> -&gt; 'a</code></pre>
<pre><span class="VALfprintlf"><span class="keyword">val</span> fprintlf</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; ('a, unit, string, unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a>) <a href="?package=ocaml&amp;module=Pervasives&amp;type=format4">Pervasives.format4</a> -&gt; 'a</code></pre>
<pre><span class="VALprint"><span class="keyword">val</span> print</span> : <code class="type">string -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre>
<pre><span class="VALprintl"><span class="keyword">val</span> printl</span> : <code class="type">string -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre>
<pre><span class="VALprintf"><span class="keyword">val</span> printf</span> : <code class="type">('a, unit, string, unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a>) <a href="?package=ocaml&amp;module=Pervasives&amp;type=format4">Pervasives.format4</a> -&gt; 'a</code></pre>
<pre><span class="VALprintlf"><span class="keyword">val</span> printlf</span> : <code class="type">('a, unit, string, unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a>) <a href="?package=ocaml&amp;module=Pervasives&amp;type=format4">Pervasives.format4</a> -&gt; 'a</code></pre>
<pre><span class="VALeprint"><span class="keyword">val</span> eprint</span> : <code class="type">string -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre>
<pre><span class="VALeprintl"><span class="keyword">val</span> eprintl</span> : <code class="type">string -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre>
<pre><span class="VALeprintf"><span class="keyword">val</span> eprintf</span> : <code class="type">('a, unit, string, unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a>) <a href="?package=ocaml&amp;module=Pervasives&amp;type=format4">Pervasives.format4</a> -&gt; 'a</code></pre>
<pre><span class="VALeprintlf"><span class="keyword">val</span> eprintlf</span> : <code class="type">('a, unit, string, unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a>) <a href="?package=ocaml&amp;module=Pervasives&amp;type=format4">Pervasives.format4</a> -&gt; 'a</code></pre>
<div class="info"><div class="info"><h6 id="6_TITLE">Utilities</h6></div></div>
<pre><span class="VALhexdump_stream"><span class="keyword">val</span> hexdump_stream</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; char <a href="?package=lwt&amp;module=Lwt_stream&amp;type=t">Lwt_stream.t</a> -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">hexdump_stream oc byte_stream</code> produces the same output as the
      command <code class="code">hexdump -C</code>.</div></div>
<pre><span class="VALhexdump"><span class="keyword">val</span> hexdump</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; string -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">hexdump oc str = hexdump_stream oc (Lwt_stream.of_string str)</code></div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">File utilities</h6></div></div>
<pre><span class="TYPEfile_name"><span class="keyword">type</span> file_name</span> = <code class="type">string</code></pre><div class="info"><div class="info">Type of file names</div></div>
<pre><span class="VALopen_file"><span class="keyword">val</span> open_file</span> : <code class="type">?buffer_size:int -&gt;
?flags:<a href="?package=ocaml&amp;module=Unix&amp;type=open_flag">Unix.open_flag</a> list -&gt;
?perm:<a href="?package=ocaml&amp;module=Unix&amp;type=file_perm">Unix.file_perm</a> -&gt; mode:'a <a href="?package=lwt&amp;module=Lwt_io&amp;type=mode">mode</a> -&gt; <a href="?package=lwt&amp;module=Lwt_io&amp;type=file_name">file_name</a> -&gt; 'a <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a> <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">open_file ?buffer_size ?flags ?perm ~mode filename</code> open the
      file with name <code class="code">filename</code> and returns a channel for
      reading/writing it. <b>Raises</b> <code>Unix.Unix_error</code> on error.<br/></div></div>
<pre><span class="VALwith_file"><span class="keyword">val</span> with_file</span> : <code class="type">?buffer_size:int -&gt;
?flags:<a href="?package=ocaml&amp;module=Unix&amp;type=open_flag">Unix.open_flag</a> list -&gt;
?perm:<a href="?package=ocaml&amp;module=Unix&amp;type=file_perm">Unix.file_perm</a> -&gt;
mode:'a <a href="?package=lwt&amp;module=Lwt_io&amp;type=mode">mode</a> -&gt; <a href="?package=lwt&amp;module=Lwt_io&amp;type=file_name">file_name</a> -&gt; ('a <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a> -&gt; 'b <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a>) -&gt; 'b <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">with_file ?buffer_size ?flags ?perm ~mode filename f</code> open a
      file and passes the channel to <code class="code">f</code>. It is ensured that the
      channel is closed when <code class="code">f ch</code> terminates (even if it fails).</div></div>
<pre><span class="VALopen_connection"><span class="keyword">val</span> open_connection</span> : <code class="type">?buffer_size:int -&gt; <a href="?package=ocaml&amp;module=Unix&amp;type=sockaddr">Unix.sockaddr</a> -&gt; (<a href="?package=lwt&amp;module=Lwt_io&amp;type=input_channel">input_channel</a> * <a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a>) <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">open_connection ?buffer_size addr</code> open a connection to
      the given address and returns two channels for using it.<br/>      The connection is completly closed when you close both
      channels. <b>Raises</b> <code>Unix.Unix_error</code> on error.<br/></div></div>
<pre><span class="VALwith_connection"><span class="keyword">val</span> with_connection</span> : <code class="type">?buffer_size:int -&gt;
<a href="?package=ocaml&amp;module=Unix&amp;type=sockaddr">Unix.sockaddr</a> -&gt; (<a href="?package=lwt&amp;module=Lwt_io&amp;type=input_channel">input_channel</a> * <a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; 'a <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a>) -&gt; 'a <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">with_connection ?buffer_size addr f</code> open a connection to
      the given address and passes the channels to <code class="code">f</code></div></div>
<pre><span class="TYPEserver"><span class="keyword">type</span> server</span> </pre><div class="info"><div class="info">Type of a server</div></div>
<pre><span class="VALestablish_server"><span class="keyword">val</span> establish_server</span> : <code class="type">?buffer_size:int -&gt;
?backlog:int -&gt;
<a href="?package=ocaml&amp;module=Unix&amp;type=sockaddr">Unix.sockaddr</a> -&gt; (<a href="?package=lwt&amp;module=Lwt_io&amp;type=input_channel">input_channel</a> * <a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; unit) -&gt; <a href="?package=lwt&amp;module=Lwt_io&amp;type=server">server</a></code></pre><div class="info"><div class="info"><code class="code">establich_server ?buffer_size ?backlog sockaddr f</code> creates a
      server which will listen for incomming connections. New
      connections are passed to <code class="code">f</code>. Note that <code class="code">f</code> must not raise any
      exception.<br/>      <code class="code">backlog</code> is the argument passed to <code class="code">Lwt_unix.listen</code></div></div>
<pre><span class="VALshutdown_server"><span class="keyword">val</span> shutdown_server</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=server">server</a> -&gt; unit</code></pre><div class="info"><div class="info">Shutdown the given server</div></div>
<pre><span class="VALlines_of_file"><span class="keyword">val</span> lines_of_file</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=file_name">file_name</a> -&gt; string <a href="?package=lwt&amp;module=Lwt_stream&amp;type=t">Lwt_stream.t</a></code></pre><div class="info"><div class="info"><code class="code">lines_of_file name</code> returns a stream of all lines of the file
      with name <code class="code">name</code>. The file is automatically closed when all
      lines have been read.</div></div>
<pre><span class="VALlines_to_file"><span class="keyword">val</span> lines_to_file</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=file_name">file_name</a> -&gt; string <a href="?package=lwt&amp;module=Lwt_stream&amp;type=t">Lwt_stream.t</a> -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">lines_to_file name lines</code> writes all lines of <code class="code">lines</code> to
      <code class="code">files</code></div></div>
<pre><span class="VALchars_of_file"><span class="keyword">val</span> chars_of_file</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=file_name">file_name</a> -&gt; char <a href="?package=lwt&amp;module=Lwt_stream&amp;type=t">Lwt_stream.t</a></code></pre><div class="info"><div class="info"><code class="code">chars_of_file name</code> returns a stream of all characters of the
      file with name <code class="code">name</code>. As for  <a href="#lines_of_file">lines_of_file</a> the file is
      closed when all characters have been read.</div></div>
<pre><span class="VALchars_to_file"><span class="keyword">val</span> chars_to_file</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=file_name">file_name</a> -&gt; char <a href="?package=lwt&amp;module=Lwt_stream&amp;type=t">Lwt_stream.t</a> -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">chars_to_file name chars</code> writes all characters of <code class="code">chars</code> to
      <code class="code">name</code></div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Input/output of integers</h6></div></div>
<div class="ocaml_module sig" name="NumberIO"><pre><span class="keyword">module type</span> <a href="?package=lwt&amp;module=Lwt_io.NumberIO">NumberIO</a> = <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="info"><div class="info">Common interface for reading/writing integers in binary</div></div><div class="ocaml_module_content">
<div class="info"><div class="info"><div class="h8">Reading</div></div></div>
<pre><span class="VALread_int"><span class="keyword">val</span> read_int</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=input_channel">input_channel</a> -&gt; int <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info">Reads a 32-bits integer as an ocaml int</div></div>
<pre><span class="VALread_int16"><span class="keyword">val</span> read_int16</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=input_channel">input_channel</a> -&gt; int <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre>
<pre><span class="VALread_int32"><span class="keyword">val</span> read_int32</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=input_channel">input_channel</a> -&gt; int32 <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre>
<pre><span class="VALread_int64"><span class="keyword">val</span> read_int64</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=input_channel">input_channel</a> -&gt; int64 <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre>
<pre><span class="VALread_float32"><span class="keyword">val</span> read_float32</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=input_channel">input_channel</a> -&gt; float <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info">Reads an IEEE single precision floating point value</div></div>
<pre><span class="VALread_float64"><span class="keyword">val</span> read_float64</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=input_channel">input_channel</a> -&gt; float <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info">Reads an IEEE double precision floating point value</div></div>
<div class="info"><div class="info"><div class="h8">Writing</div></div></div>
<pre><span class="VALwrite_int"><span class="keyword">val</span> write_int</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; int -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info">Writes an ocaml int as a 32-bits integer</div></div>
<pre><span class="VALwrite_int16"><span class="keyword">val</span> write_int16</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; int -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre>
<pre><span class="VALwrite_int32"><span class="keyword">val</span> write_int32</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; int32 -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre>
<pre><span class="VALwrite_int64"><span class="keyword">val</span> write_int64</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; int64 -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre>
<pre><span class="VALwrite_float32"><span class="keyword">val</span> write_float32</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; float -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info">Writes an IEEE single precision floating point value</div></div>
<pre><span class="VALwrite_float64"><span class="keyword">val</span> write_float64</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=output_channel">output_channel</a> -&gt; float -&gt; unit <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info">Writes an IEEE double precision floating point value</div></div></div></div>
<div class="ocaml_module ident" name="LE" path="?package=lwt&amp;module=Lwt_io.NumberIO"><pre><span class="keyword">module</span> <a href="?package=lwt&amp;module=Lwt_io.LE">LE</a> : <code class="type"><code class="code"><a href="?package=lwt&amp;module=Lwt_io.NumberIO">NumberIO</a></code></code></pre><div class="info"><div class="info">Reading/writing of numbers in little-endian</div></div></div>
<div class="ocaml_module ident" name="BE" path="?package=lwt&amp;module=Lwt_io.NumberIO"><pre><span class="keyword">module</span> <a href="?package=lwt&amp;module=Lwt_io.BE">BE</a> : <code class="type"><code class="code"><a href="?package=lwt&amp;module=Lwt_io.NumberIO">NumberIO</a></code></code></pre><div class="info"><div class="info">Reading/writing of numbers in big-endian</div></div></div>
<div class="ocaml_include ident" path="?package=lwt&amp;module=Lwt_io.NumberIO" items="[]"><pre><span class="keyword">include</span> <code class="type"><code class="code"><a href="?package=lwt&amp;module=Lwt_io.NumberIO">NumberIO</a></code></code></pre><div class="info"><div class="info">Reading/writing of numbers in the system endianness.</div></div></div>
<pre><span class="TYPEbyte_order"><span class="keyword">type</span> byte_order</span> = <code class="type"><a href="?package=lwt&amp;module=Lwt_sys&amp;type=byte_order">Lwt_sys.byte_order</a></code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTbyte_order.Little_endian"><span class="constructor">Little_endian</span></span></code></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTbyte_order.Big_endian"><span class="constructor">Big_endian</span></span></code></td><td class="typefieldcomment" align="left"><div class="info">Type of byte order</div></td></tr></table>
<pre><span class="VALsystem_byte_order"><span class="keyword">val</span> system_byte_order</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_io&amp;type=byte_order">byte_order</a></code></pre><div class="info"><div class="info">Same as  <a href="#Lwt_sys.byte_order">Lwt_sys.byte_order</a>.</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Low-level access to the internal buffer</h6></div></div>
<pre><span class="VALblock"><span class="keyword">val</span> block</span> : <code class="type">'a <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a> -&gt; int -&gt; (<a href="?package=lwt&amp;module=Lwt_bytes&amp;type=t">Lwt_bytes.t</a> -&gt; int -&gt; 'b <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a>) -&gt; 'b <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">block ch size f</code> pass to <code class="code">f</code> the internal buffer and an
      offset. The buffer contains <code class="code">size</code> chars at <code class="code">offset</code>. <code class="code">f</code> may
      reads or writes these chars.  <code class="code">size</code> must verify <code class="code">0 &lt;= size &lt;=
      16</code></div></div>
<pre><code><span class="TYPEdirect_access"><span class="keyword">type</span> direct_access</span> = {</code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTdirect_access.da_buffer">da_buffer</span> : <code class="type"><a href="?package=lwt&amp;module=Lwt_bytes&amp;type=t">Lwt_bytes.t</a></code>;</code></td><td class="typefieldcomment" align="left"><div class="info">The internal buffer</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTdirect_access.da_ptr">da_ptr</span> : <code class="type">int</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">The pointer to:<ul><li>the beginning of free space for output channels</li><li>the beginning of data for input channels </li></ul></div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="keyword">mutable</span> <span class="TYPEELTdirect_access.da_max">da_max</span> : <code class="type">int</code>;</code></td><td class="typefieldcomment" align="left"><div class="info">The maximum offset</div></td></tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code><span class="TYPEELTdirect_access.da_perform">da_perform</span> : <code class="type">unit -&gt; int <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code>;</code></td><td class="typefieldcomment" align="left"><div class="info">- for input channels:
        refill the buffer and returns how many bytes have been read<ul><li>for output channels:
        flush partially the buffer and returns how many bytes have been written </li></ul></div></td></tr><tr><td>}</td></tr></table><div class="info"><div class="info">Informations for accessing directly to the internal buffer of a
    channel</div></div>
<pre><span class="VALdirect_access"><span class="keyword">val</span> direct_access</span> : <code class="type">'a <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a> -&gt; (<a href="?package=lwt&amp;module=Lwt_io&amp;type=direct_access">direct_access</a> -&gt; 'b <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a>) -&gt; 'b <a href="?package=lwt&amp;module=Lwt&amp;type=t">Lwt.t</a></code></pre><div class="info"><div class="info"><code class="code">direct_access ch f</code> pass to <code class="code">f</code> a  <a href="#direct_access">direct_access</a>
      structure. <code class="code">f</code> must use it and update <code class="code">da_ptr</code> to reflect how
      many bytes have been read/written.</div></div>
<div class="info"><div class="info"><h6 id="6_TITLE">Misc</h6></div></div>
<pre><span class="VALdefault_buffer_size"><span class="keyword">val</span> default_buffer_size</span> : <code class="type">unit -&gt; int</code></pre><div class="info"><div class="info">Return the default size for buffers. Channels that are created
      without specific size use this one.</div></div>
<pre><span class="VALset_default_buffer_size"><span class="keyword">val</span> set_default_buffer_size</span> : <code class="type">int -&gt; unit</code></pre><div class="info"><div class="info">Change the default buffer size. <b>Raises</b> <code>Invalid_argument</code> if the given size is smaller than <code class="code">16</code>
      or greater than <code class="code">Sys.max_string_length</code><br/></div></div>
<pre><span class="VALof_string"><span class="keyword">val</span> of_string</span> : <code class="type">mode:'mode <a href="?package=lwt&amp;module=Lwt_io&amp;type=mode">mode</a> -&gt; string -&gt; 'mode <a href="?package=lwt&amp;module=Lwt_io&amp;type=channel">channel</a></code></pre>
</div>