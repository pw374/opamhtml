<div class="ocaml_toplevel_module"><div class="ocaml_module sig" name="Error"><pre><span class="keyword">module</span> <a href="?package=async_extra&amp;module=File_tail.Error">Error</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><code><span class="TYPEt"><span class="keyword">type</span> t</span> = </code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.File_replaced"><span class="constructor">File_replaced</span></span></code></td><td class="typefieldcomment" align="left"><div class="info"><code class="code">File_shrank</code> occurs if <code class="code">stat</code> detects that the length of the file decreases from
      one call to the next.</div></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.File_shrank"><span class="constructor">File_shrank</span></span></code></td><td class="typefieldcomment" align="left"><div class="info"><code class="code">Read_failed</code> occurs if some aspect of the open-seek-read-close used to get data
      fails.</div></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.Read_failed"><span class="constructor">Read_failed</span></span> <span class="keyword">of</span> <code class="type">exn</code></code></td><td class="typefieldcomment" align="left"><div class="info"><code class="code">Stat_failed</code> occurs if <code class="code">stat</code> fails.</div></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.Stat_failed"><span class="constructor">Stat_failed</span></span> <span class="keyword">of</span> <code class="type">exn</code></code></td></tr></table>
<pre><span class="VALto_string_hum"><span class="keyword">val</span> to_string_hum</span> : <code class="type"><a href="?package=async_extra&amp;module=File_tail.Error&amp;type=t">t</a> -&gt; string</code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type"><a href="?package=async_extra&amp;module=File_tail.Error&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre></div></div>
<div class="ocaml_module sig" name="Warning"><pre><span class="keyword">module</span> <a href="?package=async_extra&amp;module=File_tail.Warning">Warning</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><code><span class="TYPEt"><span class="keyword">type</span> t</span> = </code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.Did_not_reach_eof_for"><span class="constructor">Did_not_reach_eof_for</span></span> <span class="keyword">of</span> <code class="type"><a href="?package=core&amp;module=Std.Time.Span&amp;type=t">Core.Std.Time.Span.t</a></code></code></td><td class="typefieldcomment" align="left"><div class="info"><code class="code">Reached_eof</code> occurs whenever the file tail reaches the end of file, irrespective of
      whether there has previously been a <code class="code">Did_not_reach_eof_for</code> warning.</div></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.Reached_eof"><span class="constructor">Reached_eof</span></span></code></td><td class="typefieldcomment" align="left"><div class="info"><code class="code">Delayed_due_to_null_reads_for span</code> occurs when the file tail is unable to get data
      from the file, because the data being read has null ('\000') characters.  The span
      is how long it has been attempting to read and been getting nulls.  This warning
      will only occur if <code class="code">retry_null_reads = true</code>.  This warning will be repeated until
      the null reads stop.</div></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.Delayed_due_to_null_reads_for"><span class="constructor">Delayed_due_to_null_reads_for</span></span> <span class="keyword">of</span> <code class="type"><a href="?package=core&amp;module=Std.Time.Span&amp;type=t">Core.Std.Time.Span.t</a></code></code></td><td class="typefieldcomment" align="left"><div class="info"><code class="code">No_longer_delayed_due_to_null_reads</code> occurs after a nonempty sequence of
      <code class="code">Delayed_due_to_null_reads_for</code> warnings, once the file tail gets a read that does
      not contain null reads.</div></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.No_longer_delayed_due_to_null_reads"><span class="constructor">No_longer_delayed_due_to_null_reads</span></span></code></td></tr></table>
<pre><span class="VALto_string_hum"><span class="keyword">val</span> to_string_hum</span> : <code class="type"><a href="?package=async_extra&amp;module=File_tail.Warning&amp;type=t">t</a> -&gt; string</code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type"><a href="?package=async_extra&amp;module=File_tail.Warning&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre></div></div>
<div class="ocaml_module sig" name="Update"><pre><span class="keyword">module</span> <a href="?package=async_extra&amp;module=File_tail.Update">Update</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_module_content">
<pre><code><span class="TYPEt"><span class="keyword">type</span> t</span> = </code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.Data"><span class="constructor">Data</span></span> <span class="keyword">of</span> <code class="type">string</code></code></td><td class="typefieldcomment" align="left"><div class="info">Warnings do not close the stream and whatever is reading can keep on doing so.
      The <code class="code">string</code> is the file name.</div></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.Warning"><span class="constructor">Warning</span></span> <span class="keyword">of</span> <code class="type">string * <a href="?package=async_extra&amp;module=File_tail.Warning&amp;type=t">Warning.t</a></code></code></td><td class="typefieldcomment" align="left"><div class="info">Errors cause the stream to be closed.  The <code class="code">string</code> is the file name.</div></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.Error"><span class="constructor">Error</span></span> <span class="keyword">of</span> <code class="type">string * <a href="?package=async_extra&amp;module=File_tail.Error&amp;type=t">Error.t</a></code></code></td></tr></table>
<pre><span class="VALto_string_hum"><span class="keyword">val</span> to_string_hum</span> : <code class="type"><a href="?package=async_extra&amp;module=File_tail.Update&amp;type=t">t</a> -&gt; string</code></pre>
<pre><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type"><a href="?package=async_extra&amp;module=File_tail.Update&amp;type=t">t</a> -&gt; <a href="?package=sexplib&amp;module=Sexp&amp;type=t">Sexplib.Sexp.t</a></code></pre></div></div>
<pre><span class="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">?read_buf_len:int -&gt;
?read_delay:<a href="?package=core&amp;module=Std.Time.Span&amp;type=t">Core.Std.Time.Span.t</a> -&gt;
?retry_null_reads:bool -&gt;
?break_on_lines:bool -&gt;
?ignore_inode_change:bool -&gt;
?start_at:[ `Beginning | `End | `Pos of <a href="?package=core&amp;module=Std.Int64&amp;type=t">Core.Std.Int64.t</a> ] -&gt;
?eof_latency_tolerance:<a href="?package=core&amp;module=Std.Time.Span&amp;type=t">Core.Std.Time.Span.t</a> -&gt;
?null_read_tolerance:<a href="?package=core&amp;module=Std.Time.Span&amp;type=t">Core.Std.Time.Span.t</a> -&gt;
string -&gt; <a href="?package=async_extra&amp;module=File_tail.Update&amp;type=t">Update.t</a> <a href="?package=async_extra&amp;module=Import.Pipe.Reader&amp;type=t">Import.Pipe.Reader.t</a></code></pre><div class="info"><div class="info"><code class="code">create file</code> creates a <code class="code">File_tail.t</code> that will immediately begin reading <code class="code">file</code>, and
    then will start the stat-read loop.<br/>    <code class="code">read_buf_len</code> sets the size of the internal buffer used for making read system calls.<br/>    <code class="code">read_delay</code> sets how long the stat-read loop waits each time after it reaches eof
    before stat'ing again.  Setting <code class="code">read_delay</code> too low could cause unecessary load.<br/>    If <code class="code">retry_null_reads = true</code>, then reads that return data with null ('\000')
    characters are ignored and cause the system to delay 0.2s and attempt the read again.
    If <code class="code">retry_null_reads = false</code>, then the file tail will process data with nulls just as
    it would any other data.<br/>    If <code class="code">break_on_lines = true</code>, the file tail will break data into lines on '\n'.  If not,
    the fill tail will return chunks of data from the end of the file as they are
    available.<br/>    If <code class="code">ignore_inode_change = true</code>, the file tail will silently press on when the
    <code class="code">file</code>'s inode changes.  If not, an inode change will cause the file tail to report an
    error and stop.  CIFS changes inodes of mounted files few times a day and we need
    <code class="code">ignore_inode_change = true</code> option to keep tailers watching files on it alive.<br/>    <code class="code">start_at</code> determines the file position at which the file tail starts.<br/>    <code class="code">eof_latency_tolerance</code> affects the <code class="code">Did_not_reach_eof_for</code> warning.<br/>    <code class="code">null_read_tolerance</code> determines how long the tailing must observe null reads
    before it will report a <code class="code">Delayed_due_to_null_reads_for</code> warning.</div></div>
</div>