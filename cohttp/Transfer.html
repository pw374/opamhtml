<div class="ocaml_toplevel_module"><div class="info">Module to read and write the HTTP/1.1 transfer-encoding formats.
 Currently supported are <code class="code">chunked</code> and <code class="code">content-length</code>.</div>
<pre><code><span class="TYPEencoding"><span class="keyword">type</span> encoding</span> = </code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTencoding.Chunked"><span class="constructor">Chunked</span></span></code></td><td class="typefieldcomment" align="left"><div class="info">dynamic chunked encoding</div></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTencoding.Fixed"><span class="constructor">Fixed</span></span> <span class="keyword">of</span> <code class="type">int</code></code></td><td class="typefieldcomment" align="left"><div class="info">fixed size content</div></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTencoding.Unknown"><span class="constructor">Unknown</span></span></code></td><td class="typefieldcomment" align="left"><div class="info">unknown body size, which leads to best-effort</div></td></tr></table><div class="info"><div class="info">The encoding format detected from the <code class="code">transfer-encoding</code> and
 <code class="code">content-length</code> headers</div></div>
<pre><code><span class="TYPEchunk"><span class="keyword">type</span> chunk</span> = </code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTchunk.Chunk"><span class="constructor">Chunk</span></span> <span class="keyword">of</span> <code class="type">string</code></code></td><td class="typefieldcomment" align="left"><div class="info">chunk of data and not the end of stream</div></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTchunk.Final_chunk"><span class="constructor">Final_chunk</span></span> <span class="keyword">of</span> <code class="type">string</code></code></td><td class="typefieldcomment" align="left"><div class="info">the last chunk of data, so no more should be read</div></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTchunk.Done"><span class="constructor">Done</span></span></code></td><td class="typefieldcomment" align="left"><div class="info">no more body data is present</div></td></tr></table><div class="info"><div class="info">A chunk of body that also signals if there to more to arrive</div></div>
<pre><span class="VALencoding_to_string"><span class="keyword">val</span> encoding_to_string</span> : <code class="type"><a href="?package=cohttp&amp;module=Transfer&amp;type=encoding">encoding</a> -&gt; string</code></pre><div class="info"><div class="info">Convert the encoding format to a human-readable string</div></div>
<pre><span class="VALhas_body"><span class="keyword">val</span> has_body</span> : <code class="type"><a href="?package=cohttp&amp;module=Transfer&amp;type=encoding">encoding</a> -&gt; bool</code></pre>
</div>