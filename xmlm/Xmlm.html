<div class="ocaml_toplevel_module"><div class="info">Streaming XML IO.  <p>    A well-formed sequence of  <a href="#TYPEsignal">signals</a> represents an
     <a href="http://www.w3.org/TR/REC-xml">XML</a> document tree traversal in
    depth first order (this has nothing to do with XML
    well-formedness). Input pulls a well-formed sequence of signals
    from a data source and output pushes a well-formed sequence of
    signals to a data destination. Functions are provided to easily 
    transform sequences of signals to/from arborescent data structures.</p><p>    Consult the  <a href="#io">features and limitations</a> and  <a href="#ex">examples</a> 
    of use.</p><p>    <em>Release 1.1.1 - Daniel BÃ¼nzli &lt;daniel.buenzli at erratique.ch&gt; </em></p><p>    </p><h3 id="3_TITLE">References</h3>
    <ul><li>Tim Bray et al. 
    <em> <a href="http://www.w3.org/TR/xml-names11">Namespaces in XML 1.1 (2nd ed.)</a></em>,
    2006.</li><li>Tim Bray. 
    <em> <a href="http://www.xml.com/axml/axml.html">The annotated XML Specification</a></em>, 
    1998.</li></ul></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Basic types and values</h1></div></div>
<pre><span class="TYPEencoding"><span class="keyword">type</span> encoding</span> = <code class="type">[ `ISO_8859_1 | `US_ASCII | `UTF_16 | `UTF_16BE | `UTF_16LE | `UTF_8 ]</code></pre><div class="info"><div class="info">The type for character encodings. For <code class="code">`UTF_16</code>, endianness is
    determined from the 
     <a href="http://www.unicode.org/unicode/faq/utf_bom.html#BOM">BOM</a>.</div></div>
<pre><span class="TYPEdtd"><span class="keyword">type</span> dtd</span> = <code class="type">string option</code></pre><div class="info"><div class="info">The type for the optional
     <a href="http://www.w3.org/TR/REC-xml/#dt-doctype">DTD</a>.</div></div>
<pre><span class="TYPEname"><span class="keyword">type</span> name</span> = <code class="type">string * string</code></pre><div class="info"><div class="info">The type for attribute and element's
     <a href="http://www.w3.org/TR/xml-names11/#dt-expname">expanded names</a> 
    <code class="code">(uri,local)</code>. An empty <code class="code">uri</code> represents a name without a
    namespace name, i.e. an unprefixed name 
    that is not under the scope of a default namespace.</div></div>
<pre><span class="TYPEattribute"><span class="keyword">type</span> attribute</span> = <code class="type"><a href="?package=xmlm&amp;module=Xmlm&amp;type=name">name</a> * string</code></pre><div class="info"><div class="info">The type for attributes. Name and attribute data.</div></div>
<pre><span class="TYPEtag"><span class="keyword">type</span> tag</span> = <code class="type"><a href="?package=xmlm&amp;module=Xmlm&amp;type=name">name</a> * <a href="?package=xmlm&amp;module=Xmlm&amp;type=attribute">attribute</a> list</code></pre><div class="info"><div class="info">The type for an element tag. Tag name and attribute list.</div></div>
<pre><span class="TYPEsignal"><span class="keyword">type</span> signal</span> = <code class="type">[ `Data of string | `Dtd of <a href="?package=xmlm&amp;module=Xmlm&amp;type=dtd">dtd</a> | `El_end | `El_start of <a href="?package=xmlm&amp;module=Xmlm&amp;type=tag">tag</a> ]</code></pre><div class="info"><div class="info">The type for signals. A <em>well-formed</em> sequence of signals belongs
    to the language of the <code class="code">doc</code> grammar :
    <code class="code">doc ::= `Dtd tree
tree ::= `El_start child `El_end
child ::= `Data | tree | epsilon </code>
    Input and output deal only with well-formed sequences or
    exceptions are raised.</div></div>
<pre><span class="VALns_xml"><span class="keyword">val</span> ns_xml</span> : <code class="type">string</code></pre><div class="info"><div class="info">Namespace name  <a href="http://www.w3.org/XML/1998/namespace">value</a> bound to the 
    reserved <code class="code">&quot;xml&quot;</code> prefix.</div></div>
<pre><span class="VALns_xmlns"><span class="keyword">val</span> ns_xmlns</span> : <code class="type">string</code></pre><div class="info"><div class="info">Namespace name  <a href="http://www.w3.org/2000/xmlns/">value</a> bound to the 
    reserved <code class="code">&quot;xmlns&quot;</code> prefix.</div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Input</h1></div></div>
<pre><span class="TYPEpos"><span class="keyword">type</span> pos</span> = <code class="type">int * int</code></pre><div class="info"><div class="info">The type for input positions. Line and column number, both start
    with 1.</div></div>
<pre><span class="TYPEerror"><span class="keyword">type</span> error</span> = <code class="type">[ `Expected_char_seqs of string list * string
| `Expected_root_element
| `Illegal_char_ref of string
| `Illegal_char_seq of string
| `Malformed_char_stream
| `Max_buffer_size
| `Unexpected_eoi
| `Unknown_encoding of string
| `Unknown_entity_ref of string
| `Unknown_ns_prefix of string ]</code></pre><div class="info"><div class="info">The type for input errors.</div></div>
<pre><span class="VALerror_message"><span class="keyword">val</span> error_message</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm&amp;type=error">error</a> -&gt; string</code></pre><div class="info"><div class="info">Converts the error to an english error message.</div></div>
<pre><span class="EXCEPTIONError"><span class="keyword">exception</span> Error</span> <span class="keyword">of</span> <code class="type"><a href="?package=xmlm&amp;module=Xmlm&amp;type=pos">pos</a> * <a href="?package=xmlm&amp;module=Xmlm&amp;type=error">error</a></code></pre><div class="info"><div class="info">Raised on input errors.</div></div>
<pre><span class="TYPEsource"><span class="keyword">type</span> source</span> = <code class="type">[ `Channel of <a href="?package=ocaml&amp;module=Pervasives&amp;type=in_channel">Pervasives.in_channel</a>
| `Fun of unit -&gt; int
| `String of int * string ]</code></pre><div class="info"><div class="info">The type for input sources. For <code class="code">`String</code> starts reading at the
    given integer position. For <code class="code">`Fun</code> the function must return the
    next <em>byte</em> as an <code class="code">int</code> and raise <code class="code">End_of_file</code> if there is no
    such byte.</div></div>
<pre><span class="TYPEinput"><span class="keyword">type</span> input</span> </pre><div class="info"><div class="info">The type for input abstractions.</div></div>
<pre><span class="VALmake_input"><span class="keyword">val</span> make_input</span> : <code class="type">?enc:<a href="?package=xmlm&amp;module=Xmlm&amp;type=encoding">encoding</a> option -&gt;
?strip:bool -&gt;
?ns:(string -&gt; string option) -&gt;
?entity:(string -&gt; string option) -&gt; <a href="?package=xmlm&amp;module=Xmlm&amp;type=source">source</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm&amp;type=input">input</a></code></pre><div class="info"><div class="info">Returns a new input abstraction reading from the given source.
    <ul><li><code class="code">entity</code> is called to resolve non predefined entity references,
        <a href="#inentity"> details</a>. Default returns always <code class="code">None</code>.</li><li><code class="code">ns</code> is called to bind undeclared namespace prefixes,
        <a href="#inns"> details</a>. Default returns always <code class="code">None</code>.</li><li><code class="code">strip</code>, strips whitespace in character data,  <a href="#inwspace"> details</a>.
       Defaults to <code class="code">false</code>.</li><li><code class="code">enc</code>, character encoding of the document,  <a href="#inenc"> details</a>. 
       Defaults to <code class="code">None</code>.</li></ul></div></div>
<pre><span class="VALinput"><span class="keyword">val</span> input</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm&amp;type=input">input</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm&amp;type=signal">signal</a></code></pre><div class="info"><div class="info">Inputs a signal. Repeated invocation of the function with the same
    input abstraction will generate a  <a href="#TYPEsignal">well-formed</a> sequence
    of signals or an  <a href="#Error">Error</a> is raised. Furthermore there will be no
    two consecutive <code class="code">`Data</code> signals in the sequence and their string
    is always non empty. After a well-formed sequence was input another may 
    be input, see  <a href="#eoi">eoi</a> and  <a href="#iseq">details</a>.<p>    <b>Raises</b>  <a href="#Error">Error</a> on input errors.</p></div></div>
<pre><span class="VALinput_tree"><span class="keyword">val</span> input_tree</span> : <code class="type">el:(<a href="?package=xmlm&amp;module=Xmlm&amp;type=tag">tag</a> -&gt; 'a list -&gt; 'a) -&gt; data:(string -&gt; 'a) -&gt; <a href="?package=xmlm&amp;module=Xmlm&amp;type=input">input</a> -&gt; 'a</code></pre><div class="info"><div class="info">If the next signal is a :
    <ul><li>Other signals, raises <code class="code">Invalid_argument</code>.</li><li><code class="code">`El_start</code> signal, inputs the sequence of signals until its 
       matching <code class="code">`El_end</code> and invokes <code class="code">el</code> and <code class="code">data</code> as follows
    <ul><li><code class="code">data</code>, is called on each <code class="code">`Data</code> signals with the character data. 
      This function won't be called twice consecutively or with the empty 
      string.</li><li><code class="code">el</code>, is called on each <code class="code">`El_end</code> signals with the corresponding 
      <code class="code">`El_start</code> tag and the result of the callback invocation for the 
      element's children.</li></ul></li><li><code class="code">`Data</code> signal, inputs it and invokes <code class="code">data</code> with the character data.</li></ul><p>    <b>Raises</b>  <a href="#Error">Error</a> on input errors and <code class="code">Invalid_argument</code>
      if the next signal is not <code class="code">`El_start</code> or <code class="code">`Data</code>.</p></div></div>
<pre><span class="VALinput_doc_tree"><span class="keyword">val</span> input_doc_tree</span> : <code class="type">el:(<a href="?package=xmlm&amp;module=Xmlm&amp;type=tag">tag</a> -&gt; 'a list -&gt; 'a) -&gt; data:(string -&gt; 'a) -&gt; <a href="?package=xmlm&amp;module=Xmlm&amp;type=input">input</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm&amp;type=dtd">dtd</a> * 'a</code></pre><div class="info"><div class="info">Same as  <a href="#input_tree">input_tree</a> but reads a complete  <a href="#TYPEsignal">well-formed</a>  
    sequence of signals. <p>    <b>Raises</b>  <a href="#Error">Error</a> on input errors and <code class="code">Invalid_argument</code>
     if the next signal is not <code class="code">`Dtd</code>.</p></div></div>
<pre><span class="VALpeek"><span class="keyword">val</span> peek</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm&amp;type=input">input</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm&amp;type=signal">signal</a></code></pre><div class="info"><div class="info">Same as  <a href="#input">input</a> but doesn't remove the signal from the sequence. <p>    <b>Raises</b>  <a href="#Error">Error</a> on input errors.</p></div></div>
<pre><span class="VALeoi"><span class="keyword">val</span> eoi</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm&amp;type=input">input</a> -&gt; bool</code></pre><div class="info"><div class="info">Returns <code class="code">true</code> if the end of input is reached. See  <a href="#iseq">details</a>.<p>    <b>Raises</b>  <a href="#Error">Error</a> on input errors.</p></div></div>
<pre><span class="VALpos"><span class="keyword">val</span> pos</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm&amp;type=input">input</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm&amp;type=pos">pos</a></code></pre><div class="info"><div class="info">Current position in the input abstraction.</div></div>
<div class="info"><div class="info"><h1 id="1_TITLE">Output</h1></div></div>
<pre><span class="TYPEfrag"><span class="keyword">type</span> <code class="type">'a </code>frag</span> = <code class="type">[ `Data of string | `El of <a href="?package=xmlm&amp;module=Xmlm&amp;type=tag">tag</a> * 'a list ]</code></pre><div class="info"><div class="info">The type for deconstructing data structures of type <code class="code">'a</code>.</div></div>
<pre><span class="TYPEdest"><span class="keyword">type</span> dest</span> = <code class="type">[ `Buffer of <a href="?package=ocaml&amp;module=Buffer&amp;type=t">Buffer.t</a>
| `Channel of <a href="?package=ocaml&amp;module=Pervasives&amp;type=out_channel">Pervasives.out_channel</a>
| `Fun of int -&gt; unit ]</code></pre><div class="info"><div class="info">The type for output destinations. For <code class="code">`Buffer</code>, the buffer won't
    be cleared. For <code class="code">`Fun</code> the function is called with the output <em>    bytes</em> as <code class="code">int</code>s.</div></div>
<pre><span class="TYPEoutput"><span class="keyword">type</span> output</span> </pre><div class="info"><div class="info">The type for output abstractions.</div></div>
<pre><span class="VALmake_output"><span class="keyword">val</span> make_output</span> : <code class="type">?decl:bool -&gt;
?nl:bool -&gt;
?indent:int option -&gt; ?ns_prefix:(string -&gt; string option) -&gt; <a href="?package=xmlm&amp;module=Xmlm&amp;type=dest">dest</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm&amp;type=output">output</a></code></pre><div class="info"><div class="info">Returns a new output abstraction writing to the given destination.
    <ul><li><code class="code">ns_prefix</code>, undeclared namespace prefix bindings, 
       see  <a href="#outns">details</a>. Default returns always <code class="code">None</code>.</li><li><code class="code">indent</code>, identation behaviour, see  <a href="#outindent"> details</a>. Defaults to
      <code class="code">None</code>.</li><li><code class="code">nl</code>, if <code class="code">true</code> a newline is output when the root's element <code class="code">`El_end</code> 
     signal is output.
    Defaults to <code class="code">false</code>.</li><li><code class="code">decl</code>, if <code class="code">true</code> the  <a href="http://www.w3.org/TR/REC-xml/#NT-XMLDecl"> XML
     declaration</a> is output (defaults to <code class="code">true</code>).</li></ul></div></div>
<pre><span class="VALoutput"><span class="keyword">val</span> output</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm&amp;type=output">output</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm&amp;type=signal">signal</a> -&gt; unit</code></pre><div class="info"><div class="info">Outputs a signal. After a well-formed sequence of signals was 
    output a new well-formed sequence can be output.<p>    <b>Raises</b> <code class="code">Invalid_argument</code> if the resulting signal sequence on
    the output abstraction is not  <a href="#TYPEsignal">well-formed</a> or if a
    namespace name could not be bound to a prefix.</p></div></div>
<pre><span class="VALoutput_depth"><span class="keyword">val</span> output_depth</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm&amp;type=output">output</a> -&gt; int</code></pre><div class="info"><div class="info"><code class="code">output_depth o</code> is <code class="code">o</code>'s current element nesting level (undefined
    before the first <code class="code">`El_start</code> and after the last <code class="code">`El_end</code>).</div></div>
<pre><span class="VALoutput_tree"><span class="keyword">val</span> output_tree</span> : <code class="type">('a -&gt; 'a <a href="?package=xmlm&amp;module=Xmlm&amp;type=frag">frag</a>) -&gt; <a href="?package=xmlm&amp;module=Xmlm&amp;type=output">output</a> -&gt; 'a -&gt; unit</code></pre><div class="info"><div class="info">Outputs signals corresponding to a value by recursively
    applying the given value deconstructor.<p>    <b>Raises</b> see  <a href="#output">output</a>.</p></div></div>
<pre><span class="VALoutput_doc_tree"><span class="keyword">val</span> output_doc_tree</span> : <code class="type">('a -&gt; 'a <a href="?package=xmlm&amp;module=Xmlm&amp;type=frag">frag</a>) -&gt; <a href="?package=xmlm&amp;module=Xmlm&amp;type=output">output</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm&amp;type=dtd">dtd</a> * 'a -&gt; unit</code></pre><div class="info"><div class="info">Same as  <a href="#output_tree">output_tree</a> but outputs a complete  <a href="#TYPEsignal">well-formed</a> 
    sequence of signals.<p>    <b>Raises</b> see  <a href="#output">output</a>.</p></div></div>
<div class="info"><div class="info"><h1 id="sto">Functorial interface</h1> <p>     <a href="#Make">Make</a> allows client to specify types for strings and internal
    buffers. Among other things this can be used to perform
    hash-consing or to process the character stream, e.g. to normalize
    unicode characters or to convert to a custom encoding.</p></div></div>
<pre><span class="TYPEstd_string"><span class="keyword">type</span> std_string</span> = <code class="type">string</code></pre>
<pre><span class="TYPEstd_buffer"><span class="keyword">type</span> std_buffer</span> = <code class="type"><a href="?package=ocaml&amp;module=Buffer&amp;type=t">Buffer.t</a></code></pre>
<div class="ocaml_module sig" name="String"><pre><span class="keyword">module type</span> <a href="?package=xmlm&amp;module=Xmlm.String">String</a> = <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="info"><div class="info">Input signature for strings.</div></div><div class="ocaml_module_content">
<pre><span class="TYPEt"><span class="keyword">type</span> t</span> </pre><div class="info"><div class="info">The type for strings.</div></div>
<pre><span class="VALempty"><span class="keyword">val</span> empty</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm.String&amp;type=t">t</a></code></pre><div class="info"><div class="info">The empty string.</div></div>
<pre><span class="VALlength"><span class="keyword">val</span> length</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm.String&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info">Returns the length of the string.</div></div>
<pre><span class="VALappend"><span class="keyword">val</span> append</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm.String&amp;type=t">t</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm.String&amp;type=t">t</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm.String&amp;type=t">t</a></code></pre><div class="info"><div class="info">Concatenates two strings.</div></div>
<pre><span class="VALlowercase"><span class="keyword">val</span> lowercase</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm.String&amp;type=t">t</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm.String&amp;type=t">t</a></code></pre><div class="info"><div class="info">New string with uppercase letter translated
      to lowercase (correctness is only needed for ASCII
       <a href="http://www.unicode.org/glossary/#code_point">code point</a>).</div></div>
<pre><span class="VALiter"><span class="keyword">val</span> iter</span> : <code class="type">(int -&gt; unit) -&gt; <a href="?package=xmlm&amp;module=Xmlm.String&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info">Iterates over the unicode 
       <a href="http://www.unicode.org/glossary/#code_point">code point</a>
      of the given string.</div></div>
<pre><span class="VALof_string"><span class="keyword">val</span> of_string</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm&amp;type=std_string">std_string</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm.String&amp;type=t">t</a></code></pre><div class="info"><div class="info">String from an OCaml string.</div></div>
<pre><span class="VALto_utf_8"><span class="keyword">val</span> to_utf_8</span> : <code class="type">('a -&gt; <a href="?package=xmlm&amp;module=Xmlm&amp;type=std_string">std_string</a> -&gt; 'a) -&gt; 'a -&gt; <a href="?package=xmlm&amp;module=Xmlm.String&amp;type=t">t</a> -&gt; 'a</code></pre><div class="info"><div class="info"><code class="code">to_utf_8 f v s</code>, is <code class="code">f (... (f (f v s1) s2) ...) sn</code>. Where the
      concatenation of <code class="code">s1</code>, <code class="code">s2</code>, ... <code class="code">sn</code> is <code class="code">s</code> as an UTF-8 stream.</div></div>
<pre><span class="VALcompare"><span class="keyword">val</span> compare</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm.String&amp;type=t">t</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm.String&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info">String comparison. Binary comparison is sufficent.</div></div></div></div>
<div class="ocaml_module sig" name="Buffer"><pre><span class="keyword">module type</span> <a href="?package=xmlm&amp;module=Xmlm.Buffer">Buffer</a> = <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="info"><div class="info">Input signature for internal buffers.</div></div><div class="ocaml_module_content">
<pre><span class="TYPEstring"><span class="keyword">type</span> string</span> </pre><div class="info"><div class="info">The type for strings.</div></div>
<pre><span class="TYPEt"><span class="keyword">type</span> t</span> </pre><div class="info"><div class="info">The type for buffers.</div></div>
<pre><span class="EXCEPTIONFull"><span class="keyword">exception</span> Full</span></pre><div class="info"><div class="info">Raised if the buffer cannot be grown.</div></div>
<pre><span class="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">int -&gt; <a href="?package=xmlm&amp;module=Xmlm.Buffer&amp;type=t">t</a></code></pre><div class="info"><div class="info">Creates a buffer of the given size.</div></div>
<pre><span class="VALadd_uchar"><span class="keyword">val</span> add_uchar</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm.Buffer&amp;type=t">t</a> -&gt; int -&gt; unit</code></pre><div class="info"><div class="info">Adds the given (guaranteed valid) unicode
       <a href="http://www.unicode.org/glossary/#code_point">code point</a> to a
      buffer. <p>      <b>Raises</b>  <a href="#Full">Full</a> if the buffer cannot be grown.</p></div></div>
<pre><span class="VALclear"><span class="keyword">val</span> clear</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm.Buffer&amp;type=t">t</a> -&gt; unit</code></pre><div class="info"><div class="info">Clears the buffer.</div></div>
<pre><span class="VALcontents"><span class="keyword">val</span> contents</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm.Buffer&amp;type=t">t</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm.Buffer&amp;type=string">string</a></code></pre><div class="info"><div class="info">Returns the buffer contents.</div></div>
<pre><span class="VALlength"><span class="keyword">val</span> length</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm.Buffer&amp;type=t">t</a> -&gt; int</code></pre><div class="info"><div class="info">Returns the number of characters contained in the buffer.</div></div></div></div>
<div class="ocaml_module sig" name="S"><pre><span class="keyword">module type</span> <a href="?package=xmlm&amp;module=Xmlm.S">S</a> = <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="info"><div class="info">Output signature of  <a href="#Make">Make</a>.</div></div><div class="ocaml_module_content">
<div class="info"><div class="info"><h1 id="1_TITLE">Basic types and values</h1></div></div>
<pre><span class="TYPEstring"><span class="keyword">type</span> string</span> </pre>
<pre><span class="TYPEencoding"><span class="keyword">type</span> encoding</span> = <code class="type">[ `ISO_8859_1 | `US_ASCII | `UTF_16 | `UTF_16BE | `UTF_16LE | `UTF_8 ]</code></pre>
<pre><span class="TYPEdtd"><span class="keyword">type</span> dtd</span> = <code class="type"><a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a> option</code></pre>
<pre><span class="TYPEname"><span class="keyword">type</span> name</span> = <code class="type"><a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a> * <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a></code></pre>
<pre><span class="TYPEattribute"><span class="keyword">type</span> attribute</span> = <code class="type"><a href="?package=xmlm&amp;module=Xmlm.S&amp;type=name">name</a> * <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a></code></pre>
<pre><span class="TYPEtag"><span class="keyword">type</span> tag</span> = <code class="type"><a href="?package=xmlm&amp;module=Xmlm.S&amp;type=name">name</a> * <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=attribute">attribute</a> list</code></pre>
<pre><span class="TYPEsignal"><span class="keyword">type</span> signal</span> = <code class="type">[ `Data of <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a> | `Dtd of <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=dtd">dtd</a> | `El_end | `El_start of <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=tag">tag</a> ]</code></pre>
<pre><span class="VALns_xml"><span class="keyword">val</span> ns_xml</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a></code></pre>
<pre><span class="VALns_xmlns"><span class="keyword">val</span> ns_xmlns</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a></code></pre>
<div class="info"><div class="info"><h1 id="1_TITLE">Input</h1></div></div>
<pre><span class="TYPEpos"><span class="keyword">type</span> pos</span> = <code class="type">int * int</code></pre>
<pre><span class="TYPEerror"><span class="keyword">type</span> error</span> = <code class="type">[ `Expected_char_seqs of <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a> list * <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a>
| `Expected_root_element
| `Illegal_char_ref of <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a>
| `Illegal_char_seq of <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a>
| `Malformed_char_stream
| `Max_buffer_size
| `Unexpected_eoi
| `Unknown_encoding of <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a>
| `Unknown_entity_ref of <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a>
| `Unknown_ns_prefix of <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a> ]</code></pre>
<pre><span class="EXCEPTIONError"><span class="keyword">exception</span> Error</span> <span class="keyword">of</span> <code class="type"><a href="?package=xmlm&amp;module=Xmlm.S&amp;type=pos">pos</a> * <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=error">error</a></code></pre>
<pre><span class="VALerror_message"><span class="keyword">val</span> error_message</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm.S&amp;type=error">error</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a></code></pre>
<pre><span class="TYPEsource"><span class="keyword">type</span> source</span> = <code class="type">[ `Channel of <a href="?package=ocaml&amp;module=Pervasives&amp;type=in_channel">Pervasives.in_channel</a>
| `Fun of unit -&gt; int
| `String of int * <a href="?package=xmlm&amp;module=Xmlm&amp;type=std_string">std_string</a> ]</code></pre>
<pre><span class="TYPEinput"><span class="keyword">type</span> input</span> </pre>
<pre><span class="VALmake_input"><span class="keyword">val</span> make_input</span> : <code class="type">?enc:<a href="?package=xmlm&amp;module=Xmlm.S&amp;type=encoding">encoding</a> option -&gt;
?strip:bool -&gt;
?ns:(<a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a> option) -&gt;
?entity:(<a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a> option) -&gt; <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=source">source</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=input">input</a></code></pre>
<pre><span class="VALinput"><span class="keyword">val</span> input</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm.S&amp;type=input">input</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=signal">signal</a></code></pre>
<pre><span class="VALinput_tree"><span class="keyword">val</span> input_tree</span> : <code class="type">el:(<a href="?package=xmlm&amp;module=Xmlm.S&amp;type=tag">tag</a> -&gt; 'a list -&gt; 'a) -&gt; data:(<a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a> -&gt; 'a) -&gt; <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=input">input</a> -&gt; 'a</code></pre>
<pre><span class="VALinput_doc_tree"><span class="keyword">val</span> input_doc_tree</span> : <code class="type">el:(<a href="?package=xmlm&amp;module=Xmlm.S&amp;type=tag">tag</a> -&gt; 'a list -&gt; 'a) -&gt; data:(<a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a> -&gt; 'a) -&gt; <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=input">input</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=dtd">dtd</a> * 'a</code></pre>
<pre><span class="VALpeek"><span class="keyword">val</span> peek</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm.S&amp;type=input">input</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=signal">signal</a></code></pre>
<pre><span class="VALeoi"><span class="keyword">val</span> eoi</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm.S&amp;type=input">input</a> -&gt; bool</code></pre>
<pre><span class="VALpos"><span class="keyword">val</span> pos</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm.S&amp;type=input">input</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=pos">pos</a></code></pre>
<div class="info"><div class="info"><h1 id="1_TITLE">Output</h1></div></div>
<pre><span class="TYPEfrag"><span class="keyword">type</span> <code class="type">'a </code>frag</span> = <code class="type">[ `Data of <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a> | `El of <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=tag">tag</a> * 'a list ]</code></pre>
<pre><span class="TYPEdest"><span class="keyword">type</span> dest</span> = <code class="type">[ `Buffer of <a href="?package=xmlm&amp;module=Xmlm&amp;type=std_buffer">std_buffer</a>
| `Channel of <a href="?package=ocaml&amp;module=Pervasives&amp;type=out_channel">Pervasives.out_channel</a>
| `Fun of int -&gt; unit ]</code></pre>
<pre><span class="TYPEoutput"><span class="keyword">type</span> output</span> </pre>
<pre><span class="VALmake_output"><span class="keyword">val</span> make_output</span> : <code class="type">?decl:bool -&gt;
?nl:bool -&gt;
?indent:int option -&gt; ?ns_prefix:(<a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a> option) -&gt; <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=dest">dest</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=output">output</a></code></pre>
<pre><span class="VALoutput_depth"><span class="keyword">val</span> output_depth</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm.S&amp;type=output">output</a> -&gt; int</code></pre>
<pre><span class="VALoutput"><span class="keyword">val</span> output</span> : <code class="type"><a href="?package=xmlm&amp;module=Xmlm.S&amp;type=output">output</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=signal">signal</a> -&gt; unit</code></pre>
<pre><span class="VALoutput_tree"><span class="keyword">val</span> output_tree</span> : <code class="type">('a -&gt; 'a <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=frag">frag</a>) -&gt; <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=output">output</a> -&gt; 'a -&gt; unit</code></pre>
<pre><span class="VALoutput_doc_tree"><span class="keyword">val</span> output_doc_tree</span> : <code class="type">('a -&gt; 'a <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=frag">frag</a>) -&gt; <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=output">output</a> -&gt; <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=dtd">dtd</a> * 'a -&gt; unit</code></pre></div></div>
<div class="ocaml_module ident" name="Make" path="?package=xmlm&amp;module=Xmlm.S"><pre><span class="keyword">module</span> <a href="?package=xmlm&amp;module=Xmlm.Make">Make</a> : <code class="type"><div class="sig_block"><code class="code">functor (</code><code class="code">String</code><code class="code"> : </code><code class="code"><a href="?package=xmlm&amp;module=Xmlm.String">String</a></code><code class="code">) -&gt; </code><div class="sig_block"><code class="code">functor (</code><code class="code">Buffer</code><code class="code"> : </code><code class="code"><a href="?package=xmlm&amp;module=Xmlm.Buffer">Buffer</a></code> with type <a href="?package=xmlm&amp;module=Xmlm.Buffer&amp;type=string">string</a> = String.t<code class="code">) -&gt; </code><code class="code"><a href="?package=xmlm&amp;module=Xmlm.S">S</a></code> with type <a href="?package=xmlm&amp;module=Xmlm.S&amp;type=string">string</a> = String.t</div></div></code></pre><div class="info"><div class="info">Functor building streaming XML IO with the given strings and buffers.</div></div></div>
<div class="info"><div class="info"><h1 id="io">Features and limitations</h1><p>    The module assumes strings are immutable, thus strings
    the client gives or receives <em>during</em> the input and output process 
    must not be modified.
    </p><h2 id="input">Input</h2>
    <h3 id="inenc">Encoding</h3>    <p>    The parser supports ASCII, US-ASCII, 
     <a href="http://www.faqs.org/rfcs/rfc3629.html"> UTF-8</a>,
     <a href="http://www.faqs.org/rfcs/rfc2781.html"> UTF-16</a>,
     <a href="http://www.faqs.org/rfcs/rfc2781.html"> UTF-16LE</a>,
     <a href="http://www.faqs.org/rfcs/rfc2781.html"> UTF-16BE</a> and
     <a href="http://anubis.dkuug.dk/JTC1/SC2/WG3/docs/n411.pdf">ISO-8559-1</a> 
    (Latin-1) encoded documents. But strings returned by
    the library are <b>always</b> UTF-8 encoded (unless you use the functor). </p><p>    The encoding can be specified explicitly using the optional
    argument <code class="code">enc</code>. Otherwise the parser uses UTF-16 or UTF-8 if there is a
     <a href="http://www.unicode.org/unicode/faq/utf_bom.html#BOM">BOM</a> at the
    beginning of the document. If there is no BOM it uses the encoding
    specified in the  <a href="http://www.w3.org/TR/REC-xml/#NT-XMLDecl"> XML
    declaration</a>. Finally, if there is no XML declaration UTF-8 is assumed.
    </p><h3 id="inwspace">White space handling</h3><p>    The parser performs
     <a href="http://www.w3.org/TR/REC-xml/#AVNormalize">attribute data
    normalization</a> on <em>every</em> attribute data.  This means that
    attribute data does not have leading and trailling white space and that 
    any white space is collapsed and transformed to a single space 
    character (<code class="code">U+0020</code>).</p><p>    White space handling of character data depends on the <code class="code">strip</code>
    argument. If <code class="code">strip</code> is <code class="code">true</code>, character data is treated like
    attribute data, white space before and after elements is removed
    and any white space is collapsed and transformed to a single
    space character (<code class="code">U+0020</code>), except if the data is under the scope of a <em>    xml:space</em> attribute whose value is <em>preserve</em>.  If <code class="code">strip</code> is
    <code class="code">false</code> all white space data is preserved as present in the
    document (however all kinds of
     <a href="http://www.w3.org/TR/REC-xml/#sec-line-ends">line ends</a> are
    translated to the newline character (<code class="code">U+000A</code>).  </p><h3 id="inns">Namespaces</h3><p>    Xmlm's  <a href="#TYPEname">names</a> are
     <a href="http://www.w3.org/TR/xml-names11/#dt-expname">expanded names</a>.
    The parser automatically handles the document's namespace
    declarations.  Undeclared namespace prefixes can be bound via the
    callback <code class="code">ns</code>, which must return a namespace name. If <code class="code">ns</code> returns
    <code class="code">None</code> an <code class="code">`Unknown_ns_prefix</code> error is raised.</p><p>    Attributes used for namespace declarations are preserved by the
    parser. They are in the  <a href="#ns_xmlns">ns_xmlns</a> namespace. Default namespace
    declarations made with <i>xmlns</i> have the attribute name
    <code class="code">(Xmlm.ns_xmlns, &quot;xmlns&quot;)</code>. Prefix declarations have the prefix as
    the local name, for example <i>xmlns:ex</i> results in the attribute name
    <code class="code">(Xmlm.ns_xmlns, &quot;ex&quot;)</code>.</p><p>    Regarding constraints on the usage of the <i>xml</i> and <i>xmlns</i>
    prefixes by documents, the parser does not report errors on violations 
    of the <i>must</i> constraints listed in
     <a href="http://www.w3.org/TR/xml-names11/#xmlReserved">this paragraph</a>. 
    </p><h3 id="inentity">Character and entity references</h3><p>     <a href="http://www.w3.org/TR/REC-xml/#dt-charref">Character references</a>
    and  <a href="http://www.w3.org/TR/REC-xml/#sec-predefined-ent">predefined
    entities</a> are automatically resolved. Other entity references can
    be resolved by the callback <code class="code">entity</code>, which must return an UTF-8
    (unless you use the functor) string corresponding to the
    replacement character data.  The replacement data is <em>not</em>
    analysed for further references, it is added to the data as such
    modulo white space stripping. If <code class="code">entity</code> returns <code class="code">None</code> the error
    <code class="code">`Unknown_entity_ref</code> is returned.    
    </p><h3 id="iseq">Sequences of documents</h3><p>    When a well-formed sequence of signals is input, no data is consumed beyond
    the closing <code class="code">'&gt;'</code> of the document's root element. </p><p>    If you want to parse a document as
     <a href="http://www.w3.org/TR/REC-xml/#NT-document">defined</a> in the XML
    specification, call  <a href="#eoi">eoi</a> after a well-formed sequence of
    signals, it must return <code class="code">true</code>. If you expect another document on
    the same input abstraction a new well-formed sequence of signals
    can be  <a href="#input">input</a>. Use  <a href="#eoi">eoi</a> to check if a document follows (this
    may consume data).</p><p>    Invoking  <a href="#eoi">eoi</a> after a well-formed sequence of signals skips
    whitespaces, comments and processing instructions until it gets to
    either an  <a href="http://www.w3.org/TR/REC-xml/#NT-XMLDecl"> XML
    declaration</a> or a  <a href="http://www.w3.org/TR/REC-xml/#dt-doctype">DTD</a>
    or the start of a new element or the end of input (in which case
     <a href="#eoi">eoi</a> returns <code class="code">true</code>).  If there is a new document but there is no
    XML declaration or the declaration specifies UTF-16, the same
    encoding as for the previous document is used.</p><p>    </p><h3 id="inmisc">Miscellaneous</h3>
    <ul><li>Non validating.</li><li>Tail recursive.</li><li>Attribute and character data chunks are limited by 
       <code class="code">Sys.max_string_length</code> (unless you use the functor). 
       The error <code class="code">`Max_buffer_size</code> is raised if the limit is hit.</li><li>Element attributes are not checked for uniqueness.</li><li>The parser drops 
     <a href="http://www.w3.org/TR/REC-xml/#dt-comment">comments</a>, 
     <a href="http://www.w3.org/TR/REC-xml/#dt-pi">processing instructions</a>, and 
     <a href="http://www.w3.org/TR/REC-xml/#sec-rmd">standalone declaration</a>.</li><li>The  <a href="http://www.w3.org/TR/REC-xml/#dt-doctype">DTD</a> is parsed
      roughly (no guarantee it is well formed) and its information is ignored.</li><li>Parses the more liberal and simpler XML 1.1 
     <a href="http://www.w3.org/TR/xml11/#NT-Name">Name</a> definition (minus <code class="code">':'</code> because
    of namespaces).</li></ul><p>    </p><h2 id="output">Output</h2> 
    <h3 id="outenc">Encoding</h3> <p>    Outputs only  <a href="http://www.faqs.org/rfcs/rfc3629.html"> UTF-8</a>
    encoded documents (even if you use the functor).  Strings given to
    output functions <b>must be</b> UTF-8 encoded (unless you use the
    functor, but you need to provide a translation), no checks are
    performed.  </p><h3 id="outns">Namespaces</h3><p>    Xmlm's  <a href="#TYPEname">names</a> are
     <a href="http://www.w3.org/TR/xml-names11/#dt-expname">expanded names</a>.
    Expanded names are automatically converted to
     <a href="http://www.w3.org/TR/xml-names11/#dt-qualname">qualified
    names</a> by the output abstraction. There is no particular api to specify 
    prefixes and default namespaces, 
    the actual result depends solely on the output
    of attributes belonging to the  <a href="#ns_xmlns">ns_xmlns</a> namespace. For example to set 
    the default namespace of an element to <i>http://example.org/myns</i>, 
    use the following attribute :
    </p><code class="code">(* xmlns='http://example.org/myns' *)
let default_ns = (Xmlm.ns_xmlns, &quot;xmlns&quot;), &quot;http://example.org/myns&quot;</code>
    To bind the prefix <code class="code">&quot;ex&quot;</code> to <i>http://example.org/ex</i>, use the 
    following attribute :
    <code class="code">(* xmlns:ex='http://example.org/ex' *)
let ex_ns = (Xmlm.ns_xmlns, &quot;ex&quot;), &quot;http://example.org/ex&quot;</code>
    Note that outputing input signals without
    touching namespace declaration attributes will preserve existing
    prefixes and bindings provided the same namespace name is not
    bound to different prefixes in a given context.<p>    The callback <code class="code">ns_prefix</code> of an output abstraction can be used to
    give a prefix to a namespace name lacking a prefix binding in the
    current output scope. Given a namespace name the function must return 
    the prefix to use. Note that this
    will <b>not</b> add any namespace declaration attribute to the
    output.  If the function returns <code class="code">None</code>,  <a href="#output">output</a> will raise
    <code class="code">Invalid_argument</code>.  The default function returns always <code class="code">None</code>.
    </p><h3 id="outindent">Indentation</h3><p>    Output can be indented by specifying the <code class="code">indent</code> argument when an
       output abstraction is created. If <code class="code">indent</code> is <code class="code">None</code> (default)
       signal output does not introduce any extra white space.  If
       <code class="code">ident</code> is <code class="code">Some c</code>, each  <a href="#signal">signal</a> is output on its own line
       (for empty elements <code class="code">`El_start</code> and <code class="code">`El_end</code> are collapsed on a single
       line) and nested elements are indented with <code class="code">c</code> space
       characters.
    </p><h3 id="oseq">Sequences of documents</h3> <p>    After a well-formed sequence of signals was output, the output
    abstraction can be reused to output a new well-formed sequence of
    signals.</p><p>    </p><h3 id="outmisc">Miscellaneous</h3>
    <ul><li>Tail recursive.</li><li>No checks are peformed on the prefix and local part of output
      names to verify they are
       <a href="http://www.w3.org/TR/xml-names11/#NT-NCName">NCName</a>s.
      For example using the tag name <code class="code">(&quot;&quot;,&quot;dip d&quot;)</code> will produce 
      a non well-formed document because of the space character.</li><li>In attribute and character data you provide, markup 
       delimiters <code class="code">'&lt;'</code>,<code class="code">'&gt;'</code>,<code class="code">'&amp;'</code>, and <code class="code">'\&quot;'</code> are 
        automatically escaped to 
         <a href="http://www.w3.org/TR/REC-xml/#sec-predefined-ent">predefined
        entities</a>.</li><li>Output on a channel does not flush it.</li></ul><p>    </p><h2 id="2_TITLE">Tips</h2> 
    <ul><li>Complete whitespace control on output is achieved 
       with <code class="code">indent = None</code> and suitable <code class="code">`Data</code> signals</li><li>The best options to do an input/output round trip
       and preserve as much information as possible is to 
       input with <code class="code">strip = false</code> and output with <code class="code">indent = None</code>.</li></ul><p>    </p><h1 id="ex">Examples</h1> <p>    </p><h2 id="exseq">Sequential processing</h2>    <p>    Sequential processing has the advantage that you don't need to get
    the whole document tree in memory to process it.</p><p>    The following function reads a <em>single</em> document on an
    input channel and outputs it.
</p><code class="code">let id ic oc = 
  let i = Xmlm.make_input (`Channel ic) in 
  let o = Xmlm.make_output (`Channel oc) in 
  let rec pull i o depth = 
    Xmlm.output o (Xmlm.peek i);
    match Xmlm.input i with 
    | `El_start _ -&gt; pull i o (depth + 1)
    | `El_end -&gt; if depth = 1 then () else pull i o (depth - 1)
    | `Data _ -&gt; pull i o depth 
    | `Dtd _ -&gt; assert false
  in
  Xmlm.output o (Xmlm.input i); (* `Dtd *)
  pull i o 0;
  if not (Xmlm.eoi i) then invalid_arg &quot;document not well-formed&quot;</code><p>    The following function reads a <em>sequence</em> of documents on an
    input channel and outputs it.
</p><code class="code">let id_seq ic oc = 
  let i = Xmlm.make_input (`Channel ic) in 
  let o = Xmlm.make_output ~nl:true (`Channel oc) in 
  while not (Xmlm.eoi i) do Xmlm.output o (Xmlm.input i) done</code>
    The following function reads a <em>sequence</em> of documents on the 
    input channel. In each document's tree it prunes non root elements
    whose name belongs to <code class="code">prune_list</code>.
<code class="code">let prune_docs prune_list ic oc = 
  let i = Xmlm.make_input (`Channel ic) in
  let o = Xmlm.make_output ~nl:true (`Channel oc) in
  let copy i o = Xmlm.output o (Xmlm.input i) in
  let prune (name, _) = List.mem name prune_list in
  let rec process i o d = 
    let rec skip i d = match Xmlm.input i with
    | `El_start _ -&gt; skip i (d + 1)
    | `El_end -&gt; if d = 1 then () else skip i (d - 1)
    | s -&gt; skip i d
    in
    match Xmlm.peek i with 
    | `El_start tag when prune tag -&gt; skip i 0; process i o d
    | `El_start _ -&gt; copy i o; process i o (d + 1)
    | `El_end -&gt; copy i o; if d = 0 then () else process i o (d - 1)
    | `Data _ -&gt; copy i o; process i o d
    | `Dtd _ -&gt; assert false
  in
  let rec docs i o = 
    copy i o; (* `Dtd *)
    copy i o; (* root start *)
    process i o 0;
    if Xmlm.eoi i then () else docs i o
  in
  docs i o</code><p>    </p><h2 id="extree">Tree processing</h2> <p>    A document's sequence of signals can be easily converted
    to an arborescent data structure. Assume your trees are defined by :
    </p><code class="code">type tree = E of Xmlm.tag * tree list | D of string</code>
    The following functions input/output xml documents from/to abstractions 
    as value of type <code class="code">tree</code>.
<code class="code">let in_tree i = 
  let el tag childs = E (tag, childs)  in
  let data d = D d in
  Xmlm.input_doc_tree ~el ~data i

let out_tree o t = 
  let frag = function
  | E (tag, childs) -&gt; `El (tag, childs) 
  | D d -&gt; `Data d 
  in
  Xmlm.output_doc_tree frag o t</code> <p>    </p><h2 id="exrow">Tabular data processing</h2><p>    We show how to process XML data that represents tabular data (some
    people like do that).</p><p>    The file we need to deal with represents nominal data about
     <a href="http://www.w3.org/">W3C bureaucrats</a>. There are no namespaces
    and attributes are ignored. The element structure of the document
    is :
    </p><ul><li>&lt;list&gt;
     <ul><li>&lt;bureaucrat&gt; represents a W3C bureaucrat
           (zero or more).<p>        A bureaucrat contains the following elements, in order.
        </p><ul><li>&lt;tr&gt; (zero or more, string), technical reports he
               worked on.</li><li>&lt;obfuscation_level&gt; its grade on the
               open scale of obfuscation (mandatory, float).</li><li>&lt;honest&gt; present iff he implemented one of its spec 
               (optional, empty).</li><li>&lt;surname&gt; its surname (mandatory, string).</li><li>&lt;name&gt; its name (mandatory, string).</li></ul></li></ul></li></ul><p>    In OCaml we represent a W3C bureaucrat by this type :
</p><code class="code">type w3c_bureaucrat = { 
    name : string; 
    surname : string; 
    honest : bool; 
    obfuscation_level : float;
    trs : string list; }</code>
    The following functions input and output W3C bureaucrats as lists
    of values of type <code class="code">w3c_bureaucrat</code>.
<code class="code">let in_w3c_bureaucrats src = 
  let i = Xmlm.make_input ~strip:true src in
  let tag n = (&quot;&quot;, n), [] in
  let error () = invalid_arg &quot;parse error&quot; in
  let accept s i = if Xmlm.input i = s then () else error () in
  let rec i_seq el acc i = match Xmlm.peek i with 
  | `El_start _ -&gt; i_seq el ((el i) :: acc) i
  | `El_end -&gt; List.rev acc
  | _ -&gt; error ()
  in
  let i_el n i = 
    accept (`El_start (tag n)) i;
    let d = match Xmlm.peek i with
    | `Data d -&gt; ignore (Xmlm.input i); d
    | `El_end -&gt; &quot;&quot;
    | _ -&gt; error ()
    in
    accept (`El_end) i;
    d
  in
  let i_bureaucrat i = 
    try
      accept (`El_start (tag &quot;bureaucrat&quot;)) i;
      let name = i_el &quot;name&quot; i in
      let surname = i_el &quot;surname&quot; i in
      let honest = match Xmlm.peek i with
      | `El_start ((&quot;&quot;, &quot;honest&quot;), []) -&gt; ignore (i_el &quot;honest&quot; i); true
      | _ -&gt; false
      in
      let obf = float_of_string (i_el &quot;obfuscation_level&quot; i) in
      let trs = i_seq (i_el &quot;tr&quot;) [] i in
      accept (`El_end) i;
      { name = name; surname = surname; honest = honest; 
        obfuscation_level = obf; trs = trs }
    with
    | Failure _ -&gt; error () (* float_of_string *)
  in
  accept (`Dtd None) i;
  accept (`El_start (tag &quot;list&quot;)) i;
  let bl = i_seq i_bureaucrat [] i in
  accept (`El_end) i;
  if not (Xmlm.eoi i) then invalid_arg &quot;more than one document&quot;;
  bl

let out_w3c_bureaucrats dst bl = 
  let tag n = (&quot;&quot;, n), [] in
  let o = Xmlm.make_output ~nl:true ~indent:(Some 2) dst in
  let out = Xmlm.output o in
  let o_el n d = 
    out (`El_start (tag n)); 
    if d &lt;&gt; &quot;&quot; then out (`Data d); 
    out `El_end 
  in
  let o_bureaucrat b = 
    out (`El_start (tag &quot;bureaucrat&quot;));
    o_el &quot;name&quot; b.name;
    o_el &quot;surname&quot; b.surname;
    if b.honest then o_el &quot;honest&quot; &quot;&quot;;
    o_el &quot;obfuscation_level&quot; (string_of_float b.obfuscation_level);
    List.iter (o_el &quot;tr&quot;) b.trs;
    out `El_end
  in
  out (`Dtd None);
  out (`El_start (tag &quot;list&quot;));
  List.iter o_bureaucrat bl;
  out (`El_end)</code></div></div>
</div>